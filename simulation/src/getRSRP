./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'AlertPacket' as cValue -- field index out of range?", field);
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertPacket_m.cc:        field -= base->getFieldCount();
./apps/alert/AlertReceiver.cc:    EV << "AlertReceiver::initialize - binding to port: local:" << port << endl;
./apps/alert/AlertReceiver.cc:        // -------------------- //
./apps/alert/AlertReceiver.cc:    simtime_t delay = simTime() - alert->getPayloadTimestamp();
./apps/alert/AlertReceiver.cc:    EV << "AlertReceiver::handleMessage - Packet received: SeqNo[" << alert->getSno() << "] Delay[" << delay << "]" << endl;
./apps/alert/AlertSender.cc:    EV << "AlertSender::initialize - stage " << stage << endl;
./apps/alert/AlertSender.cc:    // -------------------- //
./apps/alert/AlertSender.cc:    EV << "AlertSender::initialize - binding to port: local:" << localPort_ << " , dest:" << destPort_ << endl;
./apps/alert/AlertSender.cc:            throw cRuntimeError("AlertSender::handleMessage - Unrecognized self message");
./apps/alert/AlertSender.cc:    alert->addTag<CreationTimeTag>()->setCreationTime(simTime());
./apps/alert/AlertSender.cc:    EV << "AlertSender::sendAlertPacket - Sending message [" << nextSno_ << "]\n";
./apps/alert/AlertSender.cc:        EV << "AlertSender::sendAlertPacket - Stop time reached, stopping transmissions" << endl;
./apps/alert/AlertSender.h:    // ----------------------------
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'BurstPacket' as cValue -- field index out of range?", field);
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstPacket_m.cc:        field -= base->getFieldCount();
./apps/burst/BurstReceiver.cc:        EV << "BurstReceiver::initialize - binding to port: local:" << port << endl;
./apps/burst/BurstReceiver.cc:            throw cRuntimeError("BurstReceiver::handleMessage - FATAL! Error when casting to inet::Packet");
./apps/burst/BurstReceiver.cc:    EV << "BurstReceiver::handleMessage - Packet received: FRAME[" << burstHeader->getMsgId() << "] with delay["<< delay << "]" << endl;
./apps/burst/BurstSender.cc:    EV << "BurstSender initialize: stage " << stage << " - initialize=" << initialized_ << endl;
./apps/burst/BurstSender.cc:        EV << simTime() << "BurstSender::initTraffic - destination " << destAddress << " not found" << endl;
./apps/burst/BurstSender.cc:        EV << simTime() << "BurstSender::initTraffic - the node will retry to initialize traffic in " << offset << " seconds " << endl;
./apps/burst/BurstSender.cc:        EV << simTime() << "BurstSender::initialize - binding to port: local:" << localPort_ << " , dest: " << destAddress_.str() << ":" << destPort_ << endl;
./apps/burst/BurstSender.cc:    EV << simTime() << " BurstSender::sendBurst - Start sending burst[" << idBurst_ << "]" << endl;
./apps/burst/BurstSender.cc:    EV << "BurstSender::sendPacket - Sending frame[" << idFrame_ << "] of burst [" << idBurst_ << "], next packet at "<< simTime() + intraBurstTime_ << endl;
./apps/burst/BurstSender.cc:    burst->addTag<CreationTimeTag>()->setCreationTime(simTime());
./apps/burst/BurstSender.h:    // ----------------------------
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'CbrPacket' as cValue -- field index out of range?", field);
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrPacket_m.cc:        field -= base->getFieldCount();
./apps/cbr/CbrReceiver.cc:        EV << "CbrReceiver::initialize - binding to port: local:" << port << endl;
./apps/cbr/CbrReceiver.cc:    if( simTime() > getSimulation()->getWarmupPeriod() )
./apps/cbr/CbrReceiver.cc:    EV << "CbrReceiver::handleMessage - Packet received: FRAME[" << cbrHeader->getIDframe() << "/" << cbrHeader->getNframes() << "] with delay["<< delay << "]" << endl;
./apps/cbr/CbrReceiver.cc:    simtime_t elapsedTime = simTime() - getSimulation()->getWarmupPeriod();
./apps/cbr/CbrSender.cc:    EV << "CBR Sender initialize: stage " << stage << " - initialize=" << initialized_ << endl;
./apps/cbr/CbrSender.cc:        nframes_ = (finishTime_ - startTime_) / sampling_time;
./apps/cbr/CbrSender.cc:            EV << "CbrSender::handleMessage - now[" << simTime() << "] <= finish[" << finishTime_ <<"]" <<endl;
./apps/cbr/CbrSender.cc:        EV << simTime() << "CbrSender::initTraffic - destination " << destAddress << " not found" << endl;
./apps/cbr/CbrSender.cc:        EV << simTime() << "CbrSender::initTraffic - the node will retry to initialize traffic in " << offset << " seconds " << endl;
./apps/cbr/CbrSender.cc:        EV << simTime() << "CbrSender::initialize - binding to port: local:" << localPort_ << " , dest: " << destAddress_.str() << ":" << destPort_ << endl;
./apps/cbr/CbrSender.cc:    cbr->addTag<CreationTimeTag>()->setCreationTime(simTime());
./apps/cbr/CbrSender.cc:    if( simTime() > getSimulation()->getWarmupPeriod() )
./apps/cbr/CbrSender.cc:    simtime_t elapsedTime = simTime() - getSimulation()->getWarmupPeriod();
./apps/cbr/CbrSender.h:    // ----------------------------
./apps/d2dMultihop/eventGenerator/EventGenerator.cc:    appVector_[r]->handleEvent(eventId_);
./apps/d2dMultihop/eventGenerator/EventGenerator.cc:            appVector_[id-UE_MIN_ID]->handleEvent(eventId_);
./apps/d2dMultihop/eventGenerator/EventGenerator.cc:                EV << " - " << mit->first << endl;
./apps/d2dMultihop/eventGenerator/EventGenerator.cc:    lteNodePhy_[lteNodeId] = check_and_cast<LtePhyBase*>((getSimulation()->getModule(binder_->getOmnetId(lteNodeId)))->getSubmodule("cellularNic")->getSubmodule("phy") );
./apps/d2dMultihop/MultihopD2D.cc:            throw cRuntimeError("MultihopD2D::init - FATAL! Total message size cannot be less than D2D_MULTIHOP_HEADER_LENGTH");
./apps/d2dMultihop/MultihopD2D.cc:        EV << "MultihopD2D::initialize - binding to port: local:" << localPort_ << " , dest:" << destPort_ << endl;
./apps/d2dMultihop/MultihopD2D.cc:        // -------------------- //
./apps/d2dMultihop/MultihopD2D.cc:        ltePhy_ = check_and_cast<LtePhyBase*>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("phy"));
./apps/d2dMultihop/MultihopD2D.cc:        LteMacBase* mac = check_and_cast<LteMacBase*>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("mac"));
./apps/d2dMultihop/MultihopD2D.cc:    EV << simTime() << " MultihopD2D::handleEvent - Received event notification " << endl;
./apps/d2dMultihop/MultihopD2D.cc:    auto data = makeShared<ByteCountChunk>(B(msgSize_) - D2D_MULTIHOP_HEADER_LENGTH);
./apps/d2dMultihop/MultihopD2D.cc:    mhop->addTag<CreationTimeTag>()->setCreationTime(simTime());
./apps/d2dMultihop/MultihopD2D.cc:    EV << "MultihopD2D::sendPacket - Sending msg (ID: "<< mhop->getMsgid() << " src: " << lteNodeId_ << " size: " << msgSize_ << ")" <<  endl;
./apps/d2dMultihop/MultihopD2D.cc:    EV << "MultihopD2D::handleRcvdPacket - Received packet from lower layer" << endl;
./apps/d2dMultihop/MultihopD2D.cc:        throw cRuntimeError("MultihopD2D::handleMessage - FATAL! Error when casting to inet packet");
./apps/d2dMultihop/MultihopD2D.cc:        EV << "MultihopD2D::handleRcvdPacket - The message has already been received, counter = " << counter_[msgId] << endl;
./apps/d2dMultihop/MultihopD2D.cc:        simtime_t delay = simTime() - mhop->getPayloadTimestamp();
./apps/d2dMultihop/MultihopD2D.cc:            EV << "MultihopD2D::handleRcvdPacket - The user is selfish, do not forward the message. " << endl;
./apps/d2dMultihop/MultihopD2D.cc:            EV << "MultihopD2D::handleRcvdPacket - The node is outside the broadcast area. Do not forward it. " << endl;
./apps/d2dMultihop/MultihopD2D.cc:            EV << "MultihopD2D::handleRcvdPacket - The TTL for this message has expired. Do not forward it. " << endl;
./apps/d2dMultihop/MultihopD2D.cc:                EV << "MultihopD2D::handleRcvdPacket - start Trickle interval, duration[" << t << "s]" << endl;
./apps/d2dMultihop/MultihopD2D.cc:                EV << "MultihopD2D::handleRcvdPacket - will relay the message in " << offset << "s" << endl;
./apps/d2dMultihop/MultihopD2D.cc:        EV << "MultihopD2D::handleTrickleTimer - relay the message, counter[" << counter_[msgId] << "] k[" << k_ << "]" << endl;
./apps/d2dMultihop/MultihopD2D.cc:        relayPacket(last_[msgId]->dup());
./apps/d2dMultihop/MultihopD2D.cc:        EV << "MultihopD2D::handleTrickleTimer - suppressed message, counter[" << counter_[msgId] << "] k[" << k_ << "]" << endl;
./apps/d2dMultihop/MultihopD2D.cc:        dst->setTtl(--ttl);
./apps/d2dMultihop/MultihopD2D.cc:    EV << "MultihopD2D::relayPacket - Relay msg " << dst->getMsgid() << " to address " << destAddress_ << endl;
./apps/d2dMultihop/MultihopD2D.ned:// - specifying a time-to-live (TTL) for the message, which is decreased every time
./apps/d2dMultihop/MultihopD2D.ned:// - specifying a target broadcast radius for the message: a node relays the message
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MultihopD2DPacket' as cValue -- field index out of range?", field);
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/MultihopD2DPacket_m.h:    virtual inet::Coord& getSrcCoordForUpdate() { handleChange();return const_cast<inet::Coord&>(const_cast<MultihopD2DPacket*>(this)->getSrcCoord());}
./apps/d2dMultihop/statistics/MultihopD2DStatistics.cc:            throw cRuntimeError("d2dMultihopStatistics::recordReception - Event with ID %d does not exist.", eventId);
./apps/d2dMultihop/statistics/MultihopD2DStatistics.cc:            throw cRuntimeError("d2dMultihopStatistics::recordDuplicateReception - Message with ID %d does not exist.", eventId);
./apps/d2dMultihop/statistics/MultihopD2DStatistics.cc:            throw cRuntimeError("d2dMultihopStatistics::recordDuplicateReception - Message with ID %d does not exist.", eventId);
./apps/d2dMultihop/statistics/MultihopD2DStatistics.cc:        throw cRuntimeError("d2dMultihopStatistics::recordDuplicateReception - Message with ID %d does not exist.", eventId);
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'TrickleTimerMsg' as cValue -- field index out of range?", field);
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/d2dMultihop/TrickleTimerMsg_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceApp.cc:                EV << "DeviceApp::handleUALCMPMessage - START" << endl;
./apps/mec/DeviceApp/DeviceApp.cc:                    throw cRuntimeError("DeviceApp::handleUALCMPMessage() - this should not happen. This device app sends well formed requests to the UALCMP.");
./apps/mec/DeviceApp/DeviceApp.cc:                EV << "DeviceApp::handleUALCMPMessage - CREATING" << endl;
./apps/mec/DeviceApp/DeviceApp.cc:                        EV << "DeviceApp::handleUALCMPMessage - ERROR (on CREATE 201) - Mec Application Context not created, i.e. the MEC app has not been instantiated"<< endl;
./apps/mec/DeviceApp/DeviceApp.cc:                        nack->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/DeviceApp/DeviceApp.cc:                        EV << "DeviceApp::handleUALCMPMessage - reference URI of the application instance context is: " << appContextUri << endl;
./apps/mec/DeviceApp/DeviceApp.cc:                        EV << "DeviceApp::handleUALCMPMessage - endPOint of the mec application instance is: " << mecAppEndPoint << endl;
./apps/mec/DeviceApp/DeviceApp.cc:                        ack->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/DeviceApp/DeviceApp.cc:                    EV << "DeviceApp::handleUALCMPMessage - ERROR (on CREATE "<<  response->getCode() << ") - Mec Application Context not created, i.e. the MEC app has not been instantiated"<< endl;
./apps/mec/DeviceApp/DeviceApp.cc:                    nack->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/DeviceApp/DeviceApp.cc:                    EV << "DeviceApp::handleUALCMPMessage - HTTP code " << response->getCode() << " not allowe in CREATE state" << endl;
./apps/mec/DeviceApp/DeviceApp.cc:                    ack->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/DeviceApp/DeviceApp.cc:                    ack->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/DeviceApp/DeviceApp.cc:                    ack->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/DeviceApp/DeviceApp.cc:                throw cRuntimeError("DeviceApp::handleUALCMPMessage() - appstate IDLE. No messages should arrive from the UALCMP");
./apps/mec/DeviceApp/DeviceApp.cc:    EV << "DeviceApp::initialize - UALCMPAddress: " << UALCMPAddress.str() << endl;
./apps/mec/DeviceApp/DeviceApp.cc:        throw cRuntimeError("DeviceApp::sendStartAppContext - DeviceAppStartPacket is null");
./apps/mec/DeviceApp/DeviceApp.cc:        nack->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/DeviceApp/DeviceApp.cc:        throw cRuntimeError("DeviceApp::sendStopAppContext - DeviceAppStopPacket is null");
./apps/mec/DeviceApp/DeviceApp.cc:        EV << "DeviceApp::sendStopAppContext - send DELETE for MEC app: " << appContextUri << endl;
./apps/mec/DeviceApp/DeviceApp.cc:        EV << "DeviceApp::sendStopAppContext - DELETE command already sent - discarding packet" << endl;
./apps/mec/DeviceApp/DeviceApp.cc:        EV << "DeviceApp::sendStopAppContext - LCM proxy not connected" << endl;
./apps/mec/DeviceApp/DeviceApp.cc:        ack->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/DeviceApp/DeviceApp.cc:// ------ UDP socket Callback implementation
./apps/mec/DeviceApp/DeviceApp.cc:    ueAppAddress = pk->getTag<L3AddressInd>()->getSrcAddress();
./apps/mec/DeviceApp/DeviceApp.cc:    ueAppPort = pk->getTag<L4PortInd>()->getSrcPort();
./apps/mec/DeviceApp/DeviceApp.cc:// ------ TCP socket Callback implementation
./apps/mec/DeviceApp/DeviceApp.cc:    std::vector<uint8_t> bytes =  msg->peekDataAsBytes()->getBytes();
./apps/mec/DeviceApp/DeviceApp.cc:        EV << "DeviceApp::socketDataArrived - schedule processedUALCMPMessage" << endl;
./apps/mec/DeviceApp/DeviceApp.cc:    EV <<"DeviceApp::socketEstablished - UALCMPSocket established " << endl;
./apps/mec/DeviceApp/DeviceApp.h: *  - request instantation of a MEC app
./apps/mec/DeviceApp/DeviceApp.h: *  - request termination of a MEC app
./apps/mec/DeviceApp/DeviceApp.h: *  - ACK and NACK about the above requests
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DeviceAppPacket' as cValue -- field index out of range?", field);
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DeviceAppStartPacket' as cValue -- field index out of range?", field);
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DeviceAppStopPacket' as cValue -- field index out of range?", field);
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DeviceAppStartAckPacket' as cValue -- field index out of range?", field);
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DeviceAppStopAckPacket' as cValue -- field index out of range?", field);
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/DeviceAppPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:        int64_t remainders = B(startPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:            throw cRuntimeError("DeviceApp - START_MECAPP_CODE length = %d smaller than required %d bytes", (int)B(startPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:            int64_t remainders = B(ackPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:                throw cRuntimeError("DeviceApp - START_ACK_CODE length = %d smaller than required %d bytes. Data: %s [%lu]",
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:                        (int)B(ackPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get(), sdata.c_str(), sdata.size());
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:            int64_t remainders = B(ackPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:                throw cRuntimeError("DeviceApp - START_NACK_CODE length = %d smaller than required %d bytes", (int)B(ackPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:        int64_t remainders = B(stopPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:            throw cRuntimeError("DeviceApp - STOP_MECAPP_CODE length = %d smaller than required %d bytes", (int)B(stopPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:            int64_t remainders = B(ackPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:                throw cRuntimeError("DeviceApp - STOP_ACK_CODE length = %d smaller than required %d bytes", (int)B(ackPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:            int64_t remainders = B(ackPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:                throw cRuntimeError("DeviceApp - STOP_NACK_CODE length = %d smaller than required %d bytes", (int)B(ackPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:        throw cRuntimeError("DeviceAppMessageSerializer::serialize - Code %s not recognized!", ss.c_str());
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:                throw cRuntimeError("DeviceAppMessageSerializer::deserialize - endPoint must be ip:port, but is: %s ", (char*)&bytes[0]);
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:            throw cRuntimeError("DeviceAppMessageSerializer::deserialize - Code %d not recognized!", messageCode);
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.cc:    throw cRuntimeError("DeviceAppMessageSerializer::deserialize - Cancella codice sotto!");
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.h: * - packet type code (as of DevAppCode enum)
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.h: * - length of the subsequent package size
./apps/mec/DeviceApp/DeviceAppMessages/Serializers/DeviceAppPacketSerializer.h: * - data
./apps/mec/MecApps/MecAppBase.cc:    vim = check_and_cast<VirtualisationInfrastructureManager*>(getParentModule()->getSubmodule("vim"));
./apps/mec/MecApps/MecAppBase.cc:                EV <<"MecAppBase::scheduleNextMsg() - next msg is processed in " << processingTime << "s" << endl;
./apps/mec/MecApps/MecAppBase.cc:                EV << "MecAppBase::handleMessage - no more messages are present in the queue" << endl;
./apps/mec/MecApps/MecAppBase.cc:                    EV << "MecAppBase::handleMessage(): processedHttpMsg - the httpMessageQueue is not empty, schedule next HTTP message" << endl;
./apps/mec/MecApps/MecAppBase.cc:            EV <<"MecAppBase::scheduleNextMsg() - next msg is processed in " << processingTime << "s" << endl;
./apps/mec/MecApps/MecAppBase.cc:            throw cRuntimeError("MecAppBase::handleMessage - This situation is not possible");
./apps/mec/MecApps/MecAppBase.cc://    EV << "MecAppBase::socketDataArrived - payload: " << endl;
./apps/mec/MecApps/MecAppBase.cc:    std::vector<uint8_t> bytes =  msg->peekDataAsBytes()->getBytes();
./apps/mec/MecApps/MecAppBase.cc:            throw cRuntimeError("MecAppBase::socketDataArrived - vim is null!");
./apps/mec/MecApps/MecRequestBackgroundApp/MecRequestBackgroundApp.cc:            EV << "MecRequestBackgroundApp::established - Mp1Socket"<< endl;
./apps/mec/MecApps/MecRequestBackgroundApp/MecRequestBackgroundApp.cc:            EV << "MecRequestBackgroundApp::established - serviceSocket"<< endl;
./apps/mec/MecApps/MecRequestBackgroundApp/MecRequestBackgroundApp.cc:            throw cRuntimeError("MecRequestBackgroundApp::socketEstablished - Socket %d not recognized", connId);
./apps/mec/MecApps/MecRequestBackgroundApp/MecRequestBackgroundApp.cc:        EV << "MecRequestBackgroundApp::handleSelfMessage - selfMessage not recognized" << endl;
./apps/mec/MecApps/MecRequestBackgroundApp/MecRequestBackgroundApp.cc:    EV << "MecRequestBackgroundApp::handleMp1Message - payload: " << mp1HttpMessage->getBody() << endl;
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:            EV << "MecRequestBackgroundGeneratorApp::established - Mp1Socket"<< endl;
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:            EV << "MecRequestBackgroundGeneratorApp::established - serviceSocket"<< endl;
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:            throw cRuntimeError("MecRequestBackgroundGeneratorApp::socketEstablished - Socket %d not recognized", connId);
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:        EV << "MecRequestBackgroundGeneratorApp::handleSelfMessage - selfMessage not recognized" << endl;
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:    EV << "MEWarningAlertApp_rest::handleMp1Message - payload: " << mp1HttpMessage->getBody() << endl;
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:                throw cRuntimeError("MecRequestBackgroundGeneratorApp::initialize - vim is null!");
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:                    EV << "MecRequestBackgroundGeneratorApp::initialize - MecRequestBackgroundGeneratorApp ["<< mecAppId <<"]  cannot be instantiated" << endl;
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc://                    throw cRuntimeError("MecRequestBackgroundGeneratorApp::initialize - MecRequestBackgroundGeneratorApp cannot be instantiated");
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:                EV << "MecRequestBackgroundGeneratorApp::initialize - MecRequestBackgroundGeneratorApp ["<< mecAppId <<"] does not allocate MEC host resources" << endl;
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:        throw cRuntimeError("MecRequestBackgroundGeneratorApp::initialize - vim is null!");
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:            EV << "MecRequestBackgroundGeneratorApp::finish - MEC host did not deallocate MecRequestBackgroundGeneratorApp ["<< mecAppId <<"] resources" << endl;
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc://                    throw cRuntimeError("MecRequestBackgroundGeneratorApp::initialize - MecRequestBackgroundGeneratorApp cannot be instantiated");
./apps/mec/MecApps/MecRequestBackgroundGeneratorApp/MecRequestBackgroundGeneratorApp.cc:        EV << "MecRequestBackgroundGeneratorApp::finish - MecRequestBackgroundGeneratorApp ["<< mecAppId <<"] had not allocated resources" << endl;
./apps/mec/MecApps/MecRequestForegroundApp/MecRequestForegroundApp.cc:        EV << "MecRequestBackgroundApp::handleSelfMessage - selfMessage not recognized" << endl;
./apps/mec/MecApps/MecRequestForegroundApp/MecRequestForegroundApp.cc:            EV << "MecRequestBackgroundApp::established - Mp1Socket"<< endl;
./apps/mec/MecApps/MecRequestForegroundApp/MecRequestForegroundApp.cc:            EV << "MecRequestBackgroundApp::established - serviceSocket"<< endl;
./apps/mec/MecApps/MecRequestForegroundApp/MecRequestForegroundApp.cc:            throw cRuntimeError("MecRequestBackgroundApp::socketEstablished - Socket %d not recognized", connId);
./apps/mec/MecApps/MecRequestForegroundApp/MecRequestForegroundApp.cc:    EV << "MecRequestBackgroundApp::handleMp1Message - payload: " << mp1HttpMessage->getBody() << endl;
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'ProcessingTimeMessage' as cValue -- field index out of range?", field);
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecApps/packets/ProcessingTimeMessage_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:    EV << "MECResponseApp::initialize - MEC application " << getClassName() << " with mecAppId[" << mecAppId << "] has started!" << endl;
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:    EV << "MECResponseApp::initialize - Initialize connection with the Service Registry via Mp1" << endl;
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:                throw cRuntimeError("MECResponseApp::handleProcessedMessage - Type not recognized!");
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:    if (gate("socketOut")->isConnected()) {
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:        throw cRuntimeError("MECResponseApp::handleRequest - currentRequestfMsg_ not null!");
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:    ueAppAddress = packet->getTag<L3AddressInd>()->getSrcAddress();
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:    ueAppPort  = packet->getTag<L4PortInd>()->getSrcPort();
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:    req->setServiceResponseTime(getRequestArrived_ - getRequestSent_);
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:    EV << "MECPlatooningApp::handleMp1Message - payload: " << mp1HttpMessage->getBody() << endl;
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:                EV << "MECPlatooningApp::handleMp1Message - RNIService not found" << endl;
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:        throw cRuntimeError("MECResponseApp::handleServiceMessage() - httpMessage is null!");
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:            EV << "MECResponseApp::handleServiceMessage - response 200 from Socket with Id [" << connId << "]" << endl;
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:            EV << "response time " << getRequestArrived_ - getRequestSent_ << endl;
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:            EV << "MECResponseApp::handleServiceMessage - response with HTTP code:  " << rspMsg->getCode() << endl;
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:    EV << "MECResponseApp::established - connId [" << connId << "]" << endl;
./apps/mec/MecRequestResponseApp/MECResponseApp.cc:        EV << "MECResponseApp::established - Mp1Socket" << endl;
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'RequestResponseAppPacket' as cValue -- field index out of range?", field);
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/packets/RequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::initialize - stage " << stage << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::initialize - starting sendStartMEWarningAlertApp() in " << startTime << " seconds " << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::initialize - binding to port: local:" << localPort_ << " , dest:" << deviceAppPort_ << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:            throw cRuntimeError("UERequestApp::handleMessage - \tWARNING: Unrecognized self message");
./apps/mec/MecRequestResponseApp/UERequestApp.cc:        inet::L3Address ipAdd = packet->getTag<L3AddressInd>()->getSrcAddress();
./apps/mec/MecRequestResponseApp/UERequestApp.cc:                throw cRuntimeError("UERequestApp::handleMessage - \tFATAL! Error when casting to DeviceAppPacket");
./apps/mec/MecRequestResponseApp/UERequestApp.cc:                throw cRuntimeError("UERequestApp::handleMessage - \tFATAL! Error, DeviceAppPacket type %s not recognized", mePkt->getType());
./apps/mec/MecRequestResponseApp/UERequestApp.cc:                throw cRuntimeError("UERequestApp::handleMessage - \tFATAL! Error when casting to RequestAppPacket");
./apps/mec/MecRequestResponseApp/UERequestApp.cc:                throw cRuntimeError("UERequestApp::handleMessage - \tFATAL! Error, RequestAppPacket type %d not recognized", mePkt->getType());
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::sendStartMECRequestApp - Sending " << START_MEAPP <<" type RequestPacket\n";
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    start->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::sendStopMECRequestApp - Sending " << STOP_MEAPP <<" type RequestPacket\n";
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    stop->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::handleAckStartMECRequestApp - Received Start ACK packet" << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:        EV << "UERequestApp::handleAckStartMECRequestApp - Received " << pkt->getType() << " type RequestPacket. mecApp instance is at: "<< mecAppAddress_<< ":" << mecAppPort_ << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:            EV << "UERequestApp::handleAckStartMECRequestApp - Starting sendStopMECRequestApp() in " << stopTime << " seconds " << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:        EV << "UERequestApp::handleAckStartMECRequestApp - MEC application cannot be instantiated! Reason: " << pkt->getReason() << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:        EV << "UERequestApp::initialize - starting sendStartMEWarningAlertApp() in " << startTime << " seconds " << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::handleAckStopMECRequestApp - Received Stop ACK packet" << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::handleAckStopMECRequestApp - Received " << pkt->getType() << " type RequestPacket with result: "<< pkt->getResult() << endl;
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    req->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    req->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    simtime_t upLinkDelay = res->getRequestArrivedTimestamp() - res->getRequestSentTimestamp();
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    simtime_t downLinkDelay = simTime()- res->getResponseSentTimestamp();
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    simtime_t respTime = simTime()- res->getRequestSentTimestamp();
./apps/mec/MecRequestResponseApp/UERequestApp.cc:    EV << "UERequestApp::recvResponse - message with sno [" << res->getSno() << "] " <<
./apps/mec/MecRequestResponseApp/UERequestApp.h:    // --- Functions to interact with the DeviceApp --- //
./apps/mec/MecRequestResponseApp/UERequestApp.h:    // --- Functions to interact with the MECPlatooningApp --- //
./apps/mec/WarningAlert/MECWarningAlertApp.cc:        if(getSimulation()->getSystemModule()->getCanvas()->findFigure(circle) != -1)
./apps/mec/WarningAlert/MECWarningAlertApp.cc:            getSimulation()->getSystemModule()->getCanvas()->removeFigure(circle);
./apps/mec/WarningAlert/MECWarningAlertApp.cc:    EV << "MECWarningAlertApp::initialize - Mec application "<< getClassName() << " with mecAppId["<< mecAppId << "] has started!" << endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:    if(gate("socketOut")->isConnected()){
./apps/mec/WarningAlert/MECWarningAlertApp.cc:    ueAppAddress = pk->getTag<L3AddressInd>()->getSrcAddress();
./apps/mec/WarningAlert/MECWarningAlertApp.cc:    ueAppPort = pk->getTag<L4PortInd>()->getSrcPort();
./apps/mec/WarningAlert/MECWarningAlertApp.cc:        EV << "MECWarningAlertApp::handleUeMessage - WarningStartPacket arrived" << endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:            throw cRuntimeError("MECWarningAlertApp::handleUeMessage - WarningStartPacket is null");
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                myfile <<"["<< NOW << "] MEWarningAlertApp - Received message from UE, connecting to the Location Service\n";
./apps/mec/WarningAlert/MECWarningAlertApp.cc:        throw cRuntimeError("MECWarningAlertApp::handleUeMessage - packet not recognized");
./apps/mec/WarningAlert/MECWarningAlertApp.cc:            myfile <<"["<< NOW << "] MEWarningAlertApp - Sent POST circleNotificationSubscription the Location Service \n";
./apps/mec/WarningAlert/MECWarningAlertApp.cc:        EV << "MECWarningAlertApp::established - Mp1Socket"<< endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:        EV << "MECWarningAlertApp::established - serviceSocket"<< endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:        throw cRuntimeError("MecAppBase::socketEstablished - Socket %d not recognized", connId);
./apps/mec/WarningAlert/MECWarningAlertApp.cc:    EV << "MECWarningAlertApp::handleMp1Message - payload: " << mp1HttpMessage->getBody() << endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                EV << "MECWarningAlertApp::handleMp1Message - LocationService not found"<< endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:        EV << "MECWarningAlertApp::handleTcpMsg - REQUEST " << serviceHttpMessage->getBody()<< endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                    EV << "MECWarningAlertApp::handleTcpMsg - Ue is Entered in the danger zone "<< endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                            myfile <<"["<< NOW << "] MEWarningAlertApp - Received circleNotificationSubscription notification from Location Service. UE's entered the red zone! \n";
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                    EV << "MECWarningAlertApp::handleTcpMsg - Ue left from the danger zone "<< endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                            myfile <<"["<< NOW << "] MEWarningAlertApp - Received circleNotificationSubscription notification from Location Service. UE's exited the red zone! \n";
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                alert->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/WarningAlert/MECWarningAlertApp.cc:            EV << "MECWarningAlertApp::handleTcpMsg - response 204, removing circle" << rspMsg->getBody()<< endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:             getSimulation()->getSystemModule()->getCanvas()->removeFigure(circle);
./apps/mec/WarningAlert/MECWarningAlertApp.cc:            EV << "MECWarningAlertApp::handleTcpMsg - response 201 " << rspMsg->getBody()<< endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:            circle->setBounds(cFigure::Rectangle(centerPositionX - radius, centerPositionY - radius,radius*2,radius*2));
./apps/mec/WarningAlert/MECWarningAlertApp.cc:            getSimulation()->getSystemModule()->getCanvas()->addFigure(circle);
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                EV << "MECWarningAlertApp::handleSelfMessage - service IP address is  unspecified (maybe response from the service registry is arriving)" << endl;
./apps/mec/WarningAlert/MECWarningAlertApp.cc:                EV << "MECWarningAlertApp::handleSelfMessage - service socket is already connected" << endl;
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:        int64_t remainders = B(startPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            throw cRuntimeError("Warning application packet length = %d smaller than required %d bytes", (int)B(startPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:        int64_t remainders = B(stopPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            throw cRuntimeError("Warning application packet length = %d smaller than required %d bytes", (int)B(stopPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:        int64_t remainders = B(alertPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            throw cRuntimeError("Warning application packet length = %d smaller than required %d bytes", (int)B(alertPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:        int64_t remainders = B(alertPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            throw cRuntimeError("Warning application packet length = %d smaller than required %d bytes", (int)B(alertPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            int64_t remainders = B(alertPk->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:                throw cRuntimeError("Warning application packet length = %d smaller than required %d bytes", (int)B(alertPk->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:        throw cRuntimeError("WarningAlertPacketSerializer - WarningAlertPacket type %s not recognized", ss.c_str());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:                throw cRuntimeError("WarningAlertPacketSerializer::deserialize - start application message must be in form x,y,radius. But is %s", data.c_str());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:                throw cRuntimeError("WarningAlertPacketSerializer::deserialize - WARNING application message must be in form x,y. But is %s", data.c_str());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            B remainders = totalLength - (stream.getPosition());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            B remainders = totalLength - (stream.getPosition());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            B remainders = totalLength - (stream.getPosition());
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.cc:            throw cRuntimeError("WarningAlertPacketSerializer::deserialize - Code %d not recognized!", messageCode);
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.h: * - packet type code
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.h: * - length of the subsequent package size
./apps/mec/WarningAlert/packets/Serializers/WarningAlertPacketSerializer.h: * - data
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'WarningAppPacket' as cValue -- field index out of range?", field);
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'WarningAlertPacket' as cValue -- field index out of range?", field);
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'WarningStartPacket' as cValue -- field index out of range?", field);
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'WarningStopPacket' as cValue -- field index out of range?", field);
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/packets/WarningAlertPacket_m.cc:        field -= base->getFieldCount();
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::initialize - stage " << stage << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    sourceSimbolicAddress = (char*)getParentModule()->getFullName();
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    cModule *temp = getParentModule()->getSubmodule("mobility");
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        EV << "UEWarningAlertApp::initialize - \tWARNING: Mobility module NOT FOUND!" << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        throw cRuntimeError("UEWarningAlertApp::initialize - \tWARNING: Mobility module NOT FOUND!");
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::initialize - starting sendStartMEWarningAlertApp() in " << startTime << " seconds " << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::initialize - sourceAddress: " << sourceSimbolicAddress << " [" << inet::L3AddressResolver().resolve(sourceSimbolicAddress).str()  <<"]"<< endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::initialize - destAddress: " << deviceSimbolicAppAddress_ << " [" << deviceAppAddress_.str()  <<"]"<< endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::initialize - binding to port: local:" << localPort_ << " , dest:" << deviceAppPort_ << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        else    throw cRuntimeError("UEWarningAlertApp::handleMessage - \tWARNING: Unrecognized self message");
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        inet::L3Address ipAdd = packet->getTag<L3AddressInd>()->getSrcAddress();
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        // int port = packet->getTag<L4PortInd>()->getSrcPort();
./apps/mec/WarningAlert/UEWarningAlertApp.cc:                throw cRuntimeError("UEWarningAlertApp::handleMessage - \tFATAL! Error when casting to DeviceAppPacket");
./apps/mec/WarningAlert/UEWarningAlertApp.cc:                throw cRuntimeError("UEWarningAlertApp::handleMessage - \tFATAL! Error, DeviceAppPacket type %s not recognized", mePkt->getType());
./apps/mec/WarningAlert/UEWarningAlertApp.cc:                throw cRuntimeError("UEWarningAlertApp::handleMessage - \tFATAL! Error when casting to WarningAppPacket");
./apps/mec/WarningAlert/UEWarningAlertApp.cc:                EV << "UEWarningAlertApp::handleMessage - MEC app did not started correctly, trying to start again" << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:                EV << "UEWarningAlertApp::handleMessage - MEC app started correctly" << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:                throw cRuntimeError("UEWarningAlertApp::handleMessage - \tFATAL! Error, WarningAppPacket type %s not recognized", mePkt->getType());
./apps/mec/WarningAlert/UEWarningAlertApp.cc: * -----------------------------------------------Sender Side------------------------------------------
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    start->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/WarningAlert/UEWarningAlertApp.cc:            myfile <<"["<< NOW << "] UEWarningAlertApp - UE sent start message to the Device App \n";
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::sendStopMEWarningAlertApp - Sending " << STOP_MEAPP <<" type WarningAlertPacket\n";
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    stop->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/WarningAlert/UEWarningAlertApp.cc:            myfile <<"["<< NOW << "] UEWarningAlertApp - UE sent stop message to the Device App \n";
./apps/mec/WarningAlert/UEWarningAlertApp.cc: * ---------------------------------------------Receiver Side------------------------------------------
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        EV << "UEWarningAlertApp::handleAckStartMEWarningAlertApp - Received " << pkt->getType() << " type WarningAlertPacket. mecApp isntance is at: "<< mecAppAddress_<< ":" << mecAppPort_ << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:            EV << "UEWarningAlertApp::handleAckStartMEWarningAlertApp - Starting sendStopMEWarningAlertApp() in " << stopTime << " seconds " << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        EV << "UEWarningAlertApp::handleAckStartMEWarningAlertApp - MEC application cannot be instantiated! Reason: " << pkt->getReason() << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    alert->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./apps/mec/WarningAlert/UEWarningAlertApp.cc:            myfile <<"["<< NOW << "] UEWarningAlertApp - UE sent start subscription message to the MEC application \n";
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::sendMessageToMECApp() - start Message sent to the MEC app" << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::handleInfoMEWarningrAlertApp - Received " << pkt->getType() << " type WarningAlertPacket"<< endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:                myfile <<"["<< NOW << "] UEWarningAlertApp - UE received danger alert TRUE from MEC application \n";
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        EV << "UEWarningAlertApp::handleInfoMEWarningrAlertApp - Warning Alert Detected: DANGER!" << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:                myfile <<"["<< NOW << "] UEWarningAlertApp - UE received danger alert FALSE from MEC application \n";
./apps/mec/WarningAlert/UEWarningAlertApp.cc:        EV << "UEWarningAlertApp::handleInfoMEWarningrAlertApp - Warning Alert Detected: NO DANGER!" << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.cc:    EV << "UEWarningAlertApp::handleAckStopMEWarningAlertApp - Received " << pkt->getType() << " type WarningAlertPacket with result: "<< pkt->getResult() << endl;
./apps/mec/WarningAlert/UEWarningAlertApp.h: * 2.1) ACK --> send coordinates to MEC app
./apps/mec/WarningAlert/UEWarningAlertApp.h: * 2.2) NACK --> do nothing
./apps/mec/WarningAlert/UEWarningAlertApp.ned: //  2.1) ACK --> send coordinates to MEC app
./apps/mec/WarningAlert/UEWarningAlertApp.ned: //  2.2) NACK --> do nothing
./apps/mecRequestResponseApp/MecRequestApp.cc:    EV << "MecRequestApp::initialize - stage " << stage << endl;
./apps/mecRequestResponseApp/MecRequestApp.cc:    sourceSymbolicAddress_ = (char*)getParentModule()->getFullName();
./apps/mecRequestResponseApp/MecRequestApp.cc:    nrPhy_ = check_and_cast<NRPhyUe*>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("nrPhy"));
./apps/mecRequestResponseApp/MecRequestApp.cc:    EV << "MecRequestApp::initialize - sending first packet in " << startTime << " seconds " << endl;
./apps/mecRequestResponseApp/MecRequestApp.cc:            throw cRuntimeError("MecRequestApp::handleMessage - \tWARNING: Unrecognized self message");
./apps/mecRequestResponseApp/MecRequestApp.cc: * -----------------------------------------------Sender Side------------------------------------------
./apps/mecRequestResponseApp/MecRequestApp.cc:    EV << "MecRequestApp::sendRequest - Sending request number " << sno_ << " to " << destAddress_.str() << endl;
./apps/mecRequestResponseApp/MecRequestApp.cc: * ---------------------------------------------Receiver Side------------------------------------------
./apps/mecRequestResponseApp/MecRequestApp.cc:        throw cRuntimeError("MecRequestApp::handleRequest - FATAL! Error when casting to inet packet");
./apps/mecRequestResponseApp/MecRequestApp.cc:    double rtt = simTime().dbl() - reqTimestamp;
./apps/mecRequestResponseApp/MecRequestApp.cc:    EV << "MecRequestApp::recvResponse - sno["<< sno << "] rtt[" << rtt << "]" << endl;
./apps/mecRequestResponseApp/MecResponseApp.cc:    EV << "MecResponseApp::initialize - stage " << stage << endl;
./apps/mecRequestResponseApp/MecResponseApp.cc:        EV << "CbrReceiver::initialize - binding to port: local:" << port << endl;
./apps/mecRequestResponseApp/MecResponseApp.cc:    EV << "MecResponseApp::handleMessage - \n";
./apps/mecRequestResponseApp/MecResponseApp.cc:        throw cRuntimeError("MecResponseApp::handleRequest - FATAL! Error when casting to inet packet");
./apps/mecRequestResponseApp/MecResponseApp.cc:    EV << simTime() << "MecResponseApp::handleRequest - Received packet with number " << reqPkt->getSno() << ": delay: "<< delay << endl;
./apps/mecRequestResponseApp/MecResponseApp.cc:    EV << simTime() << "MecResponseApp::handleRequest - sending response in " << responseTime << " seconds " << endl;
./apps/mecRequestResponseApp/MecResponseApp.cc:        throw cRuntimeError("MecResponseApp::sendResponse - FATAL! Error when casting to inet packet");
./apps/mecRequestResponseApp/MecResponseApp.cc:    EV << simTime() << "MecResponseApp::sendResponse - Send response for packet with number " << pkt->getSno() << " to " << reqSourceAddress << "(port " << reqSourcePort << ")" << endl;
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MecRequestResponsePacket' as cValue -- field index out of range?", field);
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MecRequestResponsePacket_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MigrationTimer' as cValue -- field index out of range?", field);
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/mecRequestResponseApp/packets/MigrationTimer_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'M1Message' as cValue -- field index out of range?", field);
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.cc:        field -= base->getFieldCount();
./apps/vod/M1Message_m.h:    virtual inet::L3Address& getClientAddrForUpdate() { return const_cast<inet::L3Address&>(const_cast<M1Message*>(this)->getClientAddr());}
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'VoDPacket' as cValue -- field index out of range?", field);
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDPacket_m.cc:        field -= base->getFieldCount();
./apps/vod/VoDUDPClient.cc:        receiveStream((VoDPacket*) (msg));   //FIXME: must decapsulate - see https://inet.omnetpp.org/docs/developers-guide/ch-packets.html
./apps/vod/VoDUDPClient.cc:    simtime_t delay = simTime() - sendingTime;
./apps/vod/VoDUDPClient.cc:    double tputSample = (double)totalRcvdBytes_ / (simTime() - getSimulation()->getWarmupPeriod());
./apps/vod/VoDUDPServer.cc:            throw cRuntimeError("VoDUDPServer::initialize - only SVC trace is currently available. Abort.");
./apps/vod/VoDUDPServer.cc:        frame->addTag<CreationTimeTag>()->setCreationTime(simTime());
./apps/vod/VoDUDPServer.cc:            frame->addTag<CreationTimeTag>()->setCreationTime(simTime());
./apps/voip/VoipPacketSerializer.cc:    int64_t remainders = B(voipPacket->getChunkLength() - (stream.getLength() - startPosition)).get();
./apps/voip/VoipPacketSerializer.cc:        throw cRuntimeError("VoipPacket length = %d smaller than required %d bytes", (int)B(voipPacket->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./apps/voip/VoipPacketSerializer.cc:    B remainders = dataLength - (stream.getPosition() - startPosition);
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'VoipPacket' as cValue -- field index out of range?", field);
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoipPacket_m.cc:        field -= base->getFieldCount();
./apps/voip/VoIPReceiver.cc:    EV << "VoIPReceiver::initialize - binding to port: local:" << port << endl;
./apps/voip/VoIPReceiver.cc:    warmUpPer_ = getSimulation()->getWarmupPeriod();
./apps/voip/VoIPReceiver.cc:        throw cRuntimeError("VoIPReceiver::handleMessage - FATAL! Error when casting to inet packet");
./apps/voip/VoIPReceiver.cc:    EV << "VoIPReceiver::handleMessage - Packet received: TALK[" << voipHeader->getIDtalk() << "] - FRAME[" << voipHeader->getIDframe() << " size: " << voipHeader->getChunkLength() << " bytes]\n";
./apps/voip/VoIPReceiver.cc:    double interval = SIMTIME_DBL(simTime() - warmUpPer_);
./apps/voip/VoIPReceiver.cc:            maxId = std::max(maxId, (*it)->getIDframe());
./apps/voip/VoIPReceiver.cc:        channelLoss = maxId + 1 - mPacketsList_.size();
./apps/voip/VoIPReceiver.cc:        channelLoss = pPacket->getNframes() - mPacketsList_.size();
./apps/voip/VoIPReceiver.cc:        sample = SIMTIME_DBL(pPacket->getArrivalTime() - pPacket->getPayloadTimestamp());
./apps/voip/VoIPReceiver.cc:        last_jitter = pPacket->getArrivalTime() - pPacket->getPlayoutTime();
./apps/voip/VoIPReceiver.cc:            EV << "VoIPReceiver::playout - Jitter measured: " << last_jitter << " TALK[" << pPacket->getIDtalk() << "] - FRAME[" << IDframe << "]\n";
./apps/voip/VoIPReceiver.cc:                    EV << "VoIPReceiver::playout - Duplicated Packet: TALK[" << pPacket->getIDtalk() << "] - FRAME[" << IDframe << "]\n";
./apps/voip/VoIPReceiver.cc:                    EV << "VoIPReceiver::playout - out of time packet deleted: TALK[" << pPacket->getIDtalk() << "] - FRAME[" << IDframe << "]\n";
./apps/voip/VoIPReceiver.cc:                while( !mPlayoutQueue_.empty() && pPacket->getArrivalTime() > mPlayoutQueue_.front()->getPlayoutTime() )
./apps/voip/VoIPReceiver.cc:                        EV << "VoIPReceiver::playout - Sampleable packet inserted into buffer: TALK["<< pPacket->getIDtalk() << "] - FRAME[" << IDframe
./apps/voip/VoIPReceiver.cc:                           << "] - arrival time[" << pPacket->getArrivalTime() << "] -  sampling time[" << pPacket->getPlayoutTime() << "]\n";
./apps/voip/VoIPReceiver.cc:                    --mBufferSpace_;
./apps/voip/VoIPReceiver.cc:                        EV << "VoIPReceiver::playout - Buffer is full, discarding packet: TALK[" << pPacket->getIDtalk() << "] - FRAME["
./apps/voip/VoIPReceiver.cc:                           << IDframe << "] - arrival time[" << pPacket->getArrivalTime() << "]\n";
./apps/voip/VoIPReceiver.cc:        EV << "VoIPReceiver::playout - proportionalLoss " << proportionalLoss << "(tailDropLoss=" << tailDropLoss << " - playoutLoss="
./apps/voip/VoIPReceiver.cc:           <<  playoutLoss << " - channelLoss=" << channelLoss << ")\n\n";
./apps/voip/VoIPReceiver.cc:        EV << "VoIPReceiver::playout - Computed MOS: eModel( " << mPlayoutDelay_ << " , " << tailDropLoss << "+" << playoutLoss << "+"
./apps/voip/VoIPReceiver.cc:        EV << "VoIPReceiver::playout - Playout Delay Adaptation \n" << "\t Old Playout Delay: " << mPlayoutDelay_ << "\n\t Max Jitter Measured: "
./apps/voip/VoIPReceiver.cc:    int u = ((delayms - 177.3) > 0 ? 1 : 0);
./apps/voip/VoIPReceiver.cc:    id = 0.024 * delayms + 0.11 * (delayms - 177.3) * u;
./apps/voip/VoIPReceiver.cc:    double ie_eff = emodel_Ie_ + (95 - emodel_Ie_) * p / (p + emodel_Bpl_);
./apps/voip/VoIPReceiver.cc:    double Rfactor = emodel_Ro_ - id - ie_eff + emodel_A_;
./apps/voip/VoIPReceiver.cc:            (Rfactor - 60) * (100 - Rfactor);
./apps/voip/VoIPSender.cc:    warmUpPer_ = getSimulation()->getWarmupPeriod();
./apps/voip/VoIPSender.cc:        EV << simTime() << "VoIPSender::initTraffic - destination " << destAddress << " not found" << endl;
./apps/voip/VoIPSender.cc:        EV << simTime() << "VoIPSender::initTraffic - the node will retry to initialize traffic in " << offset << " seconds " << endl;
./apps/voip/VoIPSender.cc:        EV << simTime() << "VoIPSender::initialize - binding to port: local:" << localPort_ << " , dest: " << destAddress_.str() << ":" << destPort_ << endl;
./apps/voip/VoIPSender.cc:    EV << "VoIPSender::talkspurt - TALKSPURT[" << iDtalk_-1 << "] - Will be created[" << nframes_ << "] frames\n\n";
./apps/voip/VoIPSender.cc:        EV << "VoIPSender::selectPeriodTime - Silence Period: " << "Duration[" << durSil_ << "/" << durSil2 << "] seconds\n";
./apps/voip/VoIPSender.cc:        EV << "VoIPSender::selectPeriodTime - Talkspurt[" << iDtalk_ << "] - Duration[" << durTalk_ << "/" << durTalk2 << "] seconds\n";
./apps/voip/VoIPSender.cc:    voip->setIDtalk(iDtalk_ - 1);
./apps/voip/VoIPSender.cc:    voip->addTag<CreationTimeTag>()->setCreationTime(simTime());
./apps/voip/VoIPSender.cc:    EV << "VoIPSender::sendVoIPPacket - Talkspurt[" << iDtalk_-1 << "] - Sending frame[" << iDframe_ << "]\n";
./apps/voip/VoIPSender.cc:    --nframesTmp_;
./apps/voip/VoIPSender.cc:    double interval = SIMTIME_DBL(simTime() - warmUpPer_);
./apps/voip/VoIPSender.h:    // ----------------------------
./common/binder/Binder.cc:        EV << "Binder::registerCarrier - Carrier @ " << carrierFrequency << "GHz already registered" << endl;
./common/binder/Binder.cc:        EV << "Binder::registerCarrier - Registered component carrier @ " << carrierFrequency << "GHz" << endl;
./common/binder/Binder.cc:        throw cRuntimeError("Binder::registerCarrierUe - Carrier [%fGHz] not found", carrierFrequency);
./common/binder/Binder.cc:        throw cRuntimeError("Binder::getCarrierUeSet - Carrier [%fGHz] not found", carrierFrequency);
./common/binder/Binder.cc:            throw cRuntimeError("Binder::computeSlotFormat - Number of symbols not valid - DL[%d] UL[%d]", tddNumSymbolsDl,tddNumSymbolsUl);
./common/binder/Binder.cc:        sf.numFlexSymbols = numSymbols - tddNumSymbolsDl - tddNumSymbolsUl;
./common/binder/Binder.cc:        throw cRuntimeError("Binder::getSlotFormat - Carrier [%fGHz] not found", carrierFrequency);
./common/binder/Binder.cc:    EV << NOW << " Binder::unregisterNode - unregistering node " << id << endl;
./common/binder/Binder.cc:        EV_ERROR << "Cannot unregister node - node id \"" << id << "\" - not found";
./common/binder/Binder.cc:        EV_ERROR << "Cannot unregister node - node id \"" << id << "\" - not found";
./common/binder/Binder.cc:        cConfigurationEx* configEx = getEnvir()->getConfigEx();
./common/binder/Binder.cc:        outputFilenameStr << "-" << itervars << "repetition=" << configEx->getVariable("repetition") << ".ini";
./common/binder/Binder.cc:            LteMacBase* macUe = check_and_cast<LteMacBase*>(info->ue->getSubmodule("cellularNic")->getSubmodule("nrMac"));
./common/binder/Binder.cc:                int bgCellId = cellId - 2;
./common/binder/Binder.cc:         throw cRuntimeError("Binder::getUpfFromMecHost - address not found");
./common/binder/Binder.cc:        throw cRuntimeError("Binder::getModuleNameByMacNodeId - node ID not found");
./common/binder/Binder.cc:        throw cRuntimeError("Binder::getModuleByMacNodeId - node ID not found");
./common/binder/Binder.cc:    if (lastUplinkTransmission_ < NOW - 2*TTI)
./common/binder/Binder.cc:        throw cRuntimeError("Binder::getX2Port - No ports available on node %d", nodeId);
./common/binder/Binder.cc:    EV << "Binder::medianCqi - median point is " << bandCqi.size() << "/2 = " << medianPoint << ". MedianCqi = " << bandCqi[medianPoint] << endl;
./common/binder/Binder.cc:        throw cRuntimeError("Binder::checkD2DCapability - Node Id not valid. Src %d Dst %d", src, dst);
./common/binder/Binder.cc:            EV << "Binder::checkD2DCapability - UE " << src << " may transmit to UE " << dst << " using D2D (current mode " << ((d2dPeeringMap_[src][dst] == DM) ? "DM)" : "IM)") << endl;
./common/binder/Binder.cc:            EV << "Binder::checkD2DCapability - UE " << src << " may not transmit to UE " << dst << " using D2D (UE " << dst << " is not D2D capable)" << endl;
./common/binder/Binder.cc:        throw cRuntimeError("Binder::getD2DCapability - Node Id not valid. Src %d Dst %d", src, dst);
./common/binder/Binder.cc:        throw cRuntimeError("Binder::getD2DMode - Node Id not valid. Src %d Dst %d", src, dst);
./common/binder/Binder.cc:        if ((*it)->id == id)
./common/binder/Binder.cc:            (*it)->cellId = newCellId;
./common/binder/Binder.cc:    EV << " ===== Binder::computeAverageCqiForBackgroundUes - START =====" << endl;
./common/binder/Binder.cc:     *  - Update interference
./common/binder/Binder.cc:     *  - Compute SINR with interference
./common/binder/Binder.cc:     *  - Update cell block usage according to connect UEs
./common/binder/Binder.cc:        // --- MAIN Interference Check Cycle --- //
./common/binder/Binder.cc:            //---------------------------------------------------------------------
./common/binder/Binder.cc:                //---------------------------------------------------------------------
./common/binder/Binder.cc:                //---------------------------------------------------------------------
./common/binder/Binder.cc:                    throw cRuntimeError("Binder::computeAverageCqiForBackgroundUes - Error! Computed negative requested rbs\n");
./common/binder/Binder.cc://            std::cout << "BgTrafficManager " << bgTrafficManagerId << " - UE[" << cont << "] cqiDl[" << cqiDl << "] cqiUl[" << cqiUl << "] "<< endl;
./common/binder/Binder.cc:    EV << " ===== Binder::computeAverageCqiForBackgroundUes - END =====" << endl;
./common/binder/Binder.cc:    EV << "Binder::updateMutualInterference - computing interference for traffic manager " << bgTrafficManagerId << " dir[" << dirToA(dir) << "]" << endl;
./common/binder/Binder.cc:            EV << "ownId[" << bgTrafficManagerId << "] extId[" << extId << "] - ownRbs[" << ownRbs << "] extRbs[" << extRbs << "] - overlap[" << newOverlapPercentage << "]" << endl;
./common/binder/Binder.cc:            int bgUeId = (*bgUes_it)->getId();
./common/binder/Binder.cc:                    int extBgUeId = (*extBgUes_it)->getId();
./common/binder/Binder.cc:                    EV << "ownId[" << globalBgUeId << "] extId[" << globalExtBgUeId << "] - ownRbs[" << ownRbs << "] extRbs[" << extRbs << "] - overlap[" << newOverlapPercentage << "]" << endl;
./common/binder/Binder.cc:            interfCoord = (extInfo->bgTrafficManager)->getBsCoord();
./common/binder/Binder.cc:            interfTxPower = (extInfo->bgTrafficManager)->getBsTxPower();
./common/binder/Binder.cc:                interferenceDbm = (extInfo->bgTrafficManager)->getReceivedPower_bgUe(interfTxPower, interfCoord, rxPos, dir, otherLos);
./common/binder/Binder.cc:                int extBgUeId = (*extBgUes_it)->getId();
./common/binder/Binder.cc:                interfCoord = (*extBgUes_it)->getCoord();
./common/binder/Binder.cc:                interfTxPower = (*extBgUes_it)->getTxPwr();
./common/binder/Binder.cc:                    interferenceDbm = (extInfo->bgTrafficManager)->getReceivedPower_bgUe(interfTxPower, interfCoord, rxPos, dir, otherLos);
./common/binder/Binder.cc:    sinr = recvSignalDbm - denomDbm;
./common/binder/Binder.cc:    double sinrRange = MAX_SINR - MIN_SINR;
./common/binder/Binder.cc:    EV << "Binder::computeRequestedRbsFromSinr - sinr[" << sinr << "] - bitRate[" << bitRate << "] - rbs[" << rbs << "]" << endl;
./common/binder/Binder.cc:        enb = (*it)->eNodeB;
./common/binder/Binder.cc:                EV << "LteBinder::addUeCollector - UeCollector for node [" << ue << "] already present in eNodeB [" << (*it)->id << "]" << endl;
./common/binder/Binder.cc:                throw cRuntimeError("LteBinder::addUeCollector - UeCollector for node [%d] already present in eNodeB [%d]", ue,(*it)->id ) ;
./common/binder/Binder.cc:            EV << "LteBinder::addUeCollector - eNodeB [" << (*it)->id << "] does not have the eNodeBStatsCollector" << endl;
./common/binder/Binder.cc://            throw cRuntimeError("LteBinder::addUeCollector - eNodeB [%d] does not have the eNodeBStatsCollector", (*it)->id ) ;
./common/binder/Binder.cc:    enb = getParentModule()->getSubmodule(getModuleNameByMacNodeId(cell));
./common/binder/Binder.cc:        EV << "LteBinder::addUeCollector - UeCollector for node [" << ue << "] added to eNodeB [" << cell << "]" << endl;
./common/binder/Binder.cc:        EV << "LteBinder::addUeCollector - eNodeB [" << cell << "] does not have the eNodeBStatsCollector." <<
./common/binder/Binder.cc://        throw cRuntimeError("LteBinder::addUeCollector - eNodeBStatsCollector not present in eNodeB [%d]",(*it)->id ) ;
./common/binder/Binder.cc:    cModule *oldEnb = getParentModule()->getSubmodule(cellModuleName); //  eNobe module
./common/binder/Binder.cc:           throw cRuntimeError("LteBinder::moveUeCollector - UeStatsCollector of node [%d] not present in eNodeB [%d]", ue,oldCell ) ;
./common/binder/Binder.cc:        throw cRuntimeError("LteBinder::moveUeCollector - eNodeBStatsCollector not present in eNodeB [%d]", oldCell) ;
./common/binder/Binder.cc:                throw cRuntimeError("LteBinder::moveUeCollector - Ue [%d] has not got NRueCollector required for the gNB", ue) ;
./common/binder/Binder.cc:                throw cRuntimeError("LteBinder::moveUeCollector - Ue [%d] has not got ueCollector required for the eNB", ue) ;
./common/binder/Binder.cc:            throw cRuntimeError("LteBinder::moveUeCollector - The new cell is not a cell [%d]", newCellType) ;
./common/binder/Binder.h:    std::vector<MacNodeId> nextHop_; // MacNodeIdMaster --> MacNodeIdSlave
./common/binder/Binder.h:    DeployedUesMap dMap_; // DeployedUes --> Master Mapping
./common/binder/Binder.h:        return extCellList_[carrierFrequency].size() - 1;
./common/binder/Binder.h:        return bgSchedulerList_[carrierFrequency].size() - 1;
./common/blerCurves/BLERvsSINR_15CQI_AWGN.h:/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
./common/blerCurves/BLERvsSINR_15CQI_AWGN.h:            // std::cout << SINR_15_CQI_AWGN [CQI] [i] << " - " << SINR_15_CQI_AWGN [CQI] [i+1] << std::endl;
./common/blerCurves/BLERvsSINR_15CQI_AWGN.h:      R = (SINR - SINR_15_CQI_AWGN [CQI-1] [index]) / ( SINR_15_CQI_AWGN [CQI-1] [index + 1] - SINR_15_CQI_AWGN [CQI-1] [index] );
./common/blerCurves/BLERvsSINR_15CQI_AWGN.h:      BLER = BLER_15_CQI_AWGN [CQI-1] [index] + R * ( BLER_15_CQI_AWGN [CQI-1] [index + 1] - BLER_15_CQI_AWGN [CQI-1] [index] );
./common/blerCurves/BLERvsSINR_15CQI_TU.h:/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
./common/blerCurves/BLERvsSINR_15CQI_TU.h:              //std::cout << SINR_15_CQI_TU [CQI-1] [i] << " - " << SINR_15_CQI_TU [CQI-1] [i+1] << std::endl;
./common/blerCurves/BLERvsSINR_15CQI_TU.h:      R = (SINR - SINR_15_CQI_TU [CQI-1] [index]) / ( SINR_15_CQI_TU [CQI-1] [index + 1] - SINR_15_CQI_TU [CQI-1] [index] );
./common/blerCurves/BLERvsSINR_15CQI_TU.h:      BLER = BLER_15_CQI_TU [CQI-1] [index] + R * ( BLER_15_CQI_TU [CQI-1] [index + 1] - BLER_15_CQI_TU [CQI-1] [index] );
./common/blerCurves/PhyPisaData.cc:        x = normal(getEnvir()->getRNG(0), 0, 0.5);
./common/blerCurves/PhyPisaData.cc:        y = normal(getEnvir()->getRNG(0), 0, 0.5);
./common/carrierAggregation/CarrierAggregation.ned:    // Carrier Frequency (GHz) -->
./common/carrierAggregation/ComponentCarrier.cc:        throw omnetpp::cRuntimeError("ComponentCarrier::initialize - numerology index [%d] not valid. It must be in the range between 0-4.", numerologyIndex_);
./common/cellInfo/CellInfo.cc:        cellId_ = getParentModule()->par("macCellId");
./common/cellInfo/CellInfo.cc:    // RBsubcarriers * (TTISymbols - SignallingSymbols) - pilotREs
./common/cellInfo/CellInfo.cc:    ulRbSymbols *= 2; // slot --> RB
./common/cellInfo/CellInfo.cc:    dlRbSymbols *= 2; // slot --> RB
./common/cellInfo/CellInfo.cc:    *mcsUl = ulRbSubcarriers * (ulRbSymbols - ulSigSymbols) - ulPilotRe;
./common/cellInfo/CellInfo.cc:    *mcsDl = dlRbSubCarriers * (dlRbSymbols - dlSigSymbols) - dlPilotRe;
./common/cellInfo/CellInfo.cc:    // RBsubcarriers * (TTISymbols - SignallingSymbols) - pilotREs
./common/cellInfo/CellInfo.cc:    rbSymbols *= 2; // slot --> RB
./common/cellInfo/CellInfo.cc:    *mcs = rbSubcarriers * (rbSymbols - sigSymbols) - pilotRe;
./common/cellInfo/CellInfo.cc:    int index = intuniform(0, binder_->phyPisaData.maxChannel() - 1);
./common/cellInfo/CellInfo.cc:        throw omnetpp::cRuntimeError("CellInfo::getCarrierNumBands - Carrier %f is not used on node %d", carrierFrequency, cellId_);
./common/cellInfo/CellInfo.cc:        throw omnetpp::cRuntimeError("CellInfo::registerCarrier - Carrier [%fGHz] already exists on node %d", carrierFrequency, cellId_);
./common/cellInfo/CellInfo.cc:        EV << "CellInfo::registerCarrier - Registered carrier @ " << carrierFrequency << "GHz" << endl;
./common/cellInfo/CellInfo.cc:            it->second.lastBand = b + it->second.numBands - 1;
./common/cellInfo/CellInfo.cc:            EV << "* [" << it->first << "GHz] - range[" << it->second.firstBand << "-" << it->second.lastBand << "]" << endl;
./common/cellInfo/CellInfo.cc:            // --- create usable bands structure --- //
./common/cellInfo/CellInfo.cc:        throw omnetpp::cRuntimeError("CellInfo::getCellwiseBand - Carrier %f is not used on node %d", carrierFrequency, cellId_);
./common/cellInfo/CellInfo.cc:        throw omnetpp::cRuntimeError("CellInfo::getCellwiseBand - Selected band [%d] is greater than the number of available band on this carrier [%d]", index, it->second.numBands);
./common/cellInfo/CellInfo.cc:        throw omnetpp::cRuntimeError("CellInfo::getCarrierBandLimit - Carrier %f is not used on node %d", carrierFrequency, cellId_);
./common/cellInfo/CellInfo.cc:        throw omnetpp::cRuntimeError("CellInfo::getCarrierStartingBand - Carrier [%fGHz] not found", carrierFrequency);
./common/cellInfo/CellInfo.cc:        throw omnetpp::cRuntimeError("CellInfo::getCarrierStartingBand - Carrier [%fGHz] not found", carrierFrequency);
./common/cellInfo/CellInfo.cc:            throw omnetpp::cRuntimeError("CellInfo::computeSlotFormat - Number of symbols not valid - DL[%d] UL[%d]", tddNumSymbolsDl,tddNumSymbolsUl);
./common/cellInfo/CellInfo.cc:        sf.numFlexSymbols = numSymbols - tddNumSymbolsDl - tddNumSymbolsUl;
./common/cellInfo/CellInfo.h:    //---------------------------------------------------------------
./common/cellInfo/CellInfo.ned:        // eNodeB type (MICRO / MACRO) - valid only for eNodeBs
./common/Circular.h:        --size_;
./common/Circular.h:        --size_;
./common/LteCommon.cc:     * ---------------------------
./common/LteCommon.cc:     *    DL     | eNb ---->  UE
./common/LteCommon.cc:     *    UL     | UE  ---->  eNb
./common/LteCommon.cc:     *    D2D    | UE  ---->  UE
./common/LteCommon.cc:    EV << "ctrlInfoToMacCid - dir[" << dir << "] - ueId[" << ueId << "] - lcid[" << lcid << "]" << endl;
./common/LteCommon.cc:     * ---------------------------
./common/LteCommon.cc:     *    DL     | eNb ---->  UE
./common/LteCommon.cc:     *    UL     | UE  ---->  eNb
./common/LteCommon.cc:     *    D2D    | UE  ---->  UE
./common/LteCommon.cc:            throw cRuntimeError("ctrlInfoToMacCid - unknown direction %d", dir);
./common/LteCommon.cc:    omnetpp::cModule* module = getSimulation()->getModule(omnetid);
./common/LteCommon.cc:    int id = getBinder()->getOmnetId(nodeId);
./common/LteCommon.cc:        return (getSimulation()->getModule(id)->getSubmodule("cellularNic")->getSubmodule("nrPhy"));
./common/LteCommon.cc:    return (getSimulation()->getModule(id)->getSubmodule("cellularNic")->getSubmodule("phy"));
./common/LteCommon.cc:	int id = getBinder()->getOmnetId(nodeId);
./common/LteCommon.cc:	    return (getSimulation()->getModule(id)->getSubmodule("cellularNic")->getSubmodule("nrMac"));
./common/LteCommon.cc:	return (getSimulation()->getModule(id)->getSubmodule("cellularNic")->getSubmodule("mac"));
./common/LteCommon.cc:        return getSimulation()->getModule(getBinder()->getOmnetId(nodeId))->getSubmodule("cellularNic")->getSubmodule("nrRlc")->getSubmodule(rlcTypeToA(rlcType).c_str());
./common/LteCommon.cc:    return getSimulation()->getModule(getBinder()->getOmnetId(nodeId))->getSubmodule("cellularNic")->getSubmodule("rlc")->getSubmodule(rlcTypeToA(rlcType).c_str());
./common/LteCommon.cc:    int id = getBinder()->getOmnetId(nodeId);
./common/LteCommon.cc:    return (getSimulation()->getModule(id)->getSubmodule("cellularNic")->getSubmodule("pdcpRrc"));
./common/LteCommon.cc:    return check_and_cast<Binder*>(getSimulation()->getModuleByPath("binder"));
./common/LteCommon.cc:        const char* name = (*it)->getAttribute("name");
./common/LteCommon.cc:        const char* type = (*it)->getAttribute("type");
./common/LteCommon.cc:        const char* value = (*it)->getAttribute("value");
./common/LteCommon.cc:    return pow(10, (db - 30) / 10);
./common/LteCommon.cc:                if(!gate->getChannel()->initialized()){
./common/LteCommon.cc:                        gate->getChannel()->callInitialize();
./common/LteCommon.h://|--------------------------------------------------|
./common/LteCommon.h:// Codeword List - returned by Harq functions
./common/LteControlInfo.msg:// - FlowControlInfo contains information with flow granularity.
./common/LteControlInfo.msg:// - UserControlInfo contains information with user granularity.
./common/LteControlInfo.msg:// - Source MAC Node ID
./common/LteControlInfo.msg:// - Destination MAC Node ID
./common/LteControlInfo.msg:// - IP Control Informations: the four tuple, a sequence number and
./common/LteControlInfo.msg:// - Traffic Control Informations: Application, Direction, Traffic
./common/LteControlInfo.msg:// - RLC Control Informations: the traffic type (TM, UM, AM)
./common/LteControlInfo.msg:// - Connection information: Logical CID
./common/LteControlInfo.msg:// - H-ARQ Control Information
./common/LteControlInfo.msg:// - PHY Control Informations: Broadcast, Corruption, Type,
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteControlInfo' as cValue -- field index out of range?", field);
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'FlowControlInfo' as cValue -- field index out of range?", field);
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'UserControlInfo_Base' as cValue -- field index out of range?", field);
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.cc:        field -= base->getFieldCount();
./common/LteControlInfo_m.h: * // - Source MAC Node ID
./common/LteControlInfo_m.h: * // - Destination MAC Node ID
./common/LteControlInfo_m.h: * // - IP Control Informations: the four tuple, a sequence number and
./common/LteControlInfo_m.h: * // - Traffic Control Informations: Application, Direction, Traffic
./common/LteControlInfo_m.h: * // - RLC Control Informations: the traffic type (TM, UM, AM)
./common/LteControlInfo_m.h: * // - Connection information: Logical CID
./common/LteControlInfo_m.h: * // - H-ARQ Control Information
./common/LteControlInfo_m.h: * // - PHY Control Informations: Broadcast, Corruption, Type,
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'TMultiTimerMsg' as cValue -- field index out of range?", field);
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TMultiTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimer.cc:        remaining = (it->first - NOW);
./common/timer/TTimer.cc:            simtime_t time = directList_.begin()->first;
./common/timer/TTimer.cc:            unsigned int event = directList_.begin()->second;
./common/timer/TTimer.h:     * @param module - the connected module
./common/timer/TTimer.h:        return NOW - start_;
./common/timer/TTimer.h:        return expire_ - NOW;
./common/timer/TTimer.h:    //!Timer identifier - will be inserted in each timer-generated message
./common/timer/TTimer.h:    //!Timer identifier - will be inserted in each timer-generated message
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'TTimerMsg' as cValue -- field index out of range?", field);
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/timer/TTimerMsg_m.cc:        field -= base->getFieldCount();
./common/utils/utlis.cc://        if (request == 0) throw cRuntimeError("UEWarningAlertApp_rest::handleMessage - \tFATAL! Error when casting to MEAppPacket");
./corenetwork/gtp/GtpUser.cc:        bool connectedBS = isBaseStation(ownerType_) && getParentModule()->gate("ppp$o")->isConnected();
./corenetwork/gtp/GtpUser.cc:        myMacNodeID = getParentModule()->par("macNodeId");
./corenetwork/gtp/GtpUser.cc:    EV << "GtpUser::selectOwnerType - setting owner type to " << type << endl;
./corenetwork/gtp/GtpUser.cc:    error("GtpUser::selectOwnerType - unknown owner type [%s]. Aborting...",type);
./corenetwork/gtp/GtpUser.cc:    if (strcmp(msg->getArrivalGate()->getFullName(), "trafficFlowFilterGate") == 0)
./corenetwork/gtp/GtpUser.cc:        EV << "GtpUser::handleMessage - message from trafficFlowFilter" << endl;
./corenetwork/gtp/GtpUser.cc:    else if(strcmp(msg->getArrivalGate()->getFullName(),"socketIn")==0)
./corenetwork/gtp/GtpUser.cc:        EV << "GtpUser::handleMessage - message from udp layer" << endl;
./corenetwork/gtp/GtpUser.cc:     *    --> delete the packet
./corenetwork/gtp/GtpUser.cc:     * 2) tftId -- 0, we are on a BS and the destination is a UE under the same gNB
./corenetwork/gtp/GtpUser.cc:     *    --> forward the packet to the local LTE/NR NIC
./corenetwork/gtp/GtpUser.cc:     *    --> tunnel the packet towards the CN gateway
./corenetwork/gtp/GtpUser.cc:     *        --> tunnel the packet towards the MEC host
./corenetwork/gtp/GtpUser.cc:     *        --> tunnel the packet towards the CN gateway
./corenetwork/gtp/GtpUser.cc:     *        --> tunnel the packet towards its serving BS
./corenetwork/gtp/GtpUser.cc:     *        --> tunnel the packet towards the CN gateway
./corenetwork/gtp/GtpUser.cc:    EV << "GtpUser::handleFromTrafficFlowFilter - Received a tftMessage with flowId[" << flowId << "]" << endl;
./corenetwork/gtp/GtpUser.cc:        EV << "GtpUser::handleFromTrafficFlowFilter - Destination has been removed from the simulation. Delete packet." << endl;
./corenetwork/gtp/GtpUser.cc:            EV << "GtpUser::handleFromTrafficFlowFilter - tunneling to " << gwAddress_.str() << endl;
./corenetwork/gtp/GtpUser.cc:            EV << "GtpUser::handleFromTrafficFlowFilter - tunneling to " << destAddr.str() << endl;
./corenetwork/gtp/GtpUser.cc:            EV << "GtpUser::handleFromTrafficFlowFilter - tunneling to " << symbolicName << endl;
./corenetwork/gtp/GtpUser.cc:     *    --> the destination is for sure a UE served by this BS, hence we decapsulate the packet and deliver it locally
./corenetwork/gtp/GtpUser.cc:     *    --> the destination is for sure the MEC host, hence we decapsulate the packet and deliver it locally
./corenetwork/gtp/GtpUser.cc:     *        --> the destination is for sure outside this network (e.g. a remote server or a node within another radio network),
./corenetwork/gtp/GtpUser.cc:     *             --> we decapsulate the packet and deliver it to the outbound interface
./corenetwork/gtp/GtpUser.cc:     *             --> we decapsulate the packet, re-encapsulate it and send it to the correct BS
./corenetwork/gtp/GtpUser.cc:    EV << "GtpUser::handleFromUdp - Decapsulating and forwarding to the correct destination" << endl;
./corenetwork/gtp/GtpUser.cc:    originalPacket->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&Protocol::ipv4);
./corenetwork/gtp/GtpUser.cc:            originalPacket->addTagIfAbsent<InterfaceReq>()->setInterfaceId(ie_->getInterfaceId());
./corenetwork/gtp/GtpUser.cc:        EV << "GtpUser::handleFromUdp - Datagram local delivery to " << destAddr.str() << endl;
./corenetwork/gtp/GtpUser.cc:        EV << "GtpUser::handleFromUdp - Datagram local delivery to " << destAddr.str() << endl;
./corenetwork/gtp/GtpUser.cc:            const char* destGw = binder_->getModuleByMacNodeId(destMaster)->par("gateway");
./corenetwork/gtp/GtpUser.cc:            if (strcmp(this->getParentModule()->getFullName(), destGw) == 0)
./corenetwork/gtp/GtpUser.cc:                EV << "GtpUser::handleFromUdp - tunneling to BS " << symbolicName << endl;
./corenetwork/gtp/GtpUser.cc:                EV << "GtpUser::handleFromUdp - Tunneling datagram to " << tunnelPeerAddress.str() << ", final destination[" << destAddr.str() << "]" << endl;
./corenetwork/gtp/GtpUser.cc:        EV << "GtpUser::handleFromUdp - Sending datagram outside the radio network, destination[" << destAddr.str() << "]" << endl;
./corenetwork/gtp/GtpUserMsgSerializer.cc:    int64_t remainders = B(gtpUserMsg->getChunkLength() - (stream.getLength() - startPosition)).get();
./corenetwork/gtp/GtpUserMsgSerializer.cc:        throw cRuntimeError("gtpUserMsg length = %d smaller than required %d bytes", (int)B(gtpUserMsg->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./corenetwork/gtp/GtpUserMsgSerializer.cc:    B remainders = dataLength - (stream.getPosition() - startPosition);
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'GtpUserMsg' as cValue -- field index out of range?", field);
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserMsg_m.cc:        field -= base->getFieldCount();
./corenetwork/gtp/GtpUserX2.cc://    X2NodeId nodeId = check_and_cast<LteMacEnb*>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("mac"))->getMacNodeId();
./corenetwork/gtp/GtpUserX2.cc://    const char* moduleName = getParentModule()->getFullName();
./corenetwork/gtp/GtpUserX2.cc:    if (strcmp(msg->getArrivalGate()->getFullName(), "lteStackIn") == 0)
./corenetwork/gtp/GtpUserX2.cc:        EV << "GtpUserX2::handleMessage - message from X2 Manager" << endl;
./corenetwork/gtp/GtpUserX2.cc:    else if(strcmp(msg->getArrivalGate()->getFullName(),"socketIn")==0)
./corenetwork/gtp/GtpUserX2.cc:        EV << "GtpUserX2::handleMessage - message from udp layer" << endl;
./corenetwork/gtp/GtpUserX2.cc:    EV << "GtpUserX2::handleFromStack - Received a LteX2Message with destId[" << destId << "]" << endl;
./corenetwork/gtp/GtpUserX2.cc:    pkt->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&LteProtocol::gtp);
./corenetwork/gtp/GtpUserX2.cc:    EV << "GtpUserX2::handleFromUdp - Decapsulating and sending to local connection." << endl;
./corenetwork/gtp/GtpUserX2.cc:    pkt->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&LteProtocol::x2ap);
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        mac_ = check_and_cast<LteMacEnb *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("mac"));
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        pdcp_ = check_and_cast<LtePdcpRrcEnb *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("pdcpRrc"));
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        cModule *rlc = getParentModule()->getSubmodule("cellularNic")->getSubmodule("rlc");
./corenetwork/statsCollector/BaseStationStatsCollector.cc:            rlc_ = check_and_cast<LteRlcUm *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("rlc")->getSubmodule("um"));
./corenetwork/statsCollector/BaseStationStatsCollector.cc:            throw cRuntimeError("%s::initialize - EnodeB statistic collector only works with RLC in UM mode", collectorType_.c_str() );
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        if(getParentModule()->getSubmodule("cellularNic")->findSubmodule("packetFlowManager") != -1)
./corenetwork/statsCollector/BaseStationStatsCollector.cc:            EV << collectorType_ << "::initialize - packetFlowManager reference" << endl;
./corenetwork/statsCollector/BaseStationStatsCollector.cc:            packetFlowManager_ = check_and_cast<PacketFlowManagerEnb *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("packetFlowManager"));
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        cellInfo_ = check_and_cast<CellInfo *>(getParentModule()->getSubmodule("cellInfo"));
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        EV << collectorType_ << "::handleMessage - get " << msg->getName() << "statistics" << endl;
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        EV << collectorType_ << "::handleMessage - it is not a self message" << endl;
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        throw cRuntimeError("%s::addUeCollector - UeStatsCollector already present for UE nodeid[%d]", collectorType_.c_str(), id);
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        EV << "BaseStationStatsCollector::removeUeCollector - removing UE pfm stats for UE with id["<<id<<"]"<< endl;
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        throw cRuntimeError("%s::removeUeCollector - UeStatsCollector not present for UE nodeid[%d]", collectorType_.c_str(), id);
./corenetwork/statsCollector/BaseStationStatsCollector.cc:       throw cRuntimeError("%s::removeUeCollector - UeStatsCollector not present for UE nodeid[%d]", collectorType_.c_str(), id);
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        EV << collectorType_ << "::add_dl_nongbr_delay_perUser - delay: " << delay << " for node id: " << ue.first << endl;
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        EV << collectorType_ << "::add_ul_nongbr_data_volume_ue_perUser - received :" << bytes << "B in UL from node id: " << ue.first << endl;
./corenetwork/statsCollector/BaseStationStatsCollector.cc:           EV << collectorType_ << "::add_dl_nongbr_data_volume_ue_perUser - sent :" << bytes << "B in DL to node id: " << ue.first << endl;
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        EV << collectorType_ << "::add_dl_nongbr_throughput_ue_perUser - tput: " << throughput << " for node " << ue.first << endl;
./corenetwork/statsCollector/BaseStationStatsCollector.cc:        EV << collectorType_ << "::add_ul_nongbr_throughput_ue_perUser - tput: " << throughput << " for node " << ue.first << endl;
./corenetwork/statsCollector/BaseStationStatsCollector.h:         * - PRB usage (TTI)
./corenetwork/statsCollector/BaseStationStatsCollector.h:         * - # active UEs
./corenetwork/statsCollector/BaseStationStatsCollector.h:         * - Discard rate
./corenetwork/statsCollector/BaseStationStatsCollector.h:         * - Packet delay
./corenetwork/statsCollector/BaseStationStatsCollector.h:         * - PDCP bytes
./corenetwork/statsCollector/BaseStationStatsCollector.h:         * - scheduled tput
./corenetwork/statsCollector/BaseStationStatsCollector.h:         *  - the UeStatsCollector of an UE;
./corenetwork/statsCollector/BaseStationStatsCollector.h:         *  - nullptr if nodeId is not present
./corenetwork/statsCollector/L2Measures/L2MeasBase.cc:        sum_ -= values_.at(index_);
./corenetwork/statsCollector/L2Measures/L2MeasBase.cc:        return mean < 0 ? 0: mean; // round could returns -0.00 -> -1
./corenetwork/statsCollector/UeStatsCollector.cc:        mac_ = check_and_cast<LteMacBase *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("mac"));
./corenetwork/statsCollector/UeStatsCollector.cc://        pdcp_ = check_and_cast<LtePdcpRrcUe *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("pdcpRrc"));
./corenetwork/statsCollector/UeStatsCollector.cc:                if(getParentModule()->getSubmodule("cellularNic")->findSubmodule("nrPacketFlowManager") != -1)
./corenetwork/statsCollector/UeStatsCollector.cc:                    EV << collectorType_ << "::initialize - NRpacketFlowManager reference" << endl;
./corenetwork/statsCollector/UeStatsCollector.cc:                    packetFlowManager_ = check_and_cast<PacketFlowManagerUe *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("nrPacketFlowManager"));
./corenetwork/statsCollector/UeStatsCollector.cc:                    throw cRuntimeError("%s::initialize - NRUe does not have NRpacketFlowManager. This should not happen", collectorType_.c_str());
./corenetwork/statsCollector/UeStatsCollector.cc:                if(getParentModule()->getSubmodule("cellularNic")->findSubmodule("packetFlowManager") != -1)
./corenetwork/statsCollector/UeStatsCollector.cc:                    EV << collectorType_ << "::initialize - packetFlowManager reference" << endl;
./corenetwork/statsCollector/UeStatsCollector.cc:                    packetFlowManager_ = check_and_cast<PacketFlowManagerUe *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("packetFlowManager"));
./corenetwork/statsCollector/UeStatsCollector.cc:                    throw cRuntimeError("%s::initialize - Ue does not have packetFlowManager. This should not happen", collectorType_.c_str());
./corenetwork/statsCollector/UeStatsCollector.cc:            if(getParentModule()->getSubmodule("cellularNic")->findSubmodule("packetFlowManager") != -1)
./corenetwork/statsCollector/UeStatsCollector.cc:                packetFlowManager_ = check_and_cast<PacketFlowManagerUe *>(getParentModule()->getSubmodule("cellularNic")->getSubmodule("packetFlowManager"));
./corenetwork/statsCollector/UeStatsCollector.cc:        packetFlowManager_ ->resetDelayCounter();
./corenetwork/statsCollector/UeStatsCollector.cc:            EV << "UeStatsCollector::add_ul_nongbr_delay_ue() - delay: " << delay << endl;
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'TftControlInfo' as cValue -- field index out of range?", field);
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TftControlInfo_m.cc:        field -= base->getFieldCount();
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:        gateway_ = getParentModule()->getFullName();
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    else if(getParentModule()->hasPar("gateway") || getParentModule()->getParentModule()->hasPar("gateway"))
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:                throw cRuntimeError("TrafficFlowFilter::initialize - Bad extMeApps parameter. It must be like address/mask");
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:            EV << "TrafficFlowFilter::initialize - emulation support:  meAppsExtAddres: " << meAppsExtAddress_.str()<<"/"<< meAppsExtAddressMask_<< endl;
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    if(getParentModule()->hasPar("mecHost")){
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:        meHost = getParentModule()->par("mecHost").stringValue();
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:            EV << "TrafficFlowFilter::initialize - meHost: " << meHost << " meHostAddress: " << meHostAddress.str() << endl;
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    EV << "TrafficFlowFilter::selectOwnerType - setting owner type to " << type << endl;
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:        error("TrafficFlowFilter::selectOwnerType - unknown owner type [%s]. Aborting...",type);
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    EV << "TrafficFlowFilter::handleMessage - Received Packet:" << endl;
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    pkt->addTagIfAbsent<DispatchProtocolReq>()->setProtocol(&Protocol::ipv4);
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    pkt->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&Protocol::ipv4);
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    EV << "TrafficFlowFilter::handleMessage - Received datagram : " << pkt->getName() << " - src[" << srcAddr << "] - dest[" << destAddr << "]\n";
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    EV << "TrafficFlowFilter::handleMessage - setting tft=" << tftId << endl;
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:        const char* destGw = (inet::L3AddressResolver().findHostWithAddress(destAddress))->getAncestorPar("gateway").stringValue();
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:        EV << "TrafficFlowFilter::findTrafficFlow - returning flowId (-3) for tunneling to " << destAddress.str() << endl;
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:        EV << "TrafficFlowFilter::findTrafficFlow - returning flowId (-3) for tunneling to " << destAddress.str() << " (external) " << endl;
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:        EV << "TrafficFlowFilter::findTrafficFlow - destination "<< destAddress.str() << " is not a UE. ";
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:        EV << "TrafficFlowFilter::findTrafficFlow - destination " << destAddress.str() << " is a UE [" << destId << "] not attached to any BS. Remove packet from the simulation." << endl;
./corenetwork/trafficFlowFilter/TrafficFlowFilter.cc:    const char* destGw = binder_->getModuleByMacNodeId(destMaster)->par("gateway");
Binary file ./libsimu5g.dll matches
Binary file ./libsimu5g.dll.a matches
Binary file ./libsimu5g_dbg.dll matches
Binary file ./libsimu5g_dbg.dll.a matches
./Makefile:#  opp_makemake --make-so -f --deep -o simu5g -O out -KINET4_4_PROJ=../../inet4.4 -DINET_IMPORT -I. -I$$\(INET4_4_PROJ\)/src -L$$\(INET4_4_PROJ\)/src -lINET$$\(D\)
./Makefile:#------------------------------------------------------------------------------
./Makefile:$(error Config file '$(CONFIGFILE)' does not exist -- add the OMNeT++ bin directory to the path so that opp_configfilepath can be found, or set the OMNETPP_CONFIGFILE variable to point to Makefile.inc)
./Makefile:#------------------------------------------------------------------------------
./Makefile:#------------------------------------------------------------------------------
./Makefile:	-$(Q)-$(LN) $(<:%.dll=%.lib) $(@:%.dll=%.lib) 2>/dev/null
./makefrag:MSGC:=$(MSGC) --msg6
./nodes/backgroundCell/BackgroundCell.ned:        // Pathloss scenario from ITU -->   
./nodes/backgroundCell/BackgroundCell.ned:        // eNodeB height -->
./nodes/backgroundCell/BackgroundCell.ned:        // Building height -->
./nodes/backgroundCell/BackgroundCell.ned:        // Antenna Gain of UE -->
./nodes/backgroundCell/BackgroundCell.ned:        // Antenna Gain of eNodeB -->
./nodes/backgroundCell/BackgroundCell.ned:        // Antenna Gain of Micro node -->
./nodes/backgroundCell/BackgroundCell.ned:        // Thermal Noise for 10 MHz of Bandwidth -->
./nodes/backgroundCell/BackgroundCell.ned:        // Ue noise figure -->
./nodes/backgroundCell/BackgroundCell.ned:        // eNodeB noise figure -->
./nodes/backgroundCell/BackgroundCell.ned:        // Cable Loss -->
./nodes/backgroundCell/BackgroundCell.ned:        // If true enable the possibility to switch dinamically the LOS/NLOS pathloss computation -->
./nodes/backgroundCell/BackgroundCell.ned:        // If dynamic-los is false this parameter, if true, compute LOS pathloss otherwise compute NLOS pathloss -->
./nodes/backgroundCell/BackgroundCell.ned:        // Enable/disable fading -->  
./nodes/backgroundCell/BackgroundCell.ned:        // Fading type (JAKES or RAYGHLEY) -->  
./nodes/backgroundCell/BackgroundCell.ned:        // If jakes fading this parameter specify the number of path (tap channel) -->  
./nodes/backgroundCell/BackgroundCell.ned:        // if true, enables the inter-cell interference computation for UL and DL connections from background cells -->  
./nodes/backgroundCell/BackgroundCell.ned:        // if true, enables the inter-cell interference computation for DL connections -->  
./nodes/backgroundCell/BackgroundCell.ned:        // if true, enables the interference computation for UL connections -->
./nodes/backgroundCell/BackgroundCellAmc.cc:    // RBsubcarriers * (TTISymbols - SignallingSymbols) - pilotREs
./nodes/backgroundCell/BackgroundCellAmc.cc:    ulRbSymbols *= 2; // slot --> RB
./nodes/backgroundCell/BackgroundCellAmc.cc:    dlRbSymbols *= 2; // slot --> RB
./nodes/backgroundCell/BackgroundCellAmc.cc:    mcsScaleUl_ = mcsScaleD2D_ = ulRbSubcarriers * (ulRbSymbols - ulSigSymbols) - ulPilotRe;
./nodes/backgroundCell/BackgroundCellAmc.cc:    mcsScaleDl_ = dlRbSubCarriers * (dlRbSymbols - dlSigSymbols) - dlPilotRe;
./nodes/backgroundCell/BackgroundCellAmc.cc:        EV << NOW << " BackgroundCellAmc::computeBitsPerRbBackground - CQI equal to zero, return no bytes available" << endl;
./nodes/backgroundCell/BackgroundCellAmc.cc:    EV << NOW << " BackgroundCellAmc::computeBitsPerRbBackground Modulation: " << modToA(mod) << " - iTbs: " << iTbs << " i: " << i << endl;
./nodes/backgroundCell/BackgroundCellAmc.cc:    const unsigned int* tbsVect = itbs2tbs(mod, TRANSMIT_DIVERSITY, layers, iTbs - i);
./nodes/backgroundCell/BackgroundCellAmc.cc:    return tbsVect[blocks - 1];
./nodes/backgroundCell/BackgroundCellAmc.h:    // utilities - do not involve pilot invocation
./nodes/backgroundCell/BackgroundCellAmcNr.cc:        EV << NOW << " BackgroundCellAmcNr::computeBitsPerRbBackground - CQI equal to zero, return no bytes available" << endl;
./nodes/backgroundCell/BackgroundCellAmcNr.cc:        default: throw cRuntimeError("NRAmc::computeCodewordTbs - unrecognized modulation.");
./nodes/backgroundCell/BackgroundCellAmcNr.cc:    return (numSubcarriers * symbolsPerSlot) - reSignal - nOverhead;
./nodes/backgroundCell/BackgroundCellAmcNr.cc:        n = std::max((int)3, (int)(floor(log2(nInfo) - 6)));
./nodes/backgroundCell/BackgroundCellAmcNr.cc:        n = floor( log2(nInfo - 24) - 5);
./nodes/backgroundCell/BackgroundCellAmcNr.cc:        _nInfo = ( 1 << n ) * round( (nInfo - 24) / (1 << n));
./nodes/backgroundCell/BackgroundCellAmcNr.cc:            tbs = 8 * C * ceil( (_nInfo+24) / (8*C) ) - 24;
./nodes/backgroundCell/BackgroundCellAmcNr.cc:                tbs = 8 * C * ceil( (_nInfo+24) / (8*C) ) - 24;
./nodes/backgroundCell/BackgroundCellAmcNr.cc:                tbs = 8 * ceil( (_nInfo+24) / 8 ) - 24;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:    recvPower -= attenuation; // (dBm-dB)=dBm
./nodes/backgroundCell/BackgroundCellChannelModel.cc:    recvPower -= cableLoss_; // (dBm-dB)=dBm
./nodes/backgroundCell/BackgroundCellChannelModel.cc://    std::cout << "BackgroundCellChannelModel::getSinr - attenuation " << attenuation << " antennaGainTx-Rx " << antennaGainTx << " " << antennaGainRx << " cableLoss " << cableLoss_ << endl;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:        double recvAngle = fabs(txAngle - ueAngle);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:            recvAngle = 360 - recvAngle;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:        recvPower -= angolarAtt;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:        snrVector[i] -= den;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   EV << "BackgroundCellChannelModel::getAttenuation - computed attenuation at distance " << sqrDistance << " is " << attenuation << endl;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           double time = (NOW.dbl()) - (positionHistory_[nodeId].front().first.dbl());
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           p = exp((-1) * ((d - 18) / 27));
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       p = (((18 / d) > 1) ? 1 : 18 / d) * (1 - exp(-1 * d / 36))
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       p = (((18 / d) > 1) ? 1 : 18 / d) * (1 - exp(-1 * d / 36))
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           p = exp(-1 * (d - 10) / 200);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           p = exp(-1 * (d - 10) / 1000);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   double dbp = 4 * (hNodeB_ - 1) * (hUe_ - 1)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           return 40 * log10(d) + 7.8 - 18 * log10(hNodeB_ - 1)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       - 18 * log10(hUe_ - 1) + 2 * log10(carrierFrequency_);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   double dbp = 4 * (hNodeB_ - 1) * (hUe_ - 1)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           return 40 * log10(d) + 7.8 - 18 * log10(hNodeB_ - 1)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       - 18 * log10(hUe_ - 1) + 2 * log10(carrierFrequency_);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   double att = 161.04 - 7.1 * log10(wStreet_) + 7.5 * log10(hBuilding_)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   - (24.37 - 3.7 * pow(hBuilding_ / hNodeB_, 2)) * log10(hNodeB_)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   + (43.42 - 3.1 * log10(hNodeB_)) * (log10(d) - 3)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   - (3.2 * (pow(log10(11.75 * hUe_), 2)) - 4.97);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   dbp = 4 * (hNodeB_ - 1) * (hUe_ - 1)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           return primo + secondo - b + quarto;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       + a * log10(dbp) - b + 0.002 * log10(hBuilding_) * dbp
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   double att = 161.04 - 7.1 * log10(wStreet_) + 7.5 * log10(hBuilding_)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   - (24.37 - 3.7 * pow(hBuilding_ / hNodeB_, 2)) * log10(hNodeB_)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   + (43.42 - 3.1 * log10(hNodeB_)) * (log10(d) - 3)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   - (3.2 * (pow(log10(11.75 * hUe_), 2)) - 4.97);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   dbp = 4 * (hNodeB_ - 1) * (hUe_ - 1)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       + a * log10(d) - b + 0.002 * log10(hBuilding_) * d;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       + a * log10(dbp) - b + 0.002 * log10(hBuilding_) * dbp
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   double att = 161.04 - 7.1 * log10(wStreet_) + 7.5 * log10(hBuilding_)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   - (24.37 - 3.7 * pow(hBuilding_ / hNodeB_, 2)) * log10(hNodeB_)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   + (43.42 - 3.1 * log10(hNodeB_)) * (log10(d) - 3)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   - (3.2 * (pow(log10(11.75 * hUe_), 2)) - 4.97);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:    else if ((NOW - lastComputedSF_.at(nodeId).first).dbl() * speed
./nodes/backgroundCell/BackgroundCellChannelModel.cc:        time = (NOW - lastComputedSF_.at(nodeId).first).dbl();
./nodes/backgroundCell/BackgroundCellChannelModel.cc:        att = a * old + sqrt(1 - pow(a, 2)) * normal(mean, stdDev);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   relx = point.x - center.x;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   rely = point.y - center.y;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       angle = 180.0 - arcoSen;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       angle = 180.0 - arcoSen;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   double temp1 = binder_->phyPisaData.getChannel(getCellInfo(id)->getLambda(id)->channelIndex + band);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   simtime_t t = simTime().dbl() - 0.001;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       double phi = 2.00 * M_PI * (phi_d * t.dbl() - phi_i);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       im_h = im_h - attenuation * sin(phi);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       //        EV << "ID=" << nodeId << " - t[" << t << "] - dopplerShift[" << doppler_shift << "] - phiD[" <<
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       //                phi_d << "] - phiI[" << phi_i << "] - phi[" << phi << "] - attenuation[" << attenuation << "] - f["
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       //                << f << "] - Band[" << band << "] - cos(phi)["
./nodes/backgroundCell/BackgroundCellChannelModel.cc:    EV << "BackgroundCellChannelModel::getReceivedPower_bgUe - DIR=" << (( dir==DL )?"DL" : "UL")
./nodes/backgroundCell/BackgroundCellChannelModel.cc:                       << " - txPwr " << txPower << " - txPos[" << txPos << "] - rxPos[" << rxPos << "] " << endl;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:    double recvPower = txPower - attenuation; // (dBm-dB)=dBm
./nodes/backgroundCell/BackgroundCellChannelModel.cc:    recvPower -= cableLoss_; // (dBm-dB)=dBm
./nodes/backgroundCell/BackgroundCellChannelModel.cc:        double recvAngle = fabs(txAngle - ueAngle);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:            recvAngle = 360 - recvAngle;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:        recvPower -= angolarAtt;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       MacNodeId id = (*it)->id;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       if(!(*it)->init)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           (*it)->phy = check_and_cast<LtePhyBase*>(getSimulation()->getModule(binder_->getOmnetId(id))->getSubmodule("cellularNic")->getSubmodule("phy"));
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           (*it)->txPwr = (*it)->phy->getTxPwr();//dBm
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           (*it)->txDirection = (*it)->phy->getTxDirection();
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           (*it)->txAngle = (*it)->phy->getTxAngle();
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           (*it)->mac = check_and_cast<LteMacEnb*>(getMacByMacNodeId(id));
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           (*it)->init = true;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       Coord bsPos = (*it)->phy->getCoord();
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       LteRealisticChannelModel* interfChanModel = dynamic_cast<LteRealisticChannelModel *>((*it)->phy->getChannelModel(carrierFrequency));
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       EV << "BsId [" << id << "] - attenuation [" << att << "]";
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       if ((*it)->txDirection == ANISOTROPIC)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           double txAngle = (*it)->txAngle;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           double recvAngle = fabs(txAngle - ueAngle);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:               recvAngle = 360 - recvAngle;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       txPwr = (*it)->txPwr - angolarAtt - cableLoss_ + antennaGainEnB_ + antennaGainUe_;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           temp = (*it)->mac->getDlBandStatus(i);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:               EV<<NOW<<" BackgroundCellChannelModel::computeUplinkInterference - Interference from UE: "<< ueId << "(dir " << dirToA(dir) << ") on band[" << i << "]" << endl;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:               double rxPwr = txPwr - cableLoss_ + antennaGainUe_ + antennaGainEnB_;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:   EV << NOW << " BackgroundCellChannelModel::computeUplinkInterference - Final Band Interference Status: "<<endl;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:       if ((*it)->getId() == bgBsId)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           c = (*it)->getPosition();
./nodes/backgroundCell/BackgroundCellChannelModel.cc:                   "] and backgroundCell[" << c.x << "," << c.y << "] is -> "
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           txPwr = (*it)->getTxPower();
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           if ((*it)->getTxDirection() == OMNI)
./nodes/backgroundCell/BackgroundCellChannelModel.cc:               double recvAngle = fabs((*it)->getTxAngle() - ueAngle);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:                   recvAngle = 360 - recvAngle;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           // TODO do we need to use (- cableLoss_ + antennaGainEnB_) in ext cells too?
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           recvPwrDBm = txPwr - att - angolarAtt - cableLoss_ + antennaGainEnB_ + antennaGainUe_;
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           numBands = std::min(numBands, (*it)->getNumBands());
./nodes/backgroundCell/BackgroundCellChannelModel.cc:               occ = (*it)->getBandStatus(i, DL);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:           numBands = std::min(numBands, (*it)->getNumBands());
./nodes/backgroundCell/BackgroundCellChannelModel.cc:               occ = (*it)->getBandStatus(i, UL);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:                   bgUe = (*it)->getBandInterferingUe(i);
./nodes/backgroundCell/BackgroundCellChannelModel.cc:                           "] and backgroundUE[" << c.x << "," << c.y << "] is -> "
./nodes/backgroundCell/BackgroundCellChannelModel.cc:                   recvPwrDBm = txPwr - att - angolarAtt - cableLoss_ + antennaGainEnB_ + antennaGainBgUe;
./nodes/backgroundCell/BackgroundCellTrafficManager.cc:        bgScheduler_ = check_and_cast<BackgroundScheduler*>(getParentModule()->getParentModule()->getSubmodule("bgScheduler"));
./nodes/backgroundCell/BackgroundCellTrafficManager.cc:        phyPisaData_ = &(getBinder()->phyPisaData);
./nodes/backgroundCell/BackgroundCellTrafficManager.cc:            bgUe_.push_back(check_and_cast<TrafficGeneratorBase*>(getParentModule()->getSubmodule("bgUE", i)->getSubmodule("generator")));
./nodes/backgroundCell/BackgroundCellTrafficManager.cc:        getBinder()->addBgTrafficManagerInfo(info);
./nodes/backgroundCell/BackgroundCellTrafficManager.cc:    int index = bgUeId - BGUE_MIN_ID;
./nodes/backgroundCell/BackgroundCellTrafficManager.cc:    Cqi cqi = bgUe_.at(index)->getCqi(dir);
./nodes/backgroundCell/BackgroundCellTrafficManager.cc:    int index = bgUeId - BGUE_MIN_ID;
./nodes/backgroundCell/BackgroundScheduler.cc:        getParentModule()->subscribe(inet::IMobility::mobilityStateChangedSignal, this);
./nodes/backgroundCell/BackgroundScheduler.cc:         bgTrafficManager_ = check_and_cast<BackgroundTrafficManager*>(getParentModule()->getSubmodule("bgTrafficGenerator")->getSubmodule("manager"));
./nodes/backgroundCell/BackgroundScheduler.cc:         bgChannelModel_ = check_and_cast<BackgroundCellChannelModel*>(getParentModule()->getSubmodule("bgChannelModel"));
./nodes/backgroundCell/BackgroundScheduler.cc:        if ( strcmp(this->getParentModule()->getFullName(), source->getParentModule()->getFullName()) != 0)
./nodes/backgroundCell/BackgroundScheduler.cc:    EV << "----- BACKGROUND CELL ALLOCATION UPDATE -----" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:    // --- schedule RAC (UL only) --- //
./nodes/backgroundCell/BackgroundScheduler.cc:                EV << "BackgroundScheduler::updateAllocation - space ended" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:            EV << NOW << " BackgroundScheduler::updateAllocation - dir[" << dirToA(dir) << "] band[" << b << "] - allocated to ue[" << bgUeId << "]" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:                EV << "BackgroundScheduler::updateAllocation - space ended" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:                EV << "----- END BACKGROUND CELL ALLOCATION UPDATE -----" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:    // --- schedule retransmissions --- //
./nodes/backgroundCell/BackgroundScheduler.cc:            EV << "BackgroundScheduler::updateAllocation - space ended" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:            EV << NOW << " BackgroundScheduler::updateAllocation - dir[" << dirToA(dir) << "] band[" << b << "] - allocated to ue[" << bgUeId << "] for rtx" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:            blocks--;
./nodes/backgroundCell/BackgroundScheduler.cc:            EV << "BackgroundScheduler::updateAllocation - space ended" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:        // - the most significant 16 bits are set to the background UE id (BGUE_MIN_ID+index)
./nodes/backgroundCell/BackgroundScheduler.cc:        // - the least significant 16 bits are set to 0 (lcid=0)
./nodes/backgroundCell/BackgroundScheduler.cc:            EV << "BackgroundScheduler::updateAllocation - space ended" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:            EV << NOW << " BackgroundScheduler::updateAllocation - dir[" << dirToA(dir) << "] band[" << b << "] - allocated to ue[" << bgUeId << "]" << endl;
./nodes/backgroundCell/BackgroundScheduler.cc:            blocks--;
./nodes/backgroundCell/BackgroundScheduler.cc:    EV << "----- END BACKGROUND CELL ALLOCATION UPDATE -----" << endl;
./nodes/backgroundCell/BackgroundScheduler.h:    // reference to the background traffic manager - one per carrier
./nodes/eNodeB.ned:        cellularNic.radioIn <-- radioIn;
./nodes/eNodeB.ned:        pppIf.phys <--> ppp;
./nodes/eNodeB.ned:        pppIf.upperLayerOut --> nl.in++;
./nodes/eNodeB.ned:        pppIf.upperLayerIn <-- nl.out++;
./nodes/eNodeB.ned:            x2ppp[i].phys <--> x2[i];
./nodes/eNodeB.ned:            x2ppp[i].upperLayerOut --> tn.in++;
./nodes/eNodeB.ned:            x2ppp[i].upperLayerIn <-- tn.out++;
./nodes/eNodeB.ned:        nl.in++ <-- gtpUser.pppGate;
./nodes/eNodeB.ned:        trafficFlowFilter.gtpUserGateOut --> gtpUser.trafficFlowFilterGate;
./nodes/eNodeB.ned:        trafficFlowFilter.internetFilterGateIn <-- nl.out++;
./nodes/eNodeB.ned:        gtpUser.socketOut --> at.in++;
./nodes/eNodeB.ned:        gtpUser.socketIn <-- at.out++;
./nodes/eNodeB.ned:        gtpUserX2.lteStackOut --> cellularNic.x2$i++;
./nodes/eNodeB.ned:        gtpUserX2.lteStackIn <-- cellularNic.x2$o++;
./nodes/eNodeB.ned:        gtpUserX2.socketOut --> at.in++;
./nodes/eNodeB.ned:        gtpUserX2.socketIn <-- at.out++;
./nodes/eNodeB.ned:            x2App[i].sctpOut[0] --> at.in++;
./nodes/eNodeB.ned:            x2App[i].sctpIn[0] <-- at.out++;
./nodes/eNodeB.ned:            x2App[i].sctpOut[1] --> at.in++;
./nodes/eNodeB.ned:            x2App[i].sctpIn[1] <-- at.out++;
./nodes/eNodeB.ned:            x2App[i].x2ManagerIn <-- cellularNic.x2$o++;
./nodes/eNodeB.ned:            x2App[i].x2ManagerOut --> cellularNic.x2$i++;
./nodes/eNodeB.ned:            app[i].socketOut --> at.in++;
./nodes/eNodeB.ned:            app[i].socketIn <-- at.out++;
./nodes/eNodeB.ned:        at.out++ --> udp.appIn if hasUdp;
./nodes/eNodeB.ned:        at.in++ <-- udp.appOut if hasUdp;
./nodes/eNodeB.ned:        at.out++ --> tcp.appIn if hasTcp;
./nodes/eNodeB.ned:        at.in++ <-- tcp.appOut if hasTcp;
./nodes/eNodeB.ned:        at.out++ --> sctp.appIn if hasSctp;
./nodes/eNodeB.ned:        at.in++ <-- sctp.appOut if hasSctp;
./nodes/eNodeB.ned:        udp.ipOut --> tn.in++ if hasUdp;
./nodes/eNodeB.ned:        udp.ipIn <-- tn.out++ if hasUdp;
./nodes/eNodeB.ned:        tcp.ipOut --> tn.in++ if hasTcp;
./nodes/eNodeB.ned:        tcp.ipIn <-- tn.out++ if hasTcp;
./nodes/eNodeB.ned:        sctp.ipOut --> tn.in++ if hasSctp;
./nodes/eNodeB.ned:        tn.out++ --> sctp.ipIn if hasSctp;
./nodes/eNodeB.ned:        ipv4.ifIn <-- nl.out++ if hasIpv4;
./nodes/eNodeB.ned:        ipv4.ifOut --> nl.in++ if hasIpv4;
./nodes/eNodeB.ned:        ipv4.transportIn <-- tn.out++ if hasIpv4;
./nodes/eNodeB.ned:        ipv4.transportOut --> tn.in++ if hasIpv4;
./nodes/eNodeB.ned:        ipv6.ifIn <-- nl.out++ if hasIpv6;
./nodes/eNodeB.ned:        ipv6.ifOut --> nl.in++ if hasIpv6;
./nodes/eNodeB.ned:        ipv6.transportIn <-- tn.out++ if hasIpv6;
./nodes/eNodeB.ned:        ipv6.transportOut --> tn.in++ if hasIpv6;
./nodes/eNodeB.ned:        tn.out++ --> nl.in++;
./nodes/eNodeB.ned:        tn.in++ <-- nl.out++;
./nodes/eNodeB.ned:        at.out++ --> tn.in++;
./nodes/eNodeB.ned:        at.in++ <-- tn.out++;
./nodes/eNodeB.ned:        cellularNic.upperLayerIn <-- nl.out++;
./nodes/eNodeB.ned:        cellularNic.upperLayerOut --> nl.in++;
./nodes/eNodeB.ned:        pppMEHostIf.upperLayerIn <-- nl.out++;
./nodes/eNodeB.ned:        pppMEHostIf.upperLayerOut --> nl.in++;
./nodes/eNodeB.ned:        pppMEHost <--> pppMEHostIf.phys;
./nodes/ExtCell.cc:        if (omnetpp::getEnvir()->isGUI())
./nodes/ExtCell.cc:    EV << "----- EXT CELL ALLOCATION UPDATE -----" << std::endl;
./nodes/ExtCell.cc:        EV << " ExtCell::updateBandStatus() - generating new random allocation for extCell " << id_ << " (carrier " << carrierFrequency_ << ")" << std::endl;
./nodes/ExtCell.cc:        EV << " ExtCell::updateBandStatus() - generating new contiguous allocation for extCell " << id_ << " (carrier " << carrierFrequency_ << ")" << std::endl;
./nodes/ExtCell.cc:            toAlloc--;
./nodes/ExtCell.cc:    EV << "----- END EXT CELL ALLOCATION UPDATE -----" << std::endl;
./nodes/ExtCell.h: * - FULL_ALLOC: the cell allocates all RBs in the frame
./nodes/ExtCell.h: * - RANDOM_ALLOC: the cell allocates X RBs, which are chosen randomly
./nodes/ExtCell.h: * - CONTIGUOUS_ALLOC: the cell allocates X contiguous RBs, starting from a given RB
./nodes/ExtCell.ned:        // --- ALLOCATION MANAGEMENT --- //
./nodes/ExtCell.ned:        // ----------------------------- //
./nodes/mec/MECHost.ned:            ppp++ <--> upf_mec.pppg++;
./nodes/mec/MECHost.ned:            virtualisationInfrastructure.ppp++ <--> pppIf++;
./nodes/mec/MECHost.ned:        virtualisationInfrastructure.ppp++ <--> Eth10G <--> upf_mec.filterGate;
./nodes/mec/MECHost.ned:            independentMecApp[i].socketIn <-- virtualisationInfrastructure.independentMecAppOut[i];
./nodes/mec/MECHost.ned:            independentMecApp[i].socketOut --> virtualisationInfrastructure.independentMecAppIn[i];
./nodes/mec/MECHost.ned:            virtualisationInfrastructure.mecPlatform++ <--> mecPlatform.virtInfr++;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/AvailableResourcesSelectionBased.cc:    EV << "AvailableResourcesSelectionBased::findBestMecHost - finding best MecHost..." << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/AvailableResourcesSelectionBased.cc:           EV << "AvailableResourcesSelectionBased::findBestMecHost - MEC host ["<< mecHost->getName() << "] has not got enough resources. Searching again..." << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/AvailableResourcesSelectionBased.cc:           EV << "AvailableResourcesSelectionBased::findBestMecHost - MEC host ["<< mecHost->getName() << "] temporally chosen as bet MEC host. Available resources: " << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/AvailableResourcesSelectionBased.cc:        EV << "AvailableResourcesSelectionBased::findBestMecHost - MEC host ["<< bestHost->getName() << "] has been chosen as the best Mec Host" << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/AvailableResourcesSelectionBased.cc:        EV << "AvailableResourcesSelectionBased::findBestMecHost - No Mec Host found" << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecHostSelectionBased.cc:    EV << "MecHostSelectionBased::findBestMecHost - finding best MecHost..." << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecHostSelectionBased.cc:        EV << "MecHostSelectionBased::findBestMecHost - No Mec Host with index [" << mecHostIndex_ << "] found" << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecHostSelectionBased.cc:        EV << "MecHostSelectionBased::findBestMecHost - MEC host ["<< bestHost->getName() << "] has been chosen as the best Mec Host" << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:    EV << "MecServiceSelectionBased::findBestMecHost - finding best MecHost..." << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:        EV << "MecServiceSelectionBased::findBestMecHost - MEC host ["<< mecHost->getName() << "] size of mecHost " <<  mecOrchestrator_->mecHosts.size() << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:           EV << "MecServiceSelectionBased::findBestMecHost - MEC host ["<< mecHost->getName() << "] has not got enough resources. Searching again..." << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:       EV << "MecServiceSelectionBased::findBestMecHost - MEC host ["<< mecHost->getName() << "] temporally chosen as bet MEC host, checking for the required MEC services.." << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:       auto mecServices = mecpm ->getAvailableMecServices();
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:           EV << "MecServiceSelectionBased::findBestMecHost - required Mec Service: " << serviceName << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:           EV << "MecServiceSelectionBased::findBestMecHost - the Mec App does not require any MEC service. Choose the temporary Mec Host as the best one"<< endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:              EV << "MecServiceSelectionBased::findBestMecHost - The temporary Mec Host has the MEC service "<< it->getName() << " required by the Mec App. It has been chosen as the best one"<< endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:       EV << "MecServiceSelectionBased::findBestMecHost - The best Mec Host hasn't got the required service. Best MEC host: " << bestHost << endl;
./nodes/mec/MECOrchestrator/mecHostSelectionPolicies/MecServiceSelectionBased.cc:       EV << "MecServiceSelectionBased::findBestMecHost - no MEC host found"<< endl;
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MECOrchestratorMessage' as cValue -- field index out of range?", field);
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'CreateAppMessage' as cValue -- field index out of range?", field);
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DeleteAppMessage' as cValue -- field index out of range?", field);
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MECOMessages/MECOrchestratorMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV << "MecOrchestrator::initialize - stage " << stage << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        throw cRuntimeError("MecOrchestrator::initialize - Selection policy %s not present!" , par("selectionPolicy").stringValue());
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:            EV << "MecOrchestrator::handleMessage - "  << msg->getName() << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::handleMessage - "  << msg->getName() << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV << "MecOrchestrator::createMeApp - processing... request id: " << contAppMsg->getRequestId() << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:     * - It checks if the MEC app has been already deployed
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:     * - It selects the most suitable MEC host     *
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:            EV << "MecOrchestrator::startMECApp - \tWARNING: required MEC App instance ALREADY STARTED on MEC host: " << contextApp.second.mecHost->getName() << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:            EV << "MecOrchestrator::startMECApp  - sending ackMEAppPacket with "<< ACK_CREATE_CONTEXT_APP << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::startMECApp - onboarding appDescriptor from: " << contAppMsg->getAppPackagePath() << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::startMECApp - Application package with AppDId["<< contAppMsg->getAppDId() << "] not onboarded." << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc://        throw cRuntimeError("MecOrchestrator::startMECApp - Application package with AppDId[%s] not onboarded", contAppMsg->getAppDId());
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:             EV << "MecOrchestrator::startMECApp - MEC app is emulated" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:             inet::L3Address gtpAddress = inet::L3AddressResolver().resolve(newMecApp.mecHost->getSubmodule("upf_mec")->getFullPath().c_str());
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:             EV << "MecOrchestrator::startMECApp - something went wrong during MEC app instantiation"<< endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:         EV << "MecOrchestrator::startMECApp - new MEC application with name: " << appInfo->instanceId << " instantiated on MEC host []"<< newMecApp.mecHost << " at "<< appInfo->endPoint.addr.str() << ":" << appInfo->endPoint.port << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        //throw cRuntimeError("MecOrchestrator::startMECApp - A suitable MEC host has not been selected");
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::startMECApp - A suitable MEC host has not been selected" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV << "MecOrchestrator::stopMECApp - processing..." << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV << "MecOrchestrator::stopMECApp - processing contextId: "<< contextId << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::stopMECApp - \tWARNING Mec Application ["<< meAppMap[contextId].mecUeAppID <<"] not found!" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc://        throw cRuntimeError("MecOrchestrator::stopMECApp - \tERROR ueAppIdToMeAppMapKey entry not found!");
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:         EV << "MecOrchestrator::stopMECApp - mec Application ["<< meAppMap[contextId].mecUeAppID << "] removed"<< endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:         EV << "MecOrchestrator::stopMECApp - mec Application ["<< meAppMap[contextId].mecUeAppID << "] not removed"<< endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV << "MecOrchestrator::sendDeleteAppContextAck - result: "<<result << " reqSno: " << requestSno << " contextId: " << contextId << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV << "MecOrchestrator::sendCreateAppContextAck - result: "<< result << " reqSno: " << requestSno << " contextId: " << contextId << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:            EV << "MecOrchestrator::ackMEAppPacket - ERROR meApp["<< contextId << "] does not exist!" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc://            throw cRuntimeError("MecOrchestrator::ackMEAppPacket - ERROR meApp[%d] does not exist!", contextId);
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV << "MecOrchestrator::findBestMecHost - finding best MecHost..." << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:            EV << "MecOrchestrator::findBestMecHost - MEC host []"<< mecHost << " has not got enough resources. Searching again..." << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::findBestMecHost - MEC host []"<< mecHost << " temporally chosen as bet MEC host, checking for the required MEC services.." << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        auto mecServices = mecpm ->getAvailableMecServices();
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::findBestMecHost - best MEC host: " << bestHost << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::findBestMecHost - no MEC host found"<< endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV <<"MecOrchestrator::getConnectedMecHosts - mecHostList: "<< par("mecHostList").stringValue() << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:            EV <<"MecOrchestrator::getConnectedMecHosts - mec host (from par): "<< token << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:            cModule *mecHostModule = getSimulation()->getModuleByPath(token);
./nodes/mec/MECOrchestrator/MecOrchestrator.cc://        throw cRuntimeError ("MecOrchestrator::getConnectedMecHosts - No mecHostList found");
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::getConnectedMecHosts - No mecHostList found" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV <<"MecOrchestrator::onBoardApplicationPackages - onboarding application package (from request): "<< fileName << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::onboardApplicationPackages() - Application descriptor with appName ["<< fileName << "] is already present.\n" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc://        throw cRuntimeError("MecOrchestrator::onboardApplicationPackages() - Application descriptor with appName [%s] is already present.\n"
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:    EV << "MecOrchestrator::registerMecService - Registering MEC service [" << serviceDescriptor.name << "]" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        cModule* module = mecHost->getSubmodule("mecPlatform")->getSubmodule("serviceRegistry");
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:            EV << "MecOrchestrator::registerMecService - Registering MEC service ["<<serviceDescriptor.name << "] in MEC host [" << mecHost->getName()<<"]" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.cc:        EV << "MecOrchestrator::onboardApplicationPackages - No mecApplicationPackageList found" << endl;
./nodes/mec/MECOrchestrator/MecOrchestrator.h://   - MEC app instantiation
./nodes/mec/MECOrchestrator/MecOrchestrator.h://   - MEC app termination
./nodes/mec/MECOrchestrator/MecOrchestrator.h://   - MEC app run-time onboarding
./nodes/mec/MECOrchestrator/MecOrchestrator.h:    //------------------------------------
./nodes/mec/MECOrchestrator/MecOrchestrator.h:    //------------------------------------
./nodes/mec/MECOrchestrator/MecOrchestrator.h:    //key = contextId - value mecAppMapEntry
./nodes/mec/MECOrchestrator/MecOrchestrator.ned://   - MEC app instantiation
./nodes/mec/MECOrchestrator/MecOrchestrator.ned://   - MEC app termination
./nodes/mec/MECOrchestrator/MecOrchestrator.ned://   - MEC app run-time onboarding
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MEAppPacket' as cValue -- field index out of range?", field);
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MEAppPacket_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MECPacket' as cValue -- field index out of range?", field);
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPackets_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECPlatform.ned:        serviceRegistry.socketOut --> virtInfr$o[0];
./nodes/mec/MECPlatform/MECPlatform.ned:        serviceRegistry.socketIn <-- virtInfr$i[0];
./nodes/mec/MECPlatform/MECPlatform.ned:            mecService[i].socketOut --> virtInfr$o[i+1];
./nodes/mec/MECPlatform/MECPlatform.ned:            mecService[i].socketIn <-- virtInfr$i[i+1];
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:        EV << "LocationService::manageSubscription() - subscription with id: " << subId << " found" << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:        EV << "LocationService::manageSubscription() - subscription with id: " << subId << " not found. Removing from subscriptionTimer.." << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:            * - ue_ipv4_address
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:            * - accessPointId
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:                    EV <<"LocationService::handleGETReques - parameters: " << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:                EV <<"LocationService::handleGETReques - toJson(cellIds, ues) " << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:                EV <<"LocationService::handleGETReques - toJson(cellIds) " << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:               EV <<"LocationService::handleGETReques - toJson(ues) " << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:            EV <<"LocationService::handleGETReques - toJson() " << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc://        EV << "LocationService::handlePOSTRequest - incorrect URI" << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc://    EV << "LocationService::handlePOSTRequest - baseuri: "<< baseUri << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:            EV << serviceName_ << " - correct subscription created!" << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.cc:    EV << "LocationService::handlePUTRequest - baseuri: "<< baseUri << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.h: *  - get the current location of a UE (or a group of UEs)
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.h: *  - get the current location of a Base Station (or a group of Base Stations)
./nodes/mec/MECPlatform/MECServices/LocationService/LocationService.h: *  - circle notification subscription 
./nodes/mec/MECPlatform/MECServices/LocationService/resources/CircleNotificationSubscription.cc:    if(firstNotificationSent && (simTime() - lastNotification) <= frequency)
./nodes/mec/MECPlatform/MECServices/LocationService/resources/CircleNotificationSubscription.cc:        EV <<"CircleNotificationSubscription::sendNotification - notification event occured near the last one. Frequency for notifications is: " << frequency << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/resources/CircleNotificationSubscription.h:        Binder* binder; //used to retrieve NodeId - Ipv4Address mapping
./nodes/mec/MECPlatform/MECServices/LocationService/resources/LocationApiDefs.cc:        cModule* module = getSimulation()->getModule(omnetId);
./nodes/mec/MECPlatform/MECServices/LocationService/resources/LocationApiDefs.cc:        cModule* module = getSimulation()->getModule(omnetId);
./nodes/mec/MECPlatform/MECServices/LocationService/resources/LocationResource.cc:	    CellInfo * cellInfo = check_and_cast<CellInfo *>((*it)->getSubmodule("cellInfo"));
./nodes/mec/MECPlatform/MECServices/LocationService/resources/LocationResource.cc:            CellInfo * cellInfo = check_and_cast<CellInfo *>((*it)->getSubmodule("cellInfo"));
./nodes/mec/MECPlatform/MECServices/LocationService/resources/LocationResource.cc:            EV << "LocationResource::addEnodeB - added eNodeB: " << cellInfo->getMacCellId() << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/resources/LocationResource.cc:    EV << "LocationResource::addEnodeB - added eNodeB: " << cellInfo->getMacCellId() << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/resources/LocationResource.cc:    EV << "LocationResource::toJson() - gnb" << it->first << endl;
./nodes/mec/MECPlatform/MECServices/LocationService/resources/LocationResource.cc:        EV << "LocationResource::toJson() - user: " << pit->first << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV << "MecServiceBase::initialize - mean request service time " << requestServiceTime_ << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV << "MecServiceBase::initialize - mean subscription service time " << subscriptionServiceTime_<< endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:                ->getParentModule(); // MeHost
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:             * For M/M/1 --> rho (lambda_/mu) < 1
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            EV <<"MecServiceBase::initialize - rho: "<< rho_ <<  endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        int found = getParentModule()->findSubmodule("serviceRegistry");
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            throw cRuntimeError("MecServiceBase::initialize - ServiceRegistry not present!");
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        servRegistry_ = check_and_cast<ServiceRegistry*>(getParentModule()->getSubmodule("serviceRegistry"));
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            EV << "MecServiceBase::initialize - MecPlatformManager found" << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:    EV << "MecServiceBase::handleStartOperation - local Address: " << localAddress << " port: " << localPort << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:    EV << "MecServiceBase::handleStartOperation - local Address resolved: "<< localAdd << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:    EV << "MecServiceBase::handleStartOperation - registering MEC service..." << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV << "MecServiceBase::handleStartOperation - MEC Orchestrator not present. Register directly to the host Service Registry"<< endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV << "MecServiceBase::handleStartOperation - registering MEC service via MEC Orchestrator"<< endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:           thread->getSocket()->close();
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        thread->getSocket()->close();
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV << " MecServiceBase::handleMessageWhenUp - "<< msg->getName() << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:    // new TCP connection -- create new socket object and server process
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:    EV << "New socket added - ["<< newSocket->getRemoteAddress() <<":"<< newSocket->getRemotePort() << " connId: "<<newSocket->getSocketId()<<"]" << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:  //  EV << "MecServiceBase::manageRequest - start manageRequest" << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            simtime_t responseTime = simTime() - currentRequestMessageServed_->getArrivalTime();
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            EV_INFO <<" MecServiceBase::manageRequest - Response time - " << responseTime << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV <<"MecServiceBase::scheduleNextEvent - subscription branch"<< endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV <<"MecServiceBase::scheduleNextEvent - request branch"<< endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            EV <<"MecServiceBase::scheduleNextEvent - load generator is on, use the response time in the packet"<< endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        throw cRuntimeError ("MecServiceBase::handleRequestQueueFull - socket not found, this should not happen.");
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV << "MecServiceBase::newRequest - queue is full" << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            EV << "MecServiceBase::newRequest - number of BG requests in front of this FG request: " << numOfBGReqs << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            simtime_t deltaTime = simTime() - lastFGRequestArrived_;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:            EV << "MecServiceBase::newRequest - number of BG requests between this and the last FG request: " << numOfBGReqs << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV << "MecServiceBase::newRequest - FG request service time is (sumOfresponseTimes): " << sumOfresponseTimes << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:        EV << "MecServiceBase::newSubscriptionEvent - subscription queue is full. Deleting event..." << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:    EV << "MecServiceBase::calculateRequestServiceTime - time: " << time << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.cc:           cModule *bsModule = getSimulation()->getModuleByPath(token);
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.h:         * if parameter is true -> scheduleAt(NOW)
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.h:         * e.g GET --> handleGetRequest()
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.h:        *  - the method (e.g. GET POST)
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.h:        *  - the number of parameters
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.h:        *  - .ini parameter
./nodes/mec/MECPlatform/MECServices/MECServiceBase/MecServiceBase.h:        *  - combination of the above
./nodes/mec/MECPlatform/MECServices/MECServiceBase/SocketManager.cc:    std::vector<uint8_t> bytes =  msg->peekDataAsBytes()->getBytes();
./nodes/mec/MECPlatform/MECServices/MECServiceBase/SocketManager.cc:    EV << "SocketManager::dataArrived - payload length: " << bytes.size() << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/SocketManager.cc:    EV << "SocketManager::dataArrived - payload : " << packet << endl;
./nodes/mec/MECPlatform/MECServices/MECServiceBase/SocketManager.cc:    //service->removeConnection(this); //sock->close(); // it crashes when mec app is deleted  with ->deleteModule FIXME
./nodes/mec/MECPlatform/MECServices/MECServiceBase/SocketManager.h:     * Called when a status arrives in response to getSocket()->getStatus().
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'AperiodicSubscriptionTimer_m' as cValue -- field index out of range?", field);
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/AperiodicSubscriptionTimer_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'HttpBaseMessage' as cValue -- field index out of range?", field);
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'HttpRequestMessage_m' as cValue -- field index out of range?", field);
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'HttpResponseMessage_m' as cValue -- field index out of range?", field);
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/MECPlatform/MECServices/packets/HttpRequestMessage/HttpRequestMessage.h: * - Content-Type
./nodes/mec/MECPlatform/MECServices/packets/HttpRequestMessage/Serializers/HttpRequestMessageSerializer.cc:    int64_t remainders = B(applicationPacket->getChunkLength() - (stream.getLength() - startPosition)).get();
./nodes/mec/MECPlatform/MECServices/packets/HttpRequestMessage/Serializers/HttpRequestMessageSerializer.cc:        throw cRuntimeError("ApplicationPacket length = %d smaller than required %d bytes", (int)B(applicationPacket->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./nodes/mec/MECPlatform/MECServices/packets/HttpRequestMessage/Serializers/HttpRequestMessageSerializer.cc:    B remainders = stream.getLength() - (stream.getPosition() - startPosition);
./nodes/mec/MECPlatform/MECServices/packets/HttpResponseMessage/HttpResponseMessage.h: * - Content-Type
./nodes/mec/MECPlatform/MECServices/packets/HttpResponseMessage/HttpResponseMessage.h: * - Connection
./nodes/mec/MECPlatform/MECServices/packets/HttpResponseMessage/Serializers/HttpResponseMessageSerializer.cc:    int64_t remainders = B(applicationPacket->getChunkLength() - (stream.getLength() - startPosition)).get();
./nodes/mec/MECPlatform/MECServices/packets/HttpResponseMessage/Serializers/HttpResponseMessageSerializer.cc:        throw cRuntimeError("ApplicationPacket length = %d smaller than required %d bytes", (int)B(applicationPacket->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./nodes/mec/MECPlatform/MECServices/Resources/SubscriptionBase.cc:        CellInfo * cellInfo = check_and_cast<CellInfo *>((*it)->getSubmodule("cellInfo"));
./nodes/mec/MECPlatform/MECServices/Resources/SubscriptionBase.cc:        CellInfo * cellInfo = check_and_cast<CellInfo *>((*it)->getSubmodule("cellInfo"));
./nodes/mec/MECPlatform/MECServices/Resources/SubscriptionBase.cc:        EV << "LocationResource::addEnodeB - added eNodeB: " << cellInfo->getMacCellId() << endl;
./nodes/mec/MECPlatform/MECServices/Resources/SubscriptionBase.cc:    EV << "LocationResource::addEnodeB - added eNodeB: " << cellInfo->getMacCellId() << endl;
./nodes/mec/MECPlatform/MECServices/RNIService/resources/L2Meas.cc:		BaseStationStatsCollector * collector = check_and_cast<BaseStationStatsCollector *>((*it)->getSubmodule("collector"));
./nodes/mec/MECPlatform/MECServices/RNIService/resources/L2Meas.cc:			BaseStationStatsCollector * collector = check_and_cast<BaseStationStatsCollector *>((*it)->getSubmodule("collector"));
./nodes/mec/MECPlatform/MECServices/RNIService/resources/RNICellInfo.h:    BaseStationStatsCollector* collector_; // it has the cellCollector and the map <Ipue -> uecollector>
./nodes/mec/MECPlatform/MECServices/RNIService/RNIService.cc:            * - cell_id
./nodes/mec/MECPlatform/MECServices/RNIService/RNIService.cc:            * - ue_ipv4_address
./nodes/mec/MECPlatform/MECServices/RNIService/RNIService.cc:            * - ue_ipv6_address // not implemented yet
./nodes/mec/MECPlatform/MECServices/RNIService/RNIService.cc:            queryMap queryParamsMap; // e.g cell_id -> [0, 1]
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:    EV << "ServiceRegistry::initialize - stage " << stage << endl;
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:    if (stage!=inet::INITSTAGE_APPLICATION_LAYER - 1)
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:        EV << "ServiceRegistry::initialize - ERROR getting mePlatform cModule!" << endl;
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:        throw cRuntimeError("ServiceRegistry::initialize - \tFATAL! Error when getting getParentModule()");
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:            * - ser_instance_id
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:            * - ser_name
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:                    EV <<"ServiceRegistry::handleGETReques - parameters: " << endl;
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:            throw cRuntimeError("ServiceRegistry::registerMeService - %s is already present in MEC host %s!", servDesc.name.c_str(), servDesc.mecHostname.c_str());
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.cc:    EV << "ServiceRegistry::registerMeService - "<< servInfo.toJson().dump(2) << "\nadded!" << endl;
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.h:// 	- ServiceName -> IpAddress and port
./nodes/mec/MECPlatform/ServiceRegistry/ServiceRegistry.ned:// 	- ServiceName -> IpAddress and port
./nodes/mec/MECPlatformManager/MecPlatformManager.cc:    EV << "VirtualisationInfrastructureManager::initialize - stage " << stage << endl;
./nodes/mec/MECPlatformManager/MecPlatformManager.cc:    vim = check_and_cast<VirtualisationInfrastructureManager*>(getParentModule()->getSubmodule("vim"));
./nodes/mec/MECPlatformManager/MecPlatformManager.cc:    cModule* mecPlatform = getParentModule()->getSubmodule("mecPlatform");
./nodes/mec/MECPlatformManager/MecPlatformManager.cc:    cModule* module = getSimulation()->findModuleByPath(mecOrche);
./nodes/mec/MECPlatformManager/MecPlatformManager.cc:        EV << "MecPlatformManager::initialize - Mec Orchestrator ["<< mecOrche << "] not found" << endl;
./nodes/mec/UALCMP/UALCMP.ned:        ualcmpApp.socketOut --> at.in++;
./nodes/mec/UALCMP/UALCMP.ned:        ualcmpApp.socketIn <-- at.out++;
./nodes/mec/UALCMP/UALCMP.ned:        ualcmpApp.toMecOrchestrator --> toMecOrchestrator;
./nodes/mec/UALCMP/UALCMP.ned:        ualcmpApp.fromMecOrchestrator <-- fromMecOrchestrator;
./nodes/mec/UALCMP/UALCMP.ned:        at.out++ --> udp.appIn;
./nodes/mec/UALCMP/UALCMP.ned:        at.in++ <-- udp.appOut;
./nodes/mec/UALCMP/UALCMP.ned:        at.out++ --> tcp.appIn;
./nodes/mec/UALCMP/UALCMP.ned:        at.in++ <-- tcp.appOut;
./nodes/mec/UALCMP/UALCMP.ned:        udp.ipOut --> tn.in++;
./nodes/mec/UALCMP/UALCMP.ned:        udp.ipIn <-- tn.out++;
./nodes/mec/UALCMP/UALCMP.ned:        tcp.ipOut --> tn.in++;
./nodes/mec/UALCMP/UALCMP.ned:        tcp.ipIn <-- tn.out++;
./nodes/mec/UALCMP/UALCMP.ned:        ipv4.ifIn <-- nl.out++ if hasIpv4;
./nodes/mec/UALCMP/UALCMP.ned:        ipv4.ifOut --> nl.in++ if hasIpv4;
./nodes/mec/UALCMP/UALCMP.ned:        ipv4.transportIn <-- tn.out++ if hasIpv4;
./nodes/mec/UALCMP/UALCMP.ned:        ipv4.transportOut --> tn.in++ if hasIpv4;
./nodes/mec/UALCMP/UALCMP.ned:        ipv6.ifIn <-- nl.out++ if hasIpv6;
./nodes/mec/UALCMP/UALCMP.ned:        ipv6.ifOut --> nl.in++ if hasIpv6;
./nodes/mec/UALCMP/UALCMP.ned:        ipv6.transportIn <-- tn.out++ if hasIpv6;
./nodes/mec/UALCMP/UALCMP.ned:        ipv6.transportOut --> tn.in++ if hasIpv6;
./nodes/mec/UALCMP/UALCMP.ned:        //            pppIf[i].upperLayerOut --> nl.in++;
./nodes/mec/UALCMP/UALCMP.ned:        //            pppIf[i].upperLayerIn <-- nl.out++;
./nodes/mec/UALCMP/UALCMP.ned:        //            pppIf[i].phys <--> gtpEndpoint.pppg++;
./nodes/mec/UALCMP/UALCMP.ned:        pppIf.upperLayerOut --> nl.in++;
./nodes/mec/UALCMP/UALCMP.ned:        pppIf.upperLayerIn <-- nl.out++;
./nodes/mec/UALCMP/UALCMP.ned:        pppIf.phys <--> ppp++;
./nodes/mec/UALCMP/UALCMP.ned:            extEth[i].upperLayerOut --> nl.in++;
./nodes/mec/UALCMP/UALCMP.ned:            extEth[i].upperLayerIn <-- nl.out++;
./nodes/mec/UALCMP/UALCMPApp.cc:        mecOrchestrator_ = check_and_cast<MecOrchestrator*>(getSimulation()->getModuleByPath(mecOrchestratorHostname.c_str()));
./nodes/mec/UALCMP/UALCMPApp.cc:    EV << "UALCMPApp::handleCreateContextAppAckMessage - reqSno: " << reqSno << endl;
./nodes/mec/UALCMP/UALCMPApp.cc:        EV << "UALCMPApp::handleCreateContextAppAckMessage - reqSno: " << reqSno<< " not present in pendingRequests. Discarding... "<<endl;
./nodes/mec/UALCMP/UALCMPApp.cc:    EV << "UALCMPApp::handleCreateContextAppAckMessage - reqSno: " << reqSno << " related to connid: "<< connId << endl;
./nodes/mec/UALCMP/UALCMPApp.cc:        EV << "UALCMPApp::handleDeleteContextAppAckMessage - reqSno: " << reqSno<< " not present in pendingRequests. Discarding... "<<endl;
./nodes/mec/UALCMP/UALCMPApp.cc:    EV << "UALCMPApp::handleDeleteContextAppAckMessage - reqSno: " << reqSno << " related to connid: "<< connId << endl;
./nodes/mec/UALCMP/UALCMPApp.cc:            * - appName
./nodes/mec/UALCMP/UALCMPApp.cc:                    EV <<"UALCMPApp::handleGETRequest - parameters: " << endl;
./nodes/mec/UALCMP/UALCMPApp.cc:    EV << "UALCMPApp::handlePOSTRequest - uri: "<< uri << endl;
./nodes/mec/UALCMP/UALCMPApp.cc:            throw cRuntimeError("UALCMPApp::handlePOSTRequest - %s", e.what());
./nodes/mec/UALCMP/UALCMPApp.cc:        EV << "UALCMPApp::parseContextCreateRequest - appInfo attribute not found" << endl;
./nodes/mec/UALCMP/UALCMPApp.cc:       EV << "UALCMPApp::parseContextCreateRequest - associateDevAppId attribute not found" << endl;
./nodes/mec/UALCMP/UALCMPApp.h://   - GET /app_list Retrieve available application information.
./nodes/mec/UALCMP/UALCMPApp.h://   - POST /app_contexts For requesting the creation of a new application context.
./nodes/mec/UALCMP/UALCMPApp.h://   - DELETE /app_contexts/{contextId}  For requesting the deletion of an existing application context
./nodes/mec/UALCMP/UALCMPApp.ned://   - GET /app_list Retrieve available application information.
./nodes/mec/UALCMP/UALCMPApp.ned://   - POST /app_contexts For requesting the creation of a new application context.
./nodes/mec/UALCMP/UALCMPApp.ned://   - DELETE /app_contexts/{contextId}  For requesting the deletion of an existing application context 
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'UALCMPMessage' as cValue -- field index out of range?", field);
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'CreateContextApp' as cValue -- field index out of range?", field);
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'CreateContextAppAck' as cValue -- field index out of range?", field);
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DeleteContextAppMessage' as cValue -- field index out of range?", field);
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DeleteContextAppAckMessage' as cValue -- field index out of range?", field);
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/UALCMP/UALCMPMessages/UALCMPMessages_m.cc:        field -= base->getFieldCount();
./nodes/mec/utils/httpUtils/httpUtils.cc:        chunkPayload->addTag<CreationTimeTag>()->setCreationTime(simTime());
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV <<"Http Utils - sendPacket" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils::parseHeader - Header: " << data << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        // if the first word is not HTTP/1.1 nor HTTP/2 (NOTE: assuming the HTTP is correct ---> it is a request)
./nodes/mec/utils/httpUtils/httpUtils.cc:            EV << "httpUtils::parseHeader - It is a request" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                   EV << "httpUtils::parseHeader - There are parameters" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                   EV << "httpUtils::parseHeader - There are not parameters" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                   EV << "httpUtils::parseHeader - Parameters error" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Content-Length: " << line[1] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Content-Type: " << line[1] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Host: " << line[1] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Connection: " << line[1] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Header: " << line[1] << ": "<< line[0] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:            EV << "httUtils::parseHeader - It is a response" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                EV << "httUtils::parseHeader - BAD_RES_LINE" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                EV << "httUtils::parseHeader - BAD_HTTP" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:            EV << "httUtils::parseHeader - code " <<  httpResponse->getCode() << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Content-Length: " << line[1] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Content-Type: " << line[1] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Connection: " << line[1] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                        EV << "httpUtili::parseHeader - Header: " << line[1] << ": "<< line[0] << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:            throw cRuntimeError("httpUtils parseTcpData - httpMessage must be not null");
./nodes/mec/utils/httpUtils/httpUtils.cc:            throw cRuntimeError("httpUtils parseTcpData - something went wrong: data length: %lu and remaining data to receive: %d", data->length(),httpMessage->getRemainingDataToRecv() );
./nodes/mec/utils/httpUtils/httpUtils.cc:        if(*currentHttpMessage != nullptr && (*currentHttpMessage)->isReceivingMsg())
./nodes/mec/utils/httpUtils/httpUtils.cc:           EV << "MecAppBase::parseReceivedMsg - Continue receiving data for the current HttpMessage" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                   EV << "MecAppBase::parseReceivedMsg - passing HttpMessage to application: " << res << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                    throw cRuntimeError("httpUtils parseReceivedMsg - This function does not support multiple HTTP messages in one segment");
./nodes/mec/utils/httpUtils/httpUtils.cc:                       throw cRuntimeError("httpUtils parseReceivedMsg - current Http Message is incomplete, but there is still data to read");
./nodes/mec/utils/httpUtils/httpUtils.cc:        *  - I am not receiving an http message
./nodes/mec/utils/httpUtils/httpUtils.cc:        *  - I was receiving an http message but I still have data (i.e a new HttpMessage) to manage.
./nodes/mec/utils/httpUtils/httpUtils.cc:           EV << "MecAppBase::parseReceivedMsg - buffered data" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:           EV << "MecAppBase::parseReceivedMsgn - new HTTP message"<< endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                   EV << "MecAppBase::parseReceivedMsg - passing HttpMessage to application: " << res << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                       throw cRuntimeError("httpUtils parseReceivedMsg - This function does not support multiple HTTP messages in one segment");
./nodes/mec/utils/httpUtils/httpUtils.cc:                       throw cRuntimeError("httpUtils parseReceivedMsg - current Http Message is incomplete, but there is still data to read");
./nodes/mec/utils/httpUtils/httpUtils.cc:            EV << "MecAppBase::parseReceivedMsgn - stored data: " << packet << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:          if(*currentHttpMessage != nullptr && (*currentHttpMessage)->isReceivingMsg())
./nodes/mec/utils/httpUtils/httpUtils.cc:              // EV << "MecAppBase::parseReceivedMsg - Continue receiving data for the current HttpMessage" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                  // EV << "MecAppBase::parseReceivedMsg - passing HttpMessage to application: " << res << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                  (*currentHttpMessage)->setSockId(socketId);
./nodes/mec/utils/httpUtils/httpUtils.cc:                  // EV << "MecAppBase::parseReceivedMsg - passing HttpMessage to application: " << res << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                  (*currentHttpMessage)->setSockId(socketId);
./nodes/mec/utils/httpUtils/httpUtils.cc:                      throw cRuntimeError("httpUtils parseReceivedMsg - current Http Message is incomplete, but there is still data to read");
./nodes/mec/utils/httpUtils/httpUtils.cc:           *  - I am not receiving an http message
./nodes/mec/utils/httpUtils/httpUtils.cc:           *  - I was receiving an http message but I still have data (i.e a new HttpMessage) to manage.
./nodes/mec/utils/httpUtils/httpUtils.cc:              // EV << "MecAppBase::parseReceivedMsg - buffered data" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:              //std::cout << "MecAppBase::parseReceivedMsg - buffered data" << std::endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                  // EV << "MecAppBase::parseReceivedMsg - passing HttpMessage to application: " << res << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                  (*currentHttpMessage)->setSockId(socketId);
./nodes/mec/utils/httpUtils/httpUtils.cc:                  // EV << "MecAppBase::parseReceivedMsg - passing HttpMessage to application: " << res << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:                  (*currentHttpMessage)->setSockId(socketId);
./nodes/mec/utils/httpUtils/httpUtils.cc:                      throw cRuntimeError("httpUtils parseReceivedMsg - current Http Message is incomplete, but there is still data to read");
./nodes/mec/utils/httpUtils/httpUtils.cc:            EV << "httpUtils::addBodyChunk - no body" << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils - addBodyChunk: data length: "<< len << "B. Remaining bytes: "<< remainingLength<< endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:            EV << "httpUtils::addBodyChunk - RESPONSE "<< endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:            EV << "httpUtils::addBodyChunk - REQUEST "<< endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        httpMessage->setRemainingDataToRecv(remainingLength - (len - data->length()));
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils - addBodyChunk: Remaining bytes: "<< httpMessage->getRemainingDataToRecv()<< endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils - sendHttpResponse: code: " << code << " to: " << socket->getRemoteAddress() << ":" << socket->getRemotePort() << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc://        resPkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&Protocol::http);
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils - sendHttpResponse: code: " << code << " to: " << socket->getRemoteAddress() << ":" << socket->getRemotePort() << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc://        resPkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&Protocol::http);
./nodes/mec/utils/httpUtils/httpUtils.cc:        resPkt->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils - sendHttpResponse: code: " << code << " to: " << socket->getRemoteAddress() << ":" << socket->getRemotePort() << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        //        resPkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&Protocol::http);
./nodes/mec/utils/httpUtils/httpUtils.cc:        resPkt->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils - sendHttpRequest: method: " << method << " to: " << socket->getRemoteAddress() << ":" << socket->getRemotePort() << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        //        resPkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&Protocol::http);
./nodes/mec/utils/httpUtils/httpUtils.cc:        reqPkt->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils - sendHttpRequest: method: " << method << " to: " << socket->getRemoteAddress() << ":" << socket->getRemotePort() << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        //        resPkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&Protocol::http);
./nodes/mec/utils/httpUtils/httpUtils.cc:        reqPkt->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./nodes/mec/utils/httpUtils/httpUtils.cc:        EV << "httpUtils - sendHttpRequest: method: " << method << " to: " << socket->getRemoteAddress() << ":" << socket->getRemotePort() << endl;
./nodes/mec/utils/httpUtils/httpUtils.cc:        //        resPkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&Protocol::http);
./nodes/mec/utils/httpUtils/httpUtils.cc:        reqPkt->addTagIfAbsent<inet::CreationTimeTag>()->setCreationTime(simTime());
./nodes/mec/utils/httpUtils/httpUtils.h: * - body parsing
./nodes/mec/utils/httpUtils/httpUtils.h: * - header parsing
./nodes/mec/utils/httpUtils/httpUtils.h: * - send HTTP messages (both requests and responds)
./nodes/mec/utils/httpUtils/httpUtils.h:     * @param header - string representing the header of the HTTP message
./nodes/mec/utils/httpUtils/httpUtils.h:     * @param data - string representing the body of a fragmented HTTP Message
./nodes/mec/utils/httpUtils/httpUtils.h:     * @param httpMessage - HttpBaseMessage of the current message
./nodes/mec/utils/httpUtils/httpUtils.h:     * @return HttpMsgState - state of the HTTP message
./nodes/mec/utils/httpUtils/httpUtils.h:     * @return bool - if true the currentHttpMessage is completed and ready to be
./nodes/mec/utils/httpUtils/json.hpp:/* Hedley - https://nemequ.github.io/hedley
./nodes/mec/utils/httpUtils/json.hpp:            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
./nodes/mec/utils/httpUtils/json.hpp:            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
./nodes/mec/utils/httpUtils/json.hpp:                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
./nodes/mec/utils/httpUtils/json.hpp:        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
./nodes/mec/utils/httpUtils/json.hpp:                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
./nodes/mec/utils/httpUtils/json.hpp:        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
./nodes/mec/utils/httpUtils/json.hpp:- @ref parse_error for exceptions indicating a parse error
./nodes/mec/utils/httpUtils/json.hpp:- @ref invalid_iterator for exceptions indicating errors with iterators
./nodes/mec/utils/httpUtils/json.hpp:- @ref type_error for exceptions indicating executing a member function with
./nodes/mec/utils/httpUtils/json.hpp:- @ref out_of_range for exceptions indicating access out of the defined range
./nodes/mec/utils/httpUtils/json.hpp:- @ref other_error for exceptions indicating other library errors
./nodes/mec/utils/httpUtils/json.hpp:------------------------------ | --------------- | -------------------------
./nodes/mec/utils/httpUtils/json.hpp:json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref exception for the base class of the library exceptions
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref invalid_iterator for exceptions indicating errors with iterators
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref type_error for exceptions indicating executing a member function with
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref out_of_range for exceptions indicating access out of the defined range
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref other_error for exceptions indicating other library errors
./nodes/mec/utils/httpUtils/json.hpp:----------------------------------- | --------------- | -------------------------
./nodes/mec/utils/httpUtils/json.hpp:json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref exception for the base class of the library exceptions
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref parse_error for exceptions indicating a parse error
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref type_error for exceptions indicating executing a member function with
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref out_of_range for exceptions indicating access out of the defined range
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref other_error for exceptions indicating other library errors
./nodes/mec/utils/httpUtils/json.hpp:----------------------------- | --------------- | -------------------------
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref exception for the base class of the library exceptions
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref parse_error for exceptions indicating a parse error
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref invalid_iterator for exceptions indicating errors with iterators
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref out_of_range for exceptions indicating access out of the defined range
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref other_error for exceptions indicating other library errors
./nodes/mec/utils/httpUtils/json.hpp:------------------------------- | --------------- | -------------------------
./nodes/mec/utils/httpUtils/json.hpp:json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref exception for the base class of the library exceptions
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref parse_error for exceptions indicating a parse error
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref invalid_iterator for exceptions indicating errors with iterators
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref type_error for exceptions indicating executing a member function with
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref other_error for exceptions indicating other library errors
./nodes/mec/utils/httpUtils/json.hpp:------------------------------ | --------------- | -------------------------
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref exception for the base class of the library exceptions
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref parse_error for exceptions indicating a parse error
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref invalid_iterator for exceptions indicating errors with iterators
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref type_error for exceptions indicating executing a member function with
./nodes/mec/utils/httpUtils/json.hpp:@sa - @ref out_of_range for exceptions indicating access out of the defined range
./nodes/mec/utils/httpUtils/json.hpp:      typename make_index_sequence < N - N / 2 >::type > {};
./nodes/mec/utils/httpUtils/json.hpp:template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
./nodes/mec/utils/httpUtils/json.hpp:@sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
./nodes/mec/utils/httpUtils/json.hpp:- order: null < boolean < number < object < array < string < binary
./nodes/mec/utils/httpUtils/json.hpp:- furthermore, each type is not smaller than itself
./nodes/mec/utils/httpUtils/json.hpp:- discarded values are not comparable
./nodes/mec/utils/httpUtils/json.hpp:- binary is represented as a b"" string in python and directly comparable to a
./nodes/mec/utils/httpUtils/json.hpp:-> decltype(j.template get<T>(), void())
./nodes/mec/utils/httpUtils/json.hpp:-> decltype(j.template get<T>(), void())
./nodes/mec/utils/httpUtils/json.hpp:-> decltype(
./nodes/mec/utils/httpUtils/json.hpp:-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
./nodes/mec/utils/httpUtils/json.hpp:    -> decltype(from_json(j, val), void())
./nodes/mec/utils/httpUtils/json.hpp:auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
./nodes/mec/utils/httpUtils/json.hpp:auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
./nodes/mec/utils/httpUtils/json.hpp:    -> decltype(to_json(j, std::forward<T>(val)), void())
./nodes/mec/utils/httpUtils/json.hpp:    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
./nodes/mec/utils/httpUtils/json.hpp:    -> decltype(::nlohmann::to_json(j, std::forward<ValueType>(val)), void())
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref subtype() -- return the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref clear_subtype() -- clears the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref has_subtype() -- returns whether or not the binary value has a
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref set_subtype() -- sets the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref clear_subtype() -- clears the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref has_subtype() -- returns whether or not the binary value has a
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref subtype() -- return the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref set_subtype() -- sets the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref clear_subtype() -- clears the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref subtype() -- return the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref set_subtype() -- sets the binary subtype
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref has_subtype() -- returns whether or not the binary value has a
./nodes/mec/utils/httpUtils/json.hpp:auto input_adapter(const ContainerType& container) -> decltype(input_adapter(begin(container), end(container)))
./nodes/mec/utils/httpUtils/json.hpp:auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N))
./nodes/mec/utils/httpUtils/json.hpp:        if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
./nodes/mec/utils/httpUtils/json.hpp:        object_element = &(ref_stack.back()->m_value.object->operator[](val));
./nodes/mec/utils/httpUtils/json.hpp:        if (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
./nodes/mec/utils/httpUtils/json.hpp:        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());
./nodes/mec/utils/httpUtils/json.hpp:        if (ref_stack.back()->is_array())
./nodes/mec/utils/httpUtils/json.hpp:            ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
./nodes/mec/utils/httpUtils/json.hpp:            return &(ref_stack.back()->m_value.array->back());
./nodes/mec/utils/httpUtils/json.hpp:        JSON_ASSERT(ref_stack.back()->is_object());
./nodes/mec/utils/httpUtils/json.hpp:        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
./nodes/mec/utils/httpUtils/json.hpp:            object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
./nodes/mec/utils/httpUtils/json.hpp:        if (ref_stack.back() && !callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
./nodes/mec/utils/httpUtils/json.hpp:        if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
./nodes/mec/utils/httpUtils/json.hpp:            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
./nodes/mec/utils/httpUtils/json.hpp:                    ref_stack.back()->erase(it);
./nodes/mec/utils/httpUtils/json.hpp:        if (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))
./nodes/mec/utils/httpUtils/json.hpp:            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
./nodes/mec/utils/httpUtils/json.hpp:        if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
./nodes/mec/utils/httpUtils/json.hpp:            ref_stack.back()->m_value.array->pop_back();
./nodes/mec/utils/httpUtils/json.hpp:        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());
./nodes/mec/utils/httpUtils/json.hpp:        if (ref_stack.back()->is_array())
./nodes/mec/utils/httpUtils/json.hpp:            ref_stack.back()->m_value.array->push_back(std::move(value));
./nodes/mec/utils/httpUtils/json.hpp:            return {true, &(ref_stack.back()->m_value.array->back())};
./nodes/mec/utils/httpUtils/json.hpp:        JSON_ASSERT(ref_stack.back()->is_object());
./nodes/mec/utils/httpUtils/json.hpp:        value_string,     ///< a string -- use get_string() for actual value
./nodes/mec/utils/httpUtils/json.hpp:        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
./nodes/mec/utils/httpUtils/json.hpp:        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
./nodes/mec/utils/httpUtils/json.hpp:        value_float,      ///< an floating point number -- use get_number_float() for actual value
./nodes/mec/utils/httpUtils/json.hpp:                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
./nodes/mec/utils/httpUtils/json.hpp:                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
./nodes/mec/utils/httpUtils/json.hpp:                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
./nodes/mec/utils/httpUtils/json.hpp:                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
./nodes/mec/utils/httpUtils/json.hpp:                                                        - 0x35FDC00u);
./nodes/mec/utils/httpUtils/json.hpp:    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
./nodes/mec/utils/httpUtils/json.hpp:    ---------|----------|----------|----------|---------|---------|----------|-----------
./nodes/mec/utils/httpUtils/json.hpp:            case '-':
./nodes/mec/utils/httpUtils/json.hpp:                error_message = "invalid number; expected digit after '-'";
./nodes/mec/utils/httpUtils/json.hpp:            case '-':
./nodes/mec/utils/httpUtils/json.hpp:                    "invalid number; expected '+', '-', or digit after exponent";
./nodes/mec/utils/httpUtils/json.hpp:    changed - we just simulate ungetting by modifying chars_read_total,
./nodes/mec/utils/httpUtils/json.hpp:        --position.chars_read_total;
./nodes/mec/utils/httpUtils/json.hpp:                --position.lines_read;
./nodes/mec/utils/httpUtils/json.hpp:            --position.chars_read_current_line;
./nodes/mec/utils/httpUtils/json.hpp:            case '-':
./nodes/mec/utils/httpUtils/json.hpp:        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != std::char_traits<char_type>::eof();
./nodes/mec/utils/httpUtils/json.hpp:    (true --> array, false --> object).
./nodes/mec/utils/httpUtils/json.hpp:                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));
./nodes/mec/utils/httpUtils/json.hpp:                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
./nodes/mec/utils/httpUtils/json.hpp:                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
./nodes/mec/utils/httpUtils/json.hpp:                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
./nodes/mec/utils/httpUtils/json.hpp:                        - static_cast<number_integer_t>(number));
./nodes/mec/utils/httpUtils/json.hpp:                            return std::ldexp(mant + 1024, exp - 25);
./nodes/mec/utils/httpUtils/json.hpp:    not throw in case the input reached EOF, but returns a -'ve valued
./nodes/mec/utils/httpUtils/json.hpp:                vec[sizeof(NumberType) - i - 1] = static_cast<std::uint8_t>(current);
./nodes/mec/utils/httpUtils/json.hpp:                        // closing } -> we are done
./nodes/mec/utils/httpUtils/json.hpp:                        // closing ] -> we are done
./nodes/mec/utils/httpUtils/json.hpp:                // comma -> next value
./nodes/mec/utils/httpUtils/json.hpp:                // comma -> next value
./nodes/mec/utils/httpUtils/json.hpp:        error_msg += "- ";
./nodes/mec/utils/httpUtils/json.hpp:        return lhs.m_it - rhs.m_it;
./nodes/mec/utils/httpUtils/json.hpp:    primitive_iterator_t& operator--() noexcept
./nodes/mec/utils/httpUtils/json.hpp:        --m_it;
./nodes/mec/utils/httpUtils/json.hpp:    primitive_iterator_t const operator--(int) noexcept
./nodes/mec/utils/httpUtils/json.hpp:        --m_it;
./nodes/mec/utils/httpUtils/json.hpp:        m_it -= n;
./nodes/mec/utils/httpUtils/json.hpp:-
./nodes/mec/utils/httpUtils/json.hpp:    @brief post-decrement (it--)
./nodes/mec/utils/httpUtils/json.hpp:    iter_impl const operator--(int)
./nodes/mec/utils/httpUtils/json.hpp:        --(*this);
./nodes/mec/utils/httpUtils/json.hpp:    @brief pre-decrement (--it)
./nodes/mec/utils/httpUtils/json.hpp:    iter_impl& operator--()
./nodes/mec/utils/httpUtils/json.hpp:                --m_it.primitive_iterator;
./nodes/mec/utils/httpUtils/json.hpp:        result -= i;
./nodes/mec/utils/httpUtils/json.hpp:                return m_it.array_iterator - other.m_it.array_iterator;
./nodes/mec/utils/httpUtils/json.hpp:                return m_it.primitive_iterator - other.m_it.primitive_iterator;
./nodes/mec/utils/httpUtils/json.hpp:-
./nodes/mec/utils/httpUtils/json.hpp:- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
./nodes/mec/utils/httpUtils/json.hpp:    /// post-decrement (it--)
./nodes/mec/utils/httpUtils/json.hpp:    json_reverse_iterator const operator--(int)
./nodes/mec/utils/httpUtils/json.hpp:        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
./nodes/mec/utils/httpUtils/json.hpp:    /// pre-decrement (--it)
./nodes/mec/utils/httpUtils/json.hpp:    json_reverse_iterator& operator--()
./nodes/mec/utils/httpUtils/json.hpp:        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
./nodes/mec/utils/httpUtils/json.hpp:        return base_iterator(*this) - base_iterator(other);
./nodes/mec/utils/httpUtils/json.hpp:    auto key() const -> decltype(std::declval<Base>().key())
./nodes/mec/utils/httpUtils/json.hpp:        auto it = --this->base();
./nodes/mec/utils/httpUtils/json.hpp:        auto it = --this->base();
./nodes/mec/utils/httpUtils/json.hpp:                // change value to array for numbers or "-" or to object otherwise
./nodes/mec/utils/httpUtils/json.hpp:                *ptr = (nums || reference_token == "-")
./nodes/mec/utils/httpUtils/json.hpp:                    if (reference_token == "-")
./nodes/mec/utils/httpUtils/json.hpp:                        // explicitly treat "-" as index beyond the end
./nodes/mec/utils/httpUtils/json.hpp:    @throw out_of_range.402  if the array index '-' is used
./nodes/mec/utils/httpUtils/json.hpp:                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
./nodes/mec/utils/httpUtils/json.hpp:                        // "-" always fails the range check
./nodes/mec/utils/httpUtils/json.hpp:                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
./nodes/mec/utils/httpUtils/json.hpp:    @throw out_of_range.402  if the array index '-' is used
./nodes/mec/utils/httpUtils/json.hpp:                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
./nodes/mec/utils/httpUtils/json.hpp:                        // "-" cannot be used for const access
./nodes/mec/utils/httpUtils/json.hpp:                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
./nodes/mec/utils/httpUtils/json.hpp:    @throw out_of_range.402  if the array index '-' is used
./nodes/mec/utils/httpUtils/json.hpp:                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
./nodes/mec/utils/httpUtils/json.hpp:                        // "-" always fails the range check
./nodes/mec/utils/httpUtils/json.hpp:                                                                "array index '-' (" + std::to_string(ptr->m_value.array->size()) +
./nodes/mec/utils/httpUtils/json.hpp:                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
./nodes/mec/utils/httpUtils/json.hpp:                        // "-" always fails the range check
./nodes/mec/utils/httpUtils/json.hpp:        // special case: empty reference string -> no reference tokens
./nodes/mec/utils/httpUtils/json.hpp:                                                   "JSON pointer must be empty or begin with '/' - was: '" +
./nodes/mec/utils/httpUtils/json.hpp:        // - slash: position of the last read slash (or end of string)
./nodes/mec/utils/httpUtils/json.hpp:        // - start: position after the previous slash
./nodes/mec/utils/httpUtils/json.hpp:            auto reference_token = reference_string.substr(start, slash - start);
./nodes/mec/utils/httpUtils/json.hpp:                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
./nodes/mec/utils/httpUtils/json.hpp:                    const auto positive_number = -1 - j.m_value.number_integer;
./nodes/mec/utils/httpUtils/json.hpp:    @brief returns x - y
./nodes/mec/utils/httpUtils/json.hpp:        return {x.f - y.f, x.e};
./nodes/mec/utils/httpUtils/json.hpp:        // (Since Q might be larger than 2^32 - 1)
./nodes/mec/utils/httpUtils/json.hpp:        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up
./nodes/mec/utils/httpUtils/json.hpp:            x.e--;
./nodes/mec/utils/httpUtils/json.hpp:    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
./nodes/mec/utils/httpUtils/json.hpp:        const int delta = x.e - target_exponent;
./nodes/mec/utils/httpUtils/json.hpp:    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
./nodes/mec/utils/httpUtils/json.hpp:    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))
./nodes/mec/utils/httpUtils/json.hpp:    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
./nodes/mec/utils/httpUtils/json.hpp:    constexpr int      kMinExp    = 1 - kBias;
./nodes/mec/utils/httpUtils/json.hpp:    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)
./nodes/mec/utils/httpUtils/json.hpp:    const std::uint64_t E = bits >> (kPrecision - 1);
./nodes/mec/utils/httpUtils/json.hpp:    const std::uint64_t F = bits & (kHiddenBit - 1);
./nodes/mec/utils/httpUtils/json.hpp:                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);
./nodes/mec/utils/httpUtils/json.hpp:    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
./nodes/mec/utils/httpUtils/json.hpp:    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
./nodes/mec/utils/httpUtils/json.hpp:    //      ---+-------------+-------------+-------------+-------------+---  (A)
./nodes/mec/utils/httpUtils/json.hpp:    //      -----------------+------+------+-------------+-------------+---  (B)
./nodes/mec/utils/httpUtils/json.hpp:    const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
./nodes/mec/utils/httpUtils/json.hpp:                          ? diyfp(4 * v.f - 1, v.e - 2)  // (B)
./nodes/mec/utils/httpUtils/json.hpp:                          : diyfp(2 * v.f - 1, v.e - 1); // (A)
./nodes/mec/utils/httpUtils/json.hpp://      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
./nodes/mec/utils/httpUtils/json.hpp:    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
./nodes/mec/utils/httpUtils/json.hpp:    //      ==> 2^(alpha - e - 1) <= c
./nodes/mec/utils/httpUtils/json.hpp:    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
./nodes/mec/utils/httpUtils/json.hpp:    //        = ceil( (alpha - e - 1) * log_10(2) )
./nodes/mec/utils/httpUtils/json.hpp:    //           -52        (p - 1)
./nodes/mec/utils/httpUtils/json.hpp:    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
./nodes/mec/utils/httpUtils/json.hpp:    //           -52        (p - 1)
./nodes/mec/utils/httpUtils/json.hpp:    //      floor( (gamma - alpha) * log_10(2) ) = 8.
./nodes/mec/utils/httpUtils/json.hpp:    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
./nodes/mec/utils/httpUtils/json.hpp:    const int f = kAlpha - e - 1;
./nodes/mec/utils/httpUtils/json.hpp:    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
./nodes/mec/utils/httpUtils/json.hpp:    //               <--------------------------- delta ---->
./nodes/mec/utils/httpUtils/json.hpp:    //                                  <---- dist --------->
./nodes/mec/utils/httpUtils/json.hpp:    // --------------[------------------+-------------------]--------------
./nodes/mec/utils/httpUtils/json.hpp:    //                                <------>
./nodes/mec/utils/httpUtils/json.hpp:    //                                       <---- rest ---->
./nodes/mec/utils/httpUtils/json.hpp:    // --------------[------------------+----+--------------]--------------
./nodes/mec/utils/httpUtils/json.hpp:            && delta - rest >= ten_k
./nodes/mec/utils/httpUtils/json.hpp:            && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
./nodes/mec/utils/httpUtils/json.hpp:        JSON_ASSERT(buf[len - 1] != '0');
./nodes/mec/utils/httpUtils/json.hpp:        buf[len - 1]--;
./nodes/mec/utils/httpUtils/json.hpp:    //               <--------------------------- delta ---->
./nodes/mec/utils/httpUtils/json.hpp:    //                                  <---- dist --------->
./nodes/mec/utils/httpUtils/json.hpp:    // --------------[------------------+-------------------]--------------
./nodes/mec/utils/httpUtils/json.hpp:    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
./nodes/mec/utils/httpUtils/json.hpp:    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)
./nodes/mec/utils/httpUtils/json.hpp:    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e
./nodes/mec/utils/httpUtils/json.hpp:        n--;
./nodes/mec/utils/httpUtils/json.hpp:        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
./nodes/mec/utils/httpUtils/json.hpp:    decimal_exponent -= m;
./nodes/mec/utils/httpUtils/json.hpp:    //  --------(-----------------------+-----------------------)--------    (A)
./nodes/mec/utils/httpUtils/json.hpp:    //  --------------------(-----------+-----------------------)--------    (B)
./nodes/mec/utils/httpUtils/json.hpp:    //  ----(---+---)---------------(---+---)---------------(---+---)----
./nodes/mec/utils/httpUtils/json.hpp:    //      w - v * 10^k < 1 ulp
./nodes/mec/utils/httpUtils/json.hpp:    //  --------+---[---------------(---+---)---------------]---+--------
./nodes/mec/utils/httpUtils/json.hpp:    const diyfp M_plus (w_plus.f  - 1, w_plus.e );
./nodes/mec/utils/httpUtils/json.hpp:    decimal_exponent = -cached.k; // = -(-k) = k
./nodes/mec/utils/httpUtils/json.hpp:        *buf++ = '-';
./nodes/mec/utils/httpUtils/json.hpp:        std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
./nodes/mec/utils/httpUtils/json.hpp:        std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
./nodes/mec/utils/httpUtils/json.hpp:        // len <= 2 + (-min_exp - 1) + max_digits10
./nodes/mec/utils/httpUtils/json.hpp:        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
./nodes/mec/utils/httpUtils/json.hpp:    return append_exponent(buf, n - 1);
./nodes/mec/utils/httpUtils/json.hpp:    static_cast<void>(last); // maybe unused - fix warning
./nodes/mec/utils/httpUtils/json.hpp:        *first++ = '-';
./nodes/mec/utils/httpUtils/json.hpp:    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);
./nodes/mec/utils/httpUtils/json.hpp:    JSON_ASSERT(last - first >= kMaxExp + 2);
./nodes/mec/utils/httpUtils/json.hpp:    JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
./nodes/mec/utils/httpUtils/json.hpp:    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);
./nodes/mec/utils/httpUtils/json.hpp:    - strings and object keys are escaped using `escape_string()`
./nodes/mec/utils/httpUtils/json.hpp:    - integer numbers are converted implicitly via `operator<<`
./nodes/mec/utils/httpUtils/json.hpp:    - floating-point numbers are converted to a string using `"%g"` format
./nodes/mec/utils/httpUtils/json.hpp:    - binary values are serialized as objects containing the subtype and the
./nodes/mec/utils/httpUtils/json.hpp:                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
./nodes/mec/utils/httpUtils/json.hpp:                    for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
./nodes/mec/utils/httpUtils/json.hpp:                            i != val.m_value.array->cend() - 1; ++i)
./nodes/mec/utils/httpUtils/json.hpp:                            i != val.m_value.array->cend() - 1; ++i)
./nodes/mec/utils/httpUtils/json.hpp:                                i != val.m_value.binary->cend() - 1; ++i)
./nodes/mec/utils/httpUtils/json.hpp:                                i != val.m_value.binary->cend() - 1; ++i)
./nodes/mec/utils/httpUtils/json.hpp:                    if (string_buffer.size() - bytes < 13)
./nodes/mec/utils/httpUtils/json.hpp:                                --i;
./nodes/mec/utils/httpUtils/json.hpp:                                if (string_buffer.size() - bytes < 13)
./nodes/mec/utils/httpUtils/json.hpp:                        // code point will not be escaped - copy byte to buffer
./nodes/mec/utils/httpUtils/json.hpp:            *buffer_ptr = '-';
./nodes/mec/utils/httpUtils/json.hpp:        JSON_ASSERT(n_chars < number_buffer.size() - 1);
./nodes/mec/utils/httpUtils/json.hpp:            *(--buffer_ptr) = digits_to_99[digits_index][1];
./nodes/mec/utils/httpUtils/json.hpp:            *(--buffer_ptr) = digits_to_99[digits_index][0];
./nodes/mec/utils/httpUtils/json.hpp:            *(--buffer_ptr) = digits_to_99[digits_index][1];
./nodes/mec/utils/httpUtils/json.hpp:            *(--buffer_ptr) = digits_to_99[digits_index][0];
./nodes/mec/utils/httpUtils/json.hpp:            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
./nodes/mec/utils/httpUtils/json.hpp:        o->write_characters(begin, static_cast<size_t>(end - begin));
./nodes/mec/utils/httpUtils/json.hpp:        // get number of digits for a float -> text -> float round-trip
./nodes/mec/utils/httpUtils/json.hpp:            JSON_ASSERT((end - number_buffer.begin()) <= len);
./nodes/mec/utils/httpUtils/json.hpp:            len = (end - number_buffer.begin());
./nodes/mec/utils/httpUtils/json.hpp:        return static_cast<number_unsigned_t>(-(x + 1)) + 1;
./nodes/mec/utils/httpUtils/json.hpp:        return {--this->end(), true};
./nodes/mec/utils/httpUtils/json.hpp:        return {--this->end(), true};
./nodes/mec/utils/httpUtils/json.hpp:- Basic
./nodes/mec/utils/httpUtils/json.hpp: - [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible):
./nodes/mec/utils/httpUtils/json.hpp: - [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible):
./nodes/mec/utils/httpUtils/json.hpp: - [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible):
./nodes/mec/utils/httpUtils/json.hpp: - [MoveAssignable](https://en.cppreference.com/w/cpp/named_req/MoveAssignable):
./nodes/mec/utils/httpUtils/json.hpp: - [CopyAssignable](https://en.cppreference.com/w/cpp/named_req/CopyAssignable):
./nodes/mec/utils/httpUtils/json.hpp: - [Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible):
./nodes/mec/utils/httpUtils/json.hpp:- Layout
./nodes/mec/utils/httpUtils/json.hpp: - [StandardLayoutType](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType):
./nodes/mec/utils/httpUtils/json.hpp:- Library-wide
./nodes/mec/utils/httpUtils/json.hpp: - [EqualityComparable](https://en.cppreference.com/w/cpp/named_req/EqualityComparable):
./nodes/mec/utils/httpUtils/json.hpp: - [LessThanComparable](https://en.cppreference.com/w/cpp/named_req/LessThanComparable):
./nodes/mec/utils/httpUtils/json.hpp: - [Swappable](https://en.cppreference.com/w/cpp/named_req/Swappable):
./nodes/mec/utils/httpUtils/json.hpp: - [NullablePointer](https://en.cppreference.com/w/cpp/named_req/NullablePointer):
./nodes/mec/utils/httpUtils/json.hpp:- Container
./nodes/mec/utils/httpUtils/json.hpp: - [Container](https://en.cppreference.com/w/cpp/named_req/Container):
./nodes/mec/utils/httpUtils/json.hpp: - [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer);
./nodes/mec/utils/httpUtils/json.hpp:- If `m_type == value_t::object`, then `m_value.object != nullptr`.
./nodes/mec/utils/httpUtils/json.hpp:- If `m_type == value_t::array`, then `m_value.array != nullptr`.
./nodes/mec/utils/httpUtils/json.hpp:- If `m_type == value_t::string`, then `m_value.string != nullptr`.
./nodes/mec/utils/httpUtils/json.hpp:    ----------- | ---------------
./nodes/mec/utils/httpUtils/json.hpp:    - When all names are unique, objects will be interoperable in the sense
./nodes/mec/utils/httpUtils/json.hpp:    - When the names within an object are not unique, it is unspecified which
./nodes/mec/utils/httpUtils/json.hpp:    - Internally, name/value pairs are stored in lexicographical order of the
./nodes/mec/utils/httpUtils/json.hpp:    - When comparing objects, the order of the name/value pairs is irrelevant.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref array_t -- type for an array value
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref object_t -- type for an object value
./nodes/mec/utils/httpUtils/json.hpp:    - The restrictions about leading zeros is not enforced in C++. Instead,
./nodes/mec/utils/httpUtils/json.hpp:    - Not-a-number (NaN) values will be serialized to `null`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref number_float_t -- type for number values (floating-point)
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref number_unsigned_t -- type for number values (unsigned integer)
./nodes/mec/utils/httpUtils/json.hpp:    - The restrictions about leading zeros is not enforced in C++. Instead,
./nodes/mec/utils/httpUtils/json.hpp:    - Not-a-number (NaN) values will be serialized to `null`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref number_float_t -- type for number values (floating-point)
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref number_integer_t -- type for number values (integer)
./nodes/mec/utils/httpUtils/json.hpp:    - The restrictions about leading zeros is not enforced in C++. Instead,
./nodes/mec/utils/httpUtils/json.hpp:    - Not-a-number (NaN) values will be serialized to `null`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref number_integer_t -- type for number values (integer)
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref number_unsigned_t -- type for number values (unsigned integer)
./nodes/mec/utils/httpUtils/json.hpp:    > Generic binary subtype - This is the most commonly used binary subtype and
./nodes/mec/utils/httpUtils/json.hpp:    - CBOR
./nodes/mec/utils/httpUtils/json.hpp:       - Binary values are represented as byte strings. No subtypes are
./nodes/mec/utils/httpUtils/json.hpp:    - MessagePack
./nodes/mec/utils/httpUtils/json.hpp:       - If a subtype is given and the binary array contains exactly 1, 2, 4, 8,
./nodes/mec/utils/httpUtils/json.hpp:       - If no subtype is given, the bin family (bin8, bin16, bin32) is used.
./nodes/mec/utils/httpUtils/json.hpp:    - BSON
./nodes/mec/utils/httpUtils/json.hpp:       - If a subtype is given, it is used and added as unsigned 8-bit integer.
./nodes/mec/utils/httpUtils/json.hpp:       - If no subtype is given, the generic binary subtype 0x00 is used.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref binary -- create a binary array
./nodes/mec/utils/httpUtils/json.hpp:    --------- | --------------- | ------------------------
./nodes/mec/utils/httpUtils/json.hpp:    - `object_start`: the parser read `{` and started to process a JSON object
./nodes/mec/utils/httpUtils/json.hpp:    - `key`: the parser read a key of a value in an object
./nodes/mec/utils/httpUtils/json.hpp:    - `object_end`: the parser read `}` and finished processing a JSON object
./nodes/mec/utils/httpUtils/json.hpp:    - `array_start`: the parser read `[` and started to process a JSON array
./nodes/mec/utils/httpUtils/json.hpp:    - `array_end`: the parser read `]` and finished processing a JSON array
./nodes/mec/utils/httpUtils/json.hpp:    - `value`: the parser finished reading a JSON value
./nodes/mec/utils/httpUtils/json.hpp:    ------------------ | ----------- | ------------------ | -------------------
./nodes/mec/utils/httpUtils/json.hpp:    - Discarded values in structured types are skipped. That is, the parser
./nodes/mec/utils/httpUtils/json.hpp:    - In case a value outside a structured type is skipped, it is replaced
./nodes/mec/utils/httpUtils/json.hpp:    ----------- | -------------
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref clear() -- restores the postcondition of this constructor
./nodes/mec/utils/httpUtils/json.hpp:    The passed null pointer itself is not read -- it is only used to choose
./nodes/mec/utils/httpUtils/json.hpp:    - **arrays**: @ref array_t and all kinds of compatible containers such as
./nodes/mec/utils/httpUtils/json.hpp:    - **objects**: @ref object_t and all kinds of compatible associative
./nodes/mec/utils/httpUtils/json.hpp:    - **strings**: @ref string_t, string literals, and all compatible string
./nodes/mec/utils/httpUtils/json.hpp:    - **numbers**: @ref number_integer_t, @ref number_unsigned_t,
./nodes/mec/utils/httpUtils/json.hpp:    - **boolean**: @ref boolean_t / `bool` can be used.
./nodes/mec/utils/httpUtils/json.hpp:    - **binary**: @ref binary_t / `std::vector<uint8_t>` may be used,
./nodes/mec/utils/httpUtils/json.hpp:    - @a CompatibleType is not derived from `std::istream`,
./nodes/mec/utils/httpUtils/json.hpp:    - @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
./nodes/mec/utils/httpUtils/json.hpp:    - @a CompatibleType is not a different @ref basic_json type (i.e. with different template arguments)
./nodes/mec/utils/httpUtils/json.hpp:    - @a CompatibleType is not a @ref basic_json nested type (e.g.,
./nodes/mec/utils/httpUtils/json.hpp:    - @ref @ref json_serializer<U> has a
./nodes/mec/utils/httpUtils/json.hpp:    - @a BasicJsonType is a @ref basic_json type.
./nodes/mec/utils/httpUtils/json.hpp:    - @a BasicJsonType has different template arguments than @ref basic_json_t.
./nodes/mec/utils/httpUtils/json.hpp:    - the empty array (`[]`): use @ref array(initializer_list_t)
./nodes/mec/utils/httpUtils/json.hpp:    - arrays whose elements satisfy rule 2: use @ref
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref array(initializer_list_t) -- create a JSON array
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref object(initializer_list_t) -- create a JSON object
./nodes/mec/utils/httpUtils/json.hpp:            // the initializer list is a list of pairs -> create object
./nodes/mec/utils/httpUtils/json.hpp:            // the initializer list describes an array -> create array
./nodes/mec/utils/httpUtils/json.hpp:    string -- in this case, the initializer list constructor would create an
./nodes/mec/utils/httpUtils/json.hpp:    2. creating an empty array -- passing the empty initializer list to the
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref basic_json(initializer_list_t, bool, value_t) --
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref object(initializer_list_t) -- create a JSON object
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref basic_json(initializer_list_t, bool, value_t) --
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref array(initializer_list_t) -- create a JSON array
./nodes/mec/utils/httpUtils/json.hpp:    - In case of a null type, invalid_iterator.206 is thrown.
./nodes/mec/utils/httpUtils/json.hpp:    - In case of other primitive types (number, boolean, or string), @a first
./nodes/mec/utils/httpUtils/json.hpp:    - In case of structured types (array, object), the constructor behaves as
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is linear.
./nodes/mec/utils/httpUtils/json.hpp:    - As postcondition, it holds: `other == basic_json(other)`.
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is linear.
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is linear.
./nodes/mec/utils/httpUtils/json.hpp:    - All stored elements are destroyed and all memory is freed.
./nodes/mec/utils/httpUtils/json.hpp:      - "bytes": an array of bytes as integers
./nodes/mec/utils/httpUtils/json.hpp:      - "subtype": the subtype as integer or "null" if the binary has no subtype
./nodes/mec/utils/httpUtils/json.hpp:            ------------------------- | -------------------------
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref operator value_t() -- return the type of the JSON value (implicit)
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref type_name() -- return the type as string
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_structured() -- returns whether JSON value is structured
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_null() -- returns whether JSON value is `null`
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_string() -- returns whether JSON value is a string
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_boolean() -- returns whether JSON value is a boolean
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number() -- returns whether JSON value is a number
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_binary() -- returns whether JSON value is a binary array
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_primitive() -- returns whether value is primitive
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_array() -- returns whether value is an array
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_object() -- returns whether value is an object
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_integer() -- check if value is an integer or unsigned
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_float() -- check if value is a floating-point number
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number() -- check if value is a number
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_float() -- check if value is a floating-point number
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number() -- check if value is a number
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_integer() -- check if value is an integer or unsigned
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_float() -- check if value is a floating-point number
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number() -- check if value is number
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_integer() -- check if value is an integer number
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref is_number_unsigned() -- check if value is an unsigned integer
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref type() -- return the type of the JSON value (explicit)
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref type_name() -- return the type as string
./nodes/mec/utils/httpUtils/json.hpp:    - @a ValueType is not @ref basic_json,
./nodes/mec/utils/httpUtils/json.hpp:    - @ref json_serializer<ValueType> has a `from_json()` method of the form
./nodes/mec/utils/httpUtils/json.hpp:    - @ref json_serializer<ValueType> does not have a `from_json()` method of
./nodes/mec/utils/httpUtils/json.hpp:    - @a ValueType is not @ref basic_json and
./nodes/mec/utils/httpUtils/json.hpp:    - @ref json_serializer<ValueType> has a `from_json()` method of the form
./nodes/mec/utils/httpUtils/json.hpp:    - @a ValueType is not @ref basic_json,
./nodes/mec/utils/httpUtils/json.hpp:    - @ref json_serializer<ValueType> has a `from_json()` method of the form
./nodes/mec/utils/httpUtils/json.hpp:    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
./nodes/mec/utils/httpUtils/json.hpp:    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
./nodes/mec/utils/httpUtils/json.hpp:    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
./nodes/mec/utils/httpUtils/json.hpp:    constexpr auto get() const noexcept -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
./nodes/mec/utils/httpUtils/json.hpp:    linear in `idx - size()`.
./nodes/mec/utils/httpUtils/json.hpp:                                      idx - m_value.array->size() + 1,
./nodes/mec/utils/httpUtils/json.hpp:            return m_value.object->find(key)->second;
./nodes/mec/utils/httpUtils/json.hpp:            return m_value.object->find(key)->second;
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref back() -- access the last element
./nodes/mec/utils/httpUtils/json.hpp:    --tmp;
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref front() -- access the first element
./nodes/mec/utils/httpUtils/json.hpp:        --tmp;
./nodes/mec/utils/httpUtils/json.hpp:        --tmp;
./nodes/mec/utils/httpUtils/json.hpp:    - objects: amortized constant
./nodes/mec/utils/httpUtils/json.hpp:    - arrays: linear in distance between @a pos and the end of the container
./nodes/mec/utils/httpUtils/json.hpp:    - strings and binary: linear in the length of the member
./nodes/mec/utils/httpUtils/json.hpp:    - other types: constant
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(const typename object_t::key_type&) -- removes the element
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(const size_type) -- removes the element from an array at
./nodes/mec/utils/httpUtils/json.hpp:    - objects: `log(size()) + std::distance(first, last)`
./nodes/mec/utils/httpUtils/json.hpp:    - arrays: linear in the distance between @a first and @a last, plus linear
./nodes/mec/utils/httpUtils/json.hpp:    - strings and binary: linear in the length of the member
./nodes/mec/utils/httpUtils/json.hpp:    - other types: constant
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(IteratorType) -- removes the element at a given position
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(const typename object_t::key_type&) -- removes the element
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(const size_type) -- removes the element from an array at
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(IteratorType) -- removes the element at a given position
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(const size_type) -- removes the element from an array at
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(IteratorType) -- removes the element at a given position
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(IteratorType, IteratorType) -- removes the elements in
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref erase(const typename object_t::key_type&) -- removes the element
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref contains(KeyT&&) const -- checks whether a key exists
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref find(KeyT&&) -- returns an iterator to an object element
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref contains(const json_pointer&) const -- checks the existence for a JSON pointer
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref contains(KeyT &&) const -- checks the existence of a key
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref cbegin() -- returns a const iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref end() -- returns an iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref cend() -- returns a const iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of `const_cast<const basic_json&>(*this).begin()`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref begin() -- returns an iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref end() -- returns an iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref cend() -- returns a const iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref cend() -- returns a const iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref begin() -- returns an iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref cbegin() -- returns a const iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of `const_cast<const basic_json&>(*this).end()`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref end() -- returns an iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref begin() -- returns an iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref cbegin() -- returns a const iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of `reverse_iterator(end())`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref rend() -- returns a reverse iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref crend() -- returns a const reverse iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of `reverse_iterator(begin())`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref crend() -- returns a const reverse iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref rbegin() -- returns a reverse iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref rbegin() -- returns a reverse iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref rend() -- returns a reverse iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref crend() -- returns a const reverse iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of `const_cast<const basic_json&>(*this).rend()`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref rend() -- returns a reverse iterator to the end
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref rbegin() -- returns a reverse iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref crbegin() -- returns a const reverse iterator to the beginning
./nodes/mec/utils/httpUtils/json.hpp:            ----------- | -------------
./nodes/mec/utils/httpUtils/json.hpp:    is empty - it returns whether the JSON container itself is empty which is
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of `begin() == end()`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref size() -- returns the number of elements
./nodes/mec/utils/httpUtils/json.hpp:            ----------- | -------------
./nodes/mec/utils/httpUtils/json.hpp:    value - it returns the number of elements in the JSON value which is 1 in
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of `std::distance(begin(), end())`.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref empty() -- checks whether the container is empty
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref max_size() -- returns the maximal number of elements
./nodes/mec/utils/httpUtils/json.hpp:            ----------- | -------------
./nodes/mec/utils/httpUtils/json.hpp:    - The complexity is constant.
./nodes/mec/utils/httpUtils/json.hpp:    - Has the semantics of returning `b.size()` where `b` is the largest
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref size() -- returns the number of elements
./nodes/mec/utils/httpUtils/json.hpp:    ----------- | -------------
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref basic_json(value_t) -- constructor that creates an object with the
./nodes/mec/utils/httpUtils/json.hpp:        if (is_object() && init.size() == 2 && (*init.begin())->is_string())
./nodes/mec/utils/httpUtils/json.hpp:            basic_json&& key = init.begin()->moved_or_copied();
./nodes/mec/utils/httpUtils/json.hpp:                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
./nodes/mec/utils/httpUtils/json.hpp:    - Two JSON values are equal if (1) they are from the same type and (2)
./nodes/mec/utils/httpUtils/json.hpp:    - Integer and floating-point numbers are automatically converted before
./nodes/mec/utils/httpUtils/json.hpp:    - Two JSON null values are equal.
./nodes/mec/utils/httpUtils/json.hpp:        return std::abs(a - b) <= epsilon;
./nodes/mec/utils/httpUtils/json.hpp:                return std::abs(lhs - rhs) <= std::numeric_limits<float>::epsilon();
./nodes/mec/utils/httpUtils/json.hpp:    - If @a lhs and @a rhs have the same type, the values are compared using
./nodes/mec/utils/httpUtils/json.hpp:    - Integer and floating-point numbers are automatically converted before
./nodes/mec/utils/httpUtils/json.hpp:    - In case @a lhs and @a rhs have different types, the values are ignored
./nodes/mec/utils/httpUtils/json.hpp:    - The indentation of the output can be controlled with the member variable
./nodes/mec/utils/httpUtils/json.hpp:    - The indentation character can be controlled with the member variable
./nodes/mec/utils/httpUtils/json.hpp:    - an std::istream object
./nodes/mec/utils/httpUtils/json.hpp:    - a FILE pointer
./nodes/mec/utils/httpUtils/json.hpp:    - a C-style array of characters
./nodes/mec/utils/httpUtils/json.hpp:    - a pointer to a null-terminated string of single byte characters
./nodes/mec/utils/httpUtils/json.hpp:    - an object obj for which begin(obj) and end(obj) produces a valid pair of
./nodes/mec/utils/httpUtils/json.hpp:    - an std::istream object
./nodes/mec/utils/httpUtils/json.hpp:    - a FILE pointer
./nodes/mec/utils/httpUtils/json.hpp:    - a C-style array of characters
./nodes/mec/utils/httpUtils/json.hpp:    - a pointer to a null-terminated string of single byte characters
./nodes/mec/utils/httpUtils/json.hpp:    - an object obj for which begin(obj) and end(obj) produces a valid pair of
./nodes/mec/utils/httpUtils/json.hpp:    - an std::istream object
./nodes/mec/utils/httpUtils/json.hpp:    - a FILE pointer
./nodes/mec/utils/httpUtils/json.hpp:    - a C-style array of characters
./nodes/mec/utils/httpUtils/json.hpp:    - a pointer to a null-terminated string of single byte characters
./nodes/mec/utils/httpUtils/json.hpp:    - an object obj for which begin(obj) and end(obj) produces a valid pair of
./nodes/mec/utils/httpUtils/json.hpp:    Returns the type name as string to be used in error messages - usually to
./nodes/mec/utils/httpUtils/json.hpp:            ----------- | -------------
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref type() -- return the type of the JSON value
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref operator value_t() -- return the type of the JSON value (implicit)
./nodes/mec/utils/httpUtils/json.hpp:    --------------- | ------------------------------------------ | ---------------------------------- | ---------------
./nodes/mec/utils/httpUtils/json.hpp:          - UTF-8 strings terminated by "break" (0x7F)
./nodes/mec/utils/httpUtils/json.hpp:          - arrays terminated by "break" (0x9F)
./nodes/mec/utils/httpUtils/json.hpp:          - maps terminated by "break" (0xBF)
./nodes/mec/utils/httpUtils/json.hpp:          - byte strings terminated by "break" (0x5F)
./nodes/mec/utils/httpUtils/json.hpp:          - date/time (0xC0..0xC1)
./nodes/mec/utils/httpUtils/json.hpp:          - bignum (0xC2..0xC3)
./nodes/mec/utils/httpUtils/json.hpp:          - decimal fraction (0xC4)
./nodes/mec/utils/httpUtils/json.hpp:          - bigfloat (0xC5)
./nodes/mec/utils/httpUtils/json.hpp:          - expected conversions (0xD5..0xD7)
./nodes/mec/utils/httpUtils/json.hpp:          - simple values (0xE0..0xF3, 0xF8)
./nodes/mec/utils/httpUtils/json.hpp:          - undefined (0xF7)
./nodes/mec/utils/httpUtils/json.hpp:          - half-precision floats (0xF9)
./nodes/mec/utils/httpUtils/json.hpp:          - break (0xFF)
./nodes/mec/utils/httpUtils/json.hpp:    --------------- | --------------------------------- | ---------------- | ----------
./nodes/mec/utils/httpUtils/json.hpp:          - strings with more than 4294967295 bytes
./nodes/mec/utils/httpUtils/json.hpp:          - byte strings with more than 4294967295 bytes
./nodes/mec/utils/httpUtils/json.hpp:          - arrays with more than 4294967295 elements
./nodes/mec/utils/httpUtils/json.hpp:          - objects with more than 4294967295 elements
./nodes/mec/utils/httpUtils/json.hpp:    --------------- | --------------------------------- | ----------- | ------
./nodes/mec/utils/httpUtils/json.hpp:          - strings with more than 9223372036854775807 bytes (theoretical)
./nodes/mec/utils/httpUtils/json.hpp:          - `Z`: no-op values are not created.
./nodes/mec/utils/httpUtils/json.hpp:          - `C`: single-byte strings are serialized with `S` markers.
./nodes/mec/utils/httpUtils/json.hpp:          that @a use_size = true alone may result in larger representations -
./nodes/mec/utils/httpUtils/json.hpp:    --------------- | --------------------------------- | ----------- | ------
./nodes/mec/utils/httpUtils/json.hpp:    number_unsigned | 9223372036854775808..18446744073709551615| --   | --
./nodes/mec/utils/httpUtils/json.hpp:    ---------------------- | --------------- | ----------
./nodes/mec/utils/httpUtils/json.hpp:             - date/time (0xC0..0xC1)
./nodes/mec/utils/httpUtils/json.hpp:             - bignum (0xC2..0xC3)
./nodes/mec/utils/httpUtils/json.hpp:             - decimal fraction (0xC4)
./nodes/mec/utils/httpUtils/json.hpp:             - bigfloat (0xC5)
./nodes/mec/utils/httpUtils/json.hpp:             - expected conversions (0xD5..0xD7)
./nodes/mec/utils/httpUtils/json.hpp:             - simple values (0xE0..0xF3, 0xF8)
./nodes/mec/utils/httpUtils/json.hpp:             - undefined (0xF7)
./nodes/mec/utils/httpUtils/json.hpp:    ---------------- | --------------- | ----------
./nodes/mec/utils/httpUtils/json.hpp:    ----------- | --------------------------------------- | ------
./nodes/mec/utils/httpUtils/json.hpp:    high-precision number | number_integer, number_unsigned, or number_float - depends on number string | 'H'
./nodes/mec/utils/httpUtils/json.hpp:    --------------- | ---------------- | ---------------------------
./nodes/mec/utils/httpUtils/json.hpp:    - If the JSON pointer points to an object key that does not exist, it
./nodes/mec/utils/httpUtils/json.hpp:    - If the JSON pointer points to an array index that does not exist, it
./nodes/mec/utils/httpUtils/json.hpp:    - The special value `-` is treated as a synonym for the index past the
./nodes/mec/utils/httpUtils/json.hpp:    `-` yields an exception.
./nodes/mec/utils/httpUtils/json.hpp:    @throw out_of_range.402  if the array index '-' is used
./nodes/mec/utils/httpUtils/json.hpp:    @throw out_of_range.402 if the array index '-' is used in the passed JSON
./nodes/mec/utils/httpUtils/json.hpp:    implicitly inserted), the index '-' is always invalid. See example below.
./nodes/mec/utils/httpUtils/json.hpp:    @throw out_of_range.402 if the array index '-' is used in the passed JSON
./nodes/mec/utils/httpUtils/json.hpp:    implicitly inserted), the index '-' is always invalid. See example below.
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref diff -- create a JSON patch by comparing two JSON values
./nodes/mec/utils/httpUtils/json.hpp:                    if (last_path == "-")
./nodes/mec/utils/httpUtils/json.hpp:                                          bool string_type) -> basic_json &
./nodes/mec/utils/httpUtils/json.hpp:                    // the "path" location must exist - use at()
./nodes/mec/utils/httpUtils/json.hpp:                    // the "from" location must exist - use at()
./nodes/mec/utils/httpUtils/json.hpp:                    // the "from" location must exist - use at()
./nodes/mec/utils/httpUtils/json.hpp:                        // the "path" location must exist - use at()
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref patch -- apply a JSON patch
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref merge_patch -- apply a JSON Merge Patch
./nodes/mec/utils/httpUtils/json.hpp:                        {"path", path + "/-"},
./nodes/mec/utils/httpUtils/json.hpp:                        // found a key that is not in o -> remove it
./nodes/mec/utils/httpUtils/json.hpp:                        // found a key that is not in this -> add it
./nodes/mec/utils/httpUtils/json.hpp:    @sa @ref patch -- apply a JSON patch
./nodes/mec/utils/MecCommon.h: * ETSI GS MEC 011 V2.2.1 (2020-12) - 8.1.2.2 Type: ServiceInfo
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            at.out++ --> independentMecAppOut++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            at.in++ <-- independentMecAppIn++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            at.out++ --> mecPlatform$o[i];
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            at.in++ <-- mecPlatform$i[i];
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        at.out++ --> udp.appIn;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        at.in++ <-- udp.appOut;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        at.out++ --> tcp.appIn;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        at.in++ <-- tcp.appOut;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        udp.ipOut --> tn.in++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        udp.ipIn <-- tn.out++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        tcp.ipOut --> tn.in++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        tcp.ipIn <-- tn.out++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        ipv4.ifIn <-- nl.out++ if hasIpv4;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        ipv4.ifOut --> nl.in++ if hasIpv4;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        ipv4.transportIn <-- tn.out++ if hasIpv4;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        ipv4.transportOut --> tn.in++ if hasIpv4;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        ipv6.ifIn <-- nl.out++ if hasIpv6;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        ipv6.ifOut --> nl.in++ if hasIpv6;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        ipv6.transportIn <-- tn.out++ if hasIpv6;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        ipv6.transportOut --> tn.in++ if hasIpv6;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            pppIf[i].upperLayerOut --> nl.in++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            pppIf[i].upperLayerIn <-- nl.out++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            pppIf[i].phys <--> ppp++;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            encap.lowerLayerOut --> extEth[i].upperLayerIn;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:            encap.lowerLayerIn <-- extEth[i].upperLayerOut;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        encap.upperLayerOut --> nl.in++ if numExtEthInterfaces != 0;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        encap.upperLayerIn <-- nl.out++ if numExtEthInterfaces != 0;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        nl.out++ --> lo.upperLayerIn;
./nodes/mec/VirtualisationInfrastructure/VirtualisationInfrastructure.ned:        lo.upperLayerOut --> nl.in++;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    EV << "VirtualisationInfrastructureManager::initialize - stage " << stage << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        throw cRuntimeError("VirtualisationInfrastructureManager::initialize - \tFATAL! Error when getting mecHost.maxMECApps parameter!");
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::initialize - scheduling mode is: segregation" << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::initialize - scheduling mode is: fair" << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::initialize - scheduling mode: " << schedulingMode<< " not recognized. Using default mode: segregation" << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        throw cRuntimeError("VirtualisationInfrastructureManager::initialize - mecHost.maxMECApps parameter!");
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    inet::L3Address gtpAddress = inet::L3AddressResolver().resolve(mecHost->getSubmodule("upf_mec")->getFullPath().c_str());
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc://    ------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    interfaceTable = check_and_cast<inet::InterfaceTable*>(mecHost->getSubmodule("virtualisationInfrastructure")->getSubmodule("interfaceTable"));
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        if(strcmp("pppIf0", interfaceTable->getInterface(i)->getInterfaceName()) == 0)
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            mecAppRemoteAddress_ = interfaceTable->getInterface(i)->getIpv4Address();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        else if (strcmp("eth", interfaceTable->getInterface(i)->getInterfaceName()) == 0)
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            mecAppLocalAddress_ = interfaceTable->getInterface(i)->getIpv4Address();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc://            throw cRuntimeError("VirtualisationInfrastructureManager::initialize - Unknown interface [%s] found. Have you changed the names?", interfaceTable->getInterface(i)->getInterfaceName());
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    EV << "VirtualisationInfrastructureManager::instantiateEmulatedMEApp - processing..." << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::instantiateEmulatedMEApp - ueAppIdToMeAppMapKey[" << ueAppID << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc://        EV << "VirtualisationInfrastructureManager::instantiateMEApp - UEAppL3Address: " << ueAppAddress.str() << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            EV << "VirtualisationInfrastructureManager::instantiateEmulatedMEApp - Mec Application with required resources:\n" <<
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::instantiateEmulatedMEApp - meModuleName: " << appName.str() << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc://        EV << "VirtualisationInfrastructureManager::instantiateMEApp - calling ackMEAppPacket with  "<< ACK_START_MEAPP << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::instantiateEmulatedMEApp - currentMEApps: " << currentMEApps << " / " << maxMECApps << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    EV << "VirtualisationInfrastructureManager::instantiateMEApp - processing..." << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::instantiateMEApp - freeGate: " << index << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::instantiateMEApp - ueAppIdToMeAppMapKey[" << ueAppID << "] = " << index << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc://        EV << "VirtualisationInfrastructureManager::instantiateMEApp - UEAppL3Address: " << ueAppAddress.str() << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            EV << "VirtualisationInfrastructureManager::instantiateMEApp - Mec Applciation with required resources:\n" <<
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::instantiateMEApp - meModuleName: " << appName.str() << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc://        EV << "VirtualisationInfrastructureManager::instantiateMEApp - UEAppSimbolicAddress: " << sourceAddress << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        virtualisationInfr->gate("meAppOut", index)->connectTo(module->gate("socketIn"));
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        virtualisationInfr->gate("meAppIn", index)->connectTo(newAtInGate);
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        module->gate("socketOut")->connectTo(virtualisationInfr->gate("meAppIn", index));
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            EV << "VirtualisationInfrastructureManager::instantiateMEApp - Connecting to the: " << msg->getRequiredService()<< endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            mecPlatform->gate("meAppOut", index)->connectTo(module->gate("mePlatformIn"));
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            module->gate("mePlatformOut")->connectTo(mecPlatform->gate("meAppIn", index));
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            (meServices.at(serviceIndex))->gate("meAppOut", index)->connectTo(mecPlatform->gate("meAppOut", index));
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            mecPlatform->gate("meAppIn", index)->connectTo((meServices.at(serviceIndex))->gate("meAppIn", index));
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        else EV << "VirtualisationInfrastructureManager::instantiateMEApp - NO omnet++-like MECServices required!"<< endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::instantiateMEApp - "<< module->getName() <<" instanced!" << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::instantiateMEApp - currentMEApps: " << currentMEApps << " / " << maxMECApps << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::terminateMEApp - " << mecAppMap[key].meAppModule->getName() << " terminated!" << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        currentMEApps--;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::terminateMEApp - currentMEApps: " << currentMEApps << " / " << maxMECApps << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::terminateMEApp - \tWARNING: NO INSTANCE FOUND!" << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::terminateMEApp - " << mecAppMap[key].meAppModule->getName() << " terminated!" << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        currentMEApps--;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::terminateMEApp - currentMEApps: " << currentMEApps << " / " << maxMECApps << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc://        EV << "VirtualisationInfrastructureManager::terminateMEApp - calling ackMEAppPacket with  "<< ACK_STOP_MEAPP << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        virtualisationInfr->gate("meAppOut", index)->getPreviousGate()->disconnect();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        virtualisationInfr->gate("meAppIn", index)->disconnect();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            (meServices.at(serviceIndex))->gate("meAppOut", index)->disconnect();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            (meServices.at(serviceIndex))->gate("meAppIn", index)->disconnect();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            mecPlatform->gate("meAppOut", index)->disconnect();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            mecPlatform->gate("meAppIn", index)->disconnect();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::terminateMEApp - \tWARNING: NO INSTANCE FOUND!" << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:       if(!strcmp((*it)->getClassName(), serviceName))
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    return it - meServices.begin();
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    EV << "VirtualisationInfrastructureManager::registerMecApp - RAM: " << reqRam << " CPU: " << reqCpu << " disk: "<< reqDisk<< endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::handleMEAppResources - independent MEC application with mecAppId ["<< ueAppID << "] already instantiated"<< endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::handleMEAppResources - resources ALLOCATED for independent MecApp with module id " << ueAppID  << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::handleMEAppResources - ram: " << mecAppMap[ueAppID].resources.ram <<" disk: "<< mecAppMap[ueAppID].resources.disk <<" cpu: "<< mecAppMap[ueAppID].resources.cpu << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::handleMEAppResources - resources NOT AVAILABLE for independent MecApp with module id " << ueAppID  << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::handleMEAppResources - resources DEALLOCATED for MecApp with UEAppId " << ueAppID  << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::handleMEAppResources - ram: " << mecAppMap[ueAppID].resources.ram <<" disk: "<< mecAppMap[ueAppID].resources.disk <<" cpu: "<< mecAppMap[ueAppID].resources.cpu << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::handleMEAppResources - NO ALLOCATION FOUND for MecApp with UEAppId id " << ueAppID  << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::calculateProcessingTime - calculated time: " << time << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:        EV << "VirtualisationInfrastructureManager::calculateProcessingTime - ZERO " << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    avRes.ram = maxRam - allocatedRam;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    avRes.disk = maxDisk - allocatedDisk;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    avRes.cpu = maxCPU - allocatedCPU;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:    EV << "VirtualisationInfrastructureManager::reserveResourcesBGApps - reserving resources for "<< numMecApps << " BG apps..." << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.cc:            throw cRuntimeError("VirtualisationInfrastructureManager::reserveResourcesBGApps - Background Mec App bgApp[%d] not found!", i);
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    //-------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    // ------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    // ------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    // key = MEC App gate index - value mecAppMapEntry
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:    //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:         *  - Segregation: where the MEC app obtains exactly the amount of computing resources
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:         *  - Fair sharing: where active MEC apps share all the available computing resources
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:         * @param numOfInstructions - number of instructions the MEC app wants to execute
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:         * @param reqRam, reqDisk, reqCpu - computation resources needed by the MEC app
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:         * @param reqRam, reqDisk, reqCpu - computation resources needed by the MEC app
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:                    ram  < maxRam - allocatedRam &&
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:                    disk < maxDisk - allocatedDisk &&
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:                    cpu  < maxCPU - allocatedCPU);
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:            EV << "VirtualisationInfrastructureManager::printResources - allocated Ram: " << allocatedRam << " / " << maxRam << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:            EV << "VirtualisationInfrastructureManager::printResources - allocated Disk: " << allocatedDisk << " / " << maxDisk << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:            EV << "VirtualisationInfrastructureManager::printResources - allocated CPU: " << allocatedCPU << " / " << maxCPU << endl;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:        //------------------------------------
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:            allocatedRam -= ram;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:            allocatedDisk -= disk;
./nodes/mec/VirtualisationInfrastructureManager/VirtualisationInfrastructureManager.h:            allocatedCPU -= cpu;
./nodes/NR/NRUe.ned:        //# UeStatsCollector - for MEC
./nodes/NR/NRUe.ned:        cellularNic.nrRadioIn <-- nrRadioIn;
./nodes/PgwStandard.ned:        gtp_user.socketOut --> at.in++;
./nodes/PgwStandard.ned:        gtp_user.socketIn <-- at.out++;
./nodes/PgwStandard.ned:        pppIf.upperLayerOut --> trafficFlowFilter.internetFilterGateIn;
./nodes/PgwStandard.ned:        pppIf.upperLayerIn <-- gtp_user.pppGate;
./nodes/PgwStandard.ned:        trafficFlowFilter.gtpUserGateOut --> gtp_user.trafficFlowFilterGate;
./nodes/PgwStandard.ned:        at.out++ --> udp.appIn;
./nodes/PgwStandard.ned:        at.in++ <-- udp.appOut;
./nodes/PgwStandard.ned:        udp.ipOut --> tn.in++;
./nodes/PgwStandard.ned:        udp.ipIn <-- tn.out++;
./nodes/PgwStandard.ned:        tn.out++ --> ipv4.transportIn if hasIpv4;
./nodes/PgwStandard.ned:        tn.in++ <-- ipv4.transportOut if hasIpv4;
./nodes/PgwStandard.ned:        tn.out++ --> ipv6.transportIn if hasIpv6;
./nodes/PgwStandard.ned:        tn.in++ <-- ipv6.transportOut if hasIpv6;
./nodes/PgwStandard.ned:        tn.out++ --> generic.transportIn if hasGn;
./nodes/PgwStandard.ned:        tn.in++ <-- generic.transportOut if hasGn;
./nodes/PgwStandard.ned:        tn.out++ --> nl.in++;
./nodes/PgwStandard.ned:        tn.in++ <-- nl.out++;
./nodes/PgwStandard.ned:        pppIf.phys <--> filterGate;
./nodes/Ue.ned:        //# UeStatsCollector - for MEC
./nodes/Ue.ned:            app[i].socketOut --> at.in++;
./nodes/Ue.ned:            app[i].socketIn <-- at.out++;
./nodes/Ue.ned:        at.out++ --> udp.appIn if hasUdp;
./nodes/Ue.ned:        at.in++ <-- udp.appOut if hasUdp;
./nodes/Ue.ned:        at.out++ --> tcp.appIn if hasTcp;
./nodes/Ue.ned:        at.in++ <-- tcp.appOut if hasTcp;
./nodes/Ue.ned:        at.out++ --> sctp.appIn if hasSctp;
./nodes/Ue.ned:        at.in++ <-- sctp.appOut if hasSctp;
./nodes/Ue.ned:        udp.ipOut --> tn.in++ if hasUdp;
./nodes/Ue.ned:        udp.ipIn <-- tn.out++ if hasUdp;
./nodes/Ue.ned:        tcp.ipOut --> tn.in++ if hasTcp;
./nodes/Ue.ned:        tcp.ipIn <-- tn.out++ if hasTcp;
./nodes/Ue.ned:        sctp.ipOut --> tn.in++ if hasSctp;
./nodes/Ue.ned:        tn.out++ --> sctp.ipIn if hasSctp;
./nodes/Ue.ned:        ipv4.ifIn <-- nl.out++ if hasIpv4;
./nodes/Ue.ned:        ipv4.ifOut --> nl.in++ if hasIpv4;
./nodes/Ue.ned:        ipv4.transportIn <-- tn.out++ if hasIpv4;
./nodes/Ue.ned:        ipv4.transportOut --> tn.in++ if hasIpv4;
./nodes/Ue.ned:        ipv6.ifIn <-- nl.out++ if hasIpv6;
./nodes/Ue.ned:        ipv6.ifOut --> nl.in++ if hasIpv6;
./nodes/Ue.ned:        ipv6.transportIn <-- tn.out++ if hasIpv6;
./nodes/Ue.ned:        ipv6.transportOut --> tn.in++ if hasIpv6;
./nodes/Ue.ned:        tn.out++ --> nl.in++;
./nodes/Ue.ned:        tn.in++ <-- nl.out++;
./nodes/Ue.ned:        cellularNic.upperLayerOut --> nl.in++;
./nodes/Ue.ned:        cellularNic.upperLayerIn <-- nl.out++;
./nodes/Ue.ned:            encap.lowerLayerOut --> eth[i].upperLayerIn;
./nodes/Ue.ned:            encap.lowerLayerIn <-- eth[i].upperLayerOut;
./nodes/Ue.ned:        encap.upperLayerOut --> nl.in++ if numEthInterfaces != 0;
./nodes/Ue.ned:        encap.upperLayerIn <-- nl.out++ if numEthInterfaces != 0;
./nodes/Ue.ned:            nl.out++ --> lo[i].upperLayerIn;
./nodes/Ue.ned:            lo[i].upperLayerOut --> nl.in++;
./nodes/Ue.ned:        cellularNic.radioIn <-- radioIn;
./nodes/Upf.ned:        gtp_user.socketOut --> at.in++;
./nodes/Upf.ned:        gtp_user.socketIn <-- at.out++;
./nodes/Upf.ned:        pppIf.upperLayerOut --> trafficFlowFilter.internetFilterGateIn;
./nodes/Upf.ned:        pppIf.upperLayerIn <-- gtp_user.pppGate;
./nodes/Upf.ned:        trafficFlowFilter.gtpUserGateOut --> gtp_user.trafficFlowFilterGate;
./nodes/Upf.ned:        at.out++ --> udp.appIn;
./nodes/Upf.ned:        at.in++ <-- udp.appOut;
./nodes/Upf.ned:        udp.ipOut --> tn.in++;
./nodes/Upf.ned:        udp.ipIn <-- tn.out++;
./nodes/Upf.ned:        tn.out++ --> ipv4.transportIn if hasIpv4;
./nodes/Upf.ned:        tn.in++ <-- ipv4.transportOut if hasIpv4;
./nodes/Upf.ned:        tn.out++ --> ipv6.transportIn if hasIpv6;
./nodes/Upf.ned:        tn.in++ <-- ipv6.transportOut if hasIpv6;
./nodes/Upf.ned:        tn.out++ --> generic.transportIn if hasGn;
./nodes/Upf.ned:        tn.in++ <-- generic.transportOut if hasGn;
./nodes/Upf.ned:        tn.out++ --> nl.in++;
./nodes/Upf.ned:        tn.in++ <-- nl.out++;
./nodes/Upf.ned:        pppIf.phys <--> filterGate;
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'ActiveUeNotification' as cValue -- field index out of range?", field);
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/ActiveUeNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:            bgUe_.push_back(check_and_cast<TrafficGeneratorBase*>(getParentModule()->getSubmodule("bgUE", i)->getSubmodule("generator")));
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:        phyPisaData_ = &(getBinder()->phyPisaData);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:        mac_ = check_and_cast<LteMacEnb*>(getParentModule()->getParentModule()->getSubmodule("mac"));
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:            LtePhyEnb* phy = check_and_cast<LtePhyEnb*>(getParentModule()->getParentModule()->getSubmodule("phy"));
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:                throw cRuntimeError("BackgroundTrafficManager::initialize - cannot find channel model for carrier frequency %f", carrierFrequency_);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:        getBinder()->addBgTrafficManagerInfo(info);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:        throw cRuntimeError("TrafficGeneratorBase::consumeBytes - unrecognized direction: %d" , dir);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:        LtePhyEnb* phy = check_and_cast<LtePhyEnb*>(getParentModule()->getParentModule()->getSubmodule("phy"));
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:            throw cRuntimeError("BackgroundTrafficManager::getCqi - cannot find channel model for carrier frequency %f", carrierFrequency_);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:        double diff = targetBler - tmp;
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    int index = bgUeId - BGUE_MIN_ID;
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    int index = bgUeId - BGUE_MIN_ID;
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    return bgUe_.at(index)->getBufferLength(dir, rtx);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    int index = bgUeId - BGUE_MIN_ID;
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    Cqi cqi = bgUe_.at(index)->getCqi(dir);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    return (mac_->getAmc()->computeBitsPerRbBackground(cqi, dir, carrierFrequency_) / 8);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    int index = bgUeId - BGUE_MIN_ID;
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    int newBuffLen = bgUe_.at(index)->consumeBytes(bytes, dir, rtx);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:    int index = bgUeId - BGUE_MIN_ID;
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:        avgCellLoad_ += bgUe_.at(i)->getAvgLoad(DL);
./stack/backgroundTrafficGenerator/BackgroundTrafficManager.cc:        avgUeLoad_.push_back(bgUe_.at(i)->getAvgLoad(UL));
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'RtxNotification' as cValue -- field index out of range?", field);
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/RtxNotification_m.cc:        field -= base->getFieldCount();
./stack/backgroundTrafficGenerator/generators/TrafficGenerator.ned:        // - periodicCqi == false && computeAvgInterference == false 
./stack/backgroundTrafficGenerator/generators/TrafficGeneratorBase.cc:        bgUeIndex_ = getParentModule()->getIndex();
./stack/backgroundTrafficGenerator/generators/TrafficGeneratorBase.cc:        bgTrafficManager_ = check_and_cast<BackgroundTrafficManager*>(getParentModule()->getParentModule()->getSubmodule("manager"));
./stack/backgroundTrafficGenerator/generators/TrafficGeneratorBase.cc:            fbPeriod_ = (simtime_t)(int(par("fbPeriod")) * TTI); // TTI -> seconds
./stack/backgroundTrafficGenerator/generators/TrafficGeneratorBase.cc:        getParentModule()->subscribe(inet::IMobility::mobilityStateChangedSignal, this);
./stack/backgroundTrafficGenerator/generators/TrafficGeneratorBase.cc:       throw cRuntimeError("TrafficGeneratorBase::consumeBytes - unrecognized direction: %d" , dir);
./stack/backgroundTrafficGenerator/generators/TrafficGeneratorBase.cc:        bufferedBytes_[dir] -= bytes;
./stack/backgroundTrafficGenerator/generators/TrafficGeneratorBase.cc:        bufferedBytesRtx_[dir] -= bytes;
./stack/backgroundTrafficGenerator/generators/TrafficGeneratorCbr.h:    // -- re-implemented functions from the base class -- //
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:    EV << NOW << " LteCompManagerProportional::provisionalSchedule - Start " << endl;
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:    double primaryCarrierFrequency = mac_->getCellInfo()->getCarriers()->front();
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:        unsigned int queueLength = vbuf->at(cid)->getQueueOccupancy();
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:        bytesPerBlock = mac_->getAmc()->computeBytesOnNRbs(ueId, band, cw,
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:        EV << NOW << " LteCompManagerProportional::provisionalSchedule - Per il nodo: " << ueId << " sono disponibili: " << bytesPerBlock << " bytes in un blocco" << endl;
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:            reqBlocks = (queueLength + bytesPerBlock - 1) / bytesPerBlock;
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:        EV << NOW << " LteCompManagerProportional::provisionalSchedule - Per il nodo: " << ueId << " sono necessari: " << reqBlocks << " blocchi" << endl;
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:    EV << NOW << " LteCompManagerProportional::provisionalSchedule - End " << endl;
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:    EV << NOW << " LteCompManagerProportional::doCoordination - Start " << endl;
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:    for (unsigned int i=0; i < partitioning_.size() - 1; i++)
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:    EV << NOW << " LteCompManagerProportional::doCoordination - End " << endl;
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:            throw cRuntimeError("LteCompManagerProportional::handleClientRequest - Expected COMP_PROP_REQUEST_IE");
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:                    "LteCompManagerProportional::handleCoordinatorReply - Expected COMP_PROP_REPLY_IE");
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:            for (unsigned int i = 0; i < len - 1; i++)
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:            vec[i] = (int) (doubleTot - integerTot);
./stack/compManager/compManagerProportional/LteCompManagerProportional.cc:        // TODO -  check numerical errors
./stack/compManager/LteCompManagerBase.cc:    numBands_ = mac_->getCellInfo()->getNumBands();
./stack/compManager/LteCompManagerBase.cc:        throw cRuntimeError("LteCompManagerBase::initialize - Unrecognized node type %s", nodeType);
./stack/compManager/LteCompManagerBase.cc:            throw cRuntimeError("LteCompManagerBase::handleMessage - Unrecognized self message %s", msg->getName());
./stack/compManager/LteCompManagerBase.cc:            EV << "LteCompManagerBase::handleMessage - Received message from X2 manager" << endl;
./stack/compManager/LteCompManagerBase.cc:            throw cRuntimeError("LteCompManagerBase::handleMessage - Unexpected message received at %s", incoming->getName());
./stack/compManager/LteCompManagerBase.cc:    EV << "LteCompManagerBase::runClientOperations - node " << nodeId_ << endl;
./stack/compManager/LteCompManagerBase.cc:    EV << "LteCompManagerBase::runCoordinatorOperations - node " << nodeId_ << endl;
./stack/compManager/LteCompManagerBase.cc:            throw cRuntimeError("LteCompManagerBase::handleX2Message - Sender is not the coordinator");
./stack/compManager/LteCompManagerBase.cc:    EV<<NOW<<" LteCompManagerBase::sendCompRequest - Send CoMP request (len: "<< compMsg->getByteLength()<< " B)" << endl;
./stack/compManager/LteCompManagerBase.cc:            throw cRuntimeError("LteCompManagerBase::sendCoordinatorReply - Node %d cannot sends reply to itself, since it is not the coordinator", clientId);
./stack/compManager/LteCompManagerBase.cc:    mac_->getAmc()->setPilotUsableBands(nodeId_, usableBands_);
./stack/d2dModeSelection/D2DModeSelectionBase.cc:        mac_ = check_and_cast<LteMacEnb*>(getParentModule()->getSubmodule("mac"));
./stack/d2dModeSelection/D2DModeSelectionBase.cc:            throw cRuntimeError("D2DModeSelectionBase::handleMessage - Unrecognized self message %s", msg->getName());
./stack/d2dModeSelection/D2DModeSelectionBase.cc:    EV << NOW << " D2DModeSelectionBase::doModeSwitchAtHandover - Force mode switching for UE " << nodeId << " (handover)" << endl;
./stack/d2dModeSelection/D2DModeSelectionBase.cc:            EV << NOW << " D2DModeSelectionBase::doModeSwitchAtHandover - Flow: " << srcId << " --> " << dstId << " [" << d2dModeToA(newMode) << "]" << endl;
./stack/d2dModeSelection/D2DModeSelectionBase.cc:        check_and_cast<LteMacEnbD2D*>(mac_)->sendModeSwitchNotification(srcId, dstId, oldMode, newMode);
./stack/d2dModeSelection/d2dModeSelectionBestCqi/D2DModeSelectionBestCqi.cc:    EV << NOW << " D2DModeSelectionBestCqi::doModeSelection - Running Mode Selection algorithm..." << endl;
./stack/d2dModeSelection/d2dModeSelectionBestCqi/D2DModeSelectionBestCqi.cc:    double primaryCarrierFrequency = mac_->getCellInfo()->getCarriers()->front();
./stack/d2dModeSelection/d2dModeSelectionBestCqi/D2DModeSelectionBestCqi.cc:            unsigned int bitsUl = mac_->getAmc()->computeBitsOnNRbs(srcId, 0, 0, 1, UL, primaryCarrierFrequency);
./stack/d2dModeSelection/d2dModeSelectionBestCqi/D2DModeSelectionBestCqi.cc:            unsigned int bitsD2D = mac_->getAmc()->computeBitsOnNRbs(srcId, 0, 0, 1, D2D, primaryCarrierFrequency);
./stack/d2dModeSelection/d2dModeSelectionBestCqi/D2DModeSelectionBestCqi.cc:            EV << NOW << " D2DModeSelectionBestCqi::doModeSelection - bitsUl[" << bitsUl << "] bitsD2D[" << bitsD2D << "]" << endl;
./stack/d2dModeSelection/d2dModeSelectionBestCqi/D2DModeSelectionBestCqi.cc:                EV << NOW << " D2DModeSelectionBestCqi::doModeSelection - Flow: " << srcId << " --> " << dstId << " [" << d2dModeToA(newMode) << "]" << endl;
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'D2DModeSwitchNotification' as cValue -- field index out of range?", field);
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/d2dModeSelection/D2DModeSwitchNotification_m.cc:        field -= base->getFieldCount();
./stack/dualConnectivityManager/DualConnectivityManager.cc:    pdcp_ = check_and_cast<LtePdcpRrcBase*>(getParentModule()->getSubmodule("pdcpRrc"));
./stack/dualConnectivityManager/DualConnectivityManager.cc:        EV << "DualConnectivityManager::handleMessage - Received message from X2 manager" << endl;
./stack/dualConnectivityManager/DualConnectivityManager.cc:        throw omnetpp::cRuntimeError("DualConnectivityManager::handleX2Message - Message type not valid. Abort.");
./stack/dualConnectivityManager/DualConnectivityManager.cc:    pkt->addTagIfAbsent<X2ControlInfoTag>()->setDestIdList(destList);
./stack/dualConnectivityManager/DualConnectivityManager.cc:    pkt->addTagIfAbsent<X2ControlInfoTag>()->setSourceId(nodeId_);
./stack/dualConnectivityManager/DualConnectivityManager.cc:    pkt->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&LteProtocol::x2ap);
./stack/dualConnectivityManager/DualConnectivityManager.cc:    EV<<NOW<<" DualConnectivityManager::forwardDataToTargetNode - Send packet to node " << targetNode << endl;
./stack/dualConnectivityManager/DualConnectivityManager.cc:    EV<<NOW<<" DualConnectivityManager::receiveDataFromSourceNode - Received packet from node " << sourceNode << endl;
./stack/handoverManager/LteHandoverManager.cc:    ip2nic_ = check_and_cast<IP2Nic*>(getParentModule()->getSubmodule("ip2nic"));
./stack/handoverManager/LteHandoverManager.cc:        EV << "LteHandoverManager::handleMessage - Received message from X2 manager" << endl;
./stack/handoverManager/LteHandoverManager.cc:    EV<<NOW<<" LteHandoverManager::sendHandoverCommand - Send handover command over X2 to eNB " << enb << " for UE " << ueId << endl;
./stack/handoverManager/LteHandoverManager.cc:    pkt->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&LteProtocol::x2ap);
./stack/handoverManager/LteHandoverManager.cc:    EV<<NOW<<" LteHandoverManager::receivedHandoverCommand - Received handover command over X2 from eNB " << enb << " for UE " << ueId << endl;
./stack/handoverManager/LteHandoverManager.cc:    datagram->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&LteProtocol::x2ap);
./stack/handoverManager/LteHandoverManager.cc:    EV<<NOW<<" LteHandoverManager::forwardDataToTargetEnb - Send IP datagram to eNB " << targetEnb << endl;
./stack/handoverManager/LteHandoverManager.cc:    EV<<NOW<<" LteHandoverManager::receiveDataFromSourceEnb - Received IP datagram from eNB " << sourceEnb << endl;
./stack/ip2nic/IP2Nic.cc:            cModule *bs = getParentModule()->getParentModule();
./stack/ip2nic/IP2Nic.cc:            cModule *ue = getParentModule()->getParentModule();
./stack/ip2nic/IP2Nic.cc:        if (msg->getArrivalGate()->isName("upperLayerIn"))
./stack/ip2nic/IP2Nic.cc:        else if(msg->getArrivalGate()->isName("stackNic$i"))
./stack/ip2nic/IP2Nic.cc:            EV << "IP2Nic::handleMessage - (E/GNODEB): Wrong gate " << msg->getArrivalGate()->getName() << endl;
./stack/ip2nic/IP2Nic.cc:        if (msg->getArrivalGate()->isName("upperLayerIn"))
./stack/ip2nic/IP2Nic.cc:        else if(msg->getArrivalGate()->isName("stackNic$i"))
./stack/ip2nic/IP2Nic.cc:            EV << "IP2Nic (UE): Wrong gate " << msg->getArrivalGate()->getName() << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "Node type: " << s << " -> " << nodeType_ << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "IP2Nic::fromIpUe - message from IP layer: send to stack: "  << datagram->str() << std::endl;
./stack/ip2nic/IP2Nic.cc:            EV << "IP2Nic::fromIpUe - UE is not attached to any serving node. Delete packet." << endl;
./stack/ip2nic/IP2Nic.cc:    pkt->addTagIfAbsent<FlowControlInfo>()->setSrcAddr(srcAddr.getInt());
./stack/ip2nic/IP2Nic.cc:    pkt->addTagIfAbsent<FlowControlInfo>()->setDstAddr(destAddr.getInt());
./stack/ip2nic/IP2Nic.cc:    pkt->addTagIfAbsent<FlowControlInfo>()->setHeaderSize(headerSize);
./stack/ip2nic/IP2Nic.cc:    pkt->addTagIfAbsent<FlowControlInfo>()->setTypeOfService(tos);
./stack/ip2nic/IP2Nic.cc:        EV << "IP2Nic::toStackUe - UE is not attached to any serving node. Delete packet." << endl;
./stack/ip2nic/IP2Nic.cc:    datagram->addTagIfAbsent<DispatchProtocolReq>()->setProtocol(protocol);
./stack/ip2nic/IP2Nic.cc:    datagram->addTagIfAbsent<PacketProtocolTag>()->setProtocol(protocol);
./stack/ip2nic/IP2Nic.cc:    datagram->addTagIfAbsent<InterfaceInd>()->setInterfaceId(networkIf->getInterfaceId());
./stack/ip2nic/IP2Nic.cc:    EV << "IP2Nic::toIpUe - message from stack: send to IP layer" << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "IP2Nic::fromIpBs - message from IP layer: send to stack" << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "IP2Nic::toIpBs - message from stack: send to IP layer" << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "IP2Nic::toStackBs - packet is forwarded to stack" << endl;
./stack/ip2nic/IP2Nic.cc:    pkt->addTagIfAbsent<FlowControlInfo>()->setSrcAddr(srcAddr.getInt());
./stack/ip2nic/IP2Nic.cc:    pkt->addTagIfAbsent<FlowControlInfo>()->setDstAddr(destAddr.getInt());
./stack/ip2nic/IP2Nic.cc:    pkt->addTagIfAbsent<FlowControlInfo>()->setTypeOfService(tos);
./stack/ip2nic/IP2Nic.cc:    pkt->addTagIfAbsent<FlowControlInfo>()->setHeaderSize(headerSize);
./stack/ip2nic/IP2Nic.cc:        EV << "IP2Nic::toStackBs - UE is not attached to any serving node. Delete packet." << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "Src IP : " << Ipv4Address(pkt->getTag<FlowControlInfo>()->getSrcAddr()) << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "Dst IP : " << Ipv4Address(pkt->getTag<FlowControlInfo>()->getDstAddr()) << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "ToS : " << pkt->getTag<FlowControlInfo>()->getTypeOfService() << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "Seq Num  : " << pkt->getTag<FlowControlInfo>()->getSequenceNumber() << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "Header Size : " << pkt->getTag<FlowControlInfo>()->getHeaderSize() << endl;
./stack/ip2nic/IP2Nic.cc:    InterfaceToken token(0, getSimulation()->getUniqueNumber(), 64);
./stack/ip2nic/IP2Nic.cc:    unsigned int numOfAddresses = iface->getProtocolData<Ipv4InterfaceData>()->getNumOfJoinedMulticastGroups();
./stack/ip2nic/IP2Nic.cc:        Ipv4Address addr = iface->getProtocolData<Ipv4InterfaceData>()->getJoinedMulticastGroup(i);
./stack/ip2nic/IP2Nic.cc:    // - use master eNB if tos < 10
./stack/ip2nic/IP2Nic.cc:    // - use secondary gNB if 10 <= tos < 20
./stack/ip2nic/IP2Nic.cc:    // - use split bearer if tos >= 20
./stack/ip2nic/IP2Nic.cc:    EV << NOW << " IP2Nic::triggerHandoverSource - start tunneling of packets destined to " << ueId << " towards eNB " << targetEnb << endl;
./stack/ip2nic/IP2Nic.cc:        hoManager_ = check_and_cast<LteHandoverManager*>(getParentModule()->getSubmodule("handoverManager"));
./stack/ip2nic/IP2Nic.cc:    EV << NOW << " IP2Nic::triggerHandoverTarget - start holding packets destined to " << ueId << endl;
./stack/ip2nic/IP2Nic.cc:    EV << "IP2Nic::sendTunneledPacketOnHandover - destination is handing over to eNB " << targetEnb << ". Forward packet via X2." << endl;
./stack/ip2nic/IP2Nic.cc:        hoManager_ = check_and_cast<LteHandoverManager*>(getParentModule()->getSubmodule("handoverManager"));
./stack/ip2nic/IP2Nic.cc:    EV << "IP2lte::receiveTunneledPacketOnHandover - received packet via X2 from " << sourceEnb << endl;
./stack/ip2nic/IP2Nic.cc:    EV << NOW << " IP2Nic::signalHandoverCompleteSource - handover of UE " << ueId << " to eNB " << targetEnb << " completed!" << endl;
./stack/ip2nic/IP2Nic.cc:        hoManager_ = check_and_cast<LteHandoverManager*>(getParentModule()->getSubmodule("handoverManager"));
./stack/ip2nic/IP2Nic.cc:    EV << NOW << " IP2Nic::triggerHandoverUe - start holding packets" << endl;
./stack/ip2nic/IP2Nic.cc:    if (getSimulation()->getSimulationStage() != CTX_FINISH)
./stack/ip2nic/IP2Nic.h:    // - use master eNB if tos < 10
./stack/ip2nic/IP2Nic.h:    // - use secondary gNB if 10 <= tos < 20
./stack/ip2nic/IP2Nic.h:    // - use split bearer if tos >= 20
./stack/ip2nic/IP2Nic.ned:// - Registers itself as an interface for being accessible from upper layers (e.g. IP Layer)
./stack/ip2nic/IP2Nic.ned:// - In the downstream direction adds control information to IP packets (5-tuple). Moreover in the BS 
./stack/ip2nic/SplitBearersTable.h:     *             - -1 if no entry was found
./stack/ip2nic/SplitBearersTable.h:     *             - number if it was found
./stack/LteNic.ned:        ip2nic.stackNic <--> pdcpRrc.DataPort;
./stack/LteNic.ned:        EUTRAN_RRC_Sap <--> pdcpRrc.EUTRAN_RRC_Sap;
./stack/LteNic.ned:        //# PDCP <-> RLC
./stack/LteNic.ned:        pdcpRrc.UM_Sap++ <--> rlc.UM_Sap;
./stack/LteNic.ned:        pdcpRrc.AM_Sap++ <--> rlc.AM_Sap;
./stack/LteNic.ned:        pdcpRrc.TM_Sap++ <--> rlc.TM_Sap;
./stack/LteNic.ned:        //# RLC <-> MAC
./stack/LteNic.ned:        rlc.RLC_to_MAC --> mac.RLC_to_MAC;
./stack/LteNic.ned:        rlc.MAC_to_RLC <-- mac.MAC_to_RLC;
./stack/LteNic.ned:        mac.MAC_to_PHY --> phy.upperGateIn;
./stack/LteNic.ned:        mac.PHY_to_MAC <-- phy.upperGateOut;
./stack/LteNic.ned:        radioIn --> phy.radioIn;
./stack/LteNic.ned:        ip2nic.upperLayerOut --> {  delay = parent.processingDelayOut; } --> upperLayerOut;
./stack/LteNic.ned:        upperLayerIn --> {  delay = parent.processingDelayIn; } --> ip2nic.upperLayerIn;
./stack/LteNic.ned:        compManager.x2ManagerIn <-- x2Manager.dataPort$o++ if compEnabled;
./stack/LteNic.ned:        compManager.x2ManagerOut --> x2Manager.dataPort$i++ if compEnabled;
./stack/LteNic.ned:        handoverManager.x2ManagerIn <-- x2Manager.dataPort$o++;
./stack/LteNic.ned:        handoverManager.x2ManagerOut --> x2Manager.dataPort$i++;
./stack/LteNic.ned:        dualConnectivityManager.x2ManagerIn <-- x2Manager.dataPort$o++ if dualConnectivityEnabled;
./stack/LteNic.ned:        dualConnectivityManager.x2ManagerOut --> x2Manager.dataPort$i++ if dualConnectivityEnabled;
./stack/LteNic.ned:            x2$i[0] --> x2Manager.x2Gtp$i;
./stack/LteNic.ned:            x2$o[0] <-- x2Manager.x2Gtp$o;
./stack/LteNic.ned:            x2$i[i] --> x2Manager.x2$i++;
./stack/LteNic.ned:            x2$o[i] <-- x2Manager.x2$o++;
./stack/mac/allocator/LteAllocationModule.cc:    //---------- Peering availability Check ----------
./stack/mac/allocator/LteAllocationModule.cc:    //---- If we reach this point, we can use MuMimo peering by setting the allocator properly ----
./stack/mac/allocator/LteAllocationModule.cc:    int availableBlocks = resourceBlocks - allocatedBlocks;
./stack/mac/allocator/LteAllocationModule.cc:    EV << NOW << " LteAllocationModule::computeTotalRbs " << dirToA(dir_) << " - total " << resourceBlocks <<
./stack/mac/allocator/LteAllocationModule.cc:        EV << NOW << " LteAllocator::availableBlocks " << dirToA(dir_) << " - Band " << band <<
./stack/mac/allocator/LteAllocationModule.cc:        " has " << blocksPerBand - allocatedBlocks <<
./stack/mac/allocator/LteAllocationModule.cc:        return (blocksPerBand - allocatedBlocks);
./stack/mac/allocator/LteAllocationModule.cc:    if ((availableBlocksOnBand - (int) blocks) < 0)
./stack/mac/allocator/LteAllocationModule.cc:        EV << NOW << " LteAllocator::addBlocks " << dirToA(dir_) << " - Node " << nodeId <<
./stack/mac/allocator/LteAllocationModule.cc:        EV << NOW << " LteAllocator::addBlocks " << dirToA(dir_) << " - Node " << nodeId << " - 0 bytes available with " << blocks << " blocks" << endl;
./stack/mac/allocator/LteAllocationModule.cc:    EV << NOW << " LteAllocator::addBlocks " << dirToA(dir_) << " - Node " << nodeId << ", the request of " << blocks << " blocks on band " << band << " satisfied" << endl;
./stack/mac/allocator/LteAllocationModule.cc:        EV << NOW << " LteAllocator::removeBlocks " << dirToA(dir_) << " - Node " << nodeId << ", invalid band " << band << endl;
./stack/mac/allocator/LteAllocationModule.cc:    allocatedRbsPerBand_[plane][antenna][band].allocated_ -= toDrain;
./stack/mac/allocator/LteAllocationModule.cc:    allocatedRbsMatrix_[plane][antenna] -= toDrain;
./stack/mac/allocator/LteAllocationModule.cc:    EV << NOW << " LteAllocator::removeBlocks " << dirToA(dir_) << " - Node " << nodeId << ", " << toDrain << " blocks drained from band " << band << endl;
./stack/mac/allocator/LteAllocationModule.h:    // --- General Parameters ------------------------------------------------------------------
./stack/mac/allocator/LteAllocationModule.h:    // --- Get (Parameters) --------------------------------------------------------------------
./stack/mac/allocator/LteAllocationModule.h:    // --------- Map Iteration Methods --------->
./stack/mac/allocator/LteAllocatorUtils.h:    //----------------------------------------------------------------------
./stack/mac/allocator/LteAllocatorUtils.h:    //----------------------------------------------------------------------
./stack/mac/allocator/LteAllocatorUtils.h:    //----------------------------------------------------------------------
./stack/mac/allocator/LteAllocatorUtils.h:    //----------------------------------------------------------------------
./stack/mac/amc/AmcPilotAuto.cc:                Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, b);
./stack/mac/amc/AmcPilotAuto.cc:            EV << NOW <<" AmcPilotAuto::computeTxParams - no UsableBand available for this user." << endl;
./stack/mac/amc/AmcPilotAuto.cc:                Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, currBand);
./stack/mac/amc/AmcPilotAuto.cc:            EV << NOW <<" AmcPilotAuto::computeTxParams - UsableBand of size " << usableB->size() << " available for this user" << endl;
./stack/mac/amc/AmcPilotAuto.cc:                Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, b);
./stack/mac/amc/AmcPilotAuto.cc:            EV << NOW <<" AmcPilotAuto::computeTxParams - no UsableBand available for this user." << endl;
./stack/mac/amc/AmcPilotAuto.cc:                Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, currBand);
./stack/mac/amc/AmcPilotAuto.cc:            EV << NOW <<" AmcPilotAuto::computeTxParams - UsableBand of size " << usableB->size() << " available for this user" << endl;
./stack/mac/amc/AmcPilotAuto.cc:        EV << "AmcPilotAuto::computeTxParams - computing ROBUST CQI" << endl;
./stack/mac/amc/AmcPilotAuto.cc:                Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, b);
./stack/mac/amc/AmcPilotAuto.cc:        chosenCqi = getBinder()->meanCqi(sfb.getCqi(0),id,dir);
./stack/mac/amc/AmcPilotAuto.cc:            Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, i);
./stack/mac/amc/AmcPilotAuto.cc:        chosenCqi = getBinder()->medianCqi(sfb.getCqi(0),id,dir);
./stack/mac/amc/AmcPilotAuto.cc:            Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, i);
./stack/mac/amc/AmcPilotAuto.cc:    EV << NOW << " AmcPilot" << getName() << "::computeTxParams NEW values assigned! - CQI =" << chosenCqi << "\n";
./stack/mac/amc/AmcPilotAuto.cc:    EV << NOW << " AmcPilotAuto::setUsableBands - setting Usable bands: for node " << id<< " [" ;
./stack/mac/amc/AmcPilotAuto.cc:    EV << NOW << " AmcPilotAuto::getUsableBands - getting Usable bands for node " << id;
./stack/mac/amc/AmcPilotAuto.cc:            MacNodeId cellId = getBinder()->getNextHop(id);
./stack/mac/amc/AmcPilotD2D.cc:    preconfiguredTxParams_->writePmi(intuniform(getEnvir()->getRNG(0),1, pow(ri, (double) 2)));   // taken from LteFeedbackComputationRealistic::computeFeedback
./stack/mac/amc/AmcPilotD2D.cc:        throw cRuntimeError("AmcPilotD2D::setPreconfiguredTxParams - CQI %hu is not a valid value. Aborting", cqi);
./stack/mac/amc/AmcPilotD2D.cc:    for ( ; i < getBinder()->getTotalBands(); ++i)
./stack/mac/amc/AmcPilotD2D.cc:        chosenCqi = getBinder()->meanCqi(sfb.getCqi(0),id,dir);
./stack/mac/amc/AmcPilotD2D.cc:            Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, i);
./stack/mac/amc/AmcPilotD2D.cc:        Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, band);
./stack/mac/amc/AmcPilotD2D.cc://        Band cellWiseBand = amc_->getCellInfo()->getCellwiseBand(carrierFrequency, band);
./stack/mac/amc/AmcPilotD2D.cc:    EV << NOW << " AmcPilot" << getName() << "::computeTxParams NEW values assigned! - CQI =" << chosenCqi << "\n";
./stack/mac/amc/LteAmc.cc:    EV << NOW << " LteAmc::computeTxParams --------------::[ START ]::--------------\n";
./stack/mac/amc/LteAmc.cc:    EV << NOW << " LteAmc::computeTxParams - - - - - - - - - - - - - - - - - - - - -\n";
./stack/mac/amc/LteAmc.cc:    EV << NOW << " LteAmc::computeTxParams - - - - - - - - - - - - - - - - - - - - -\n";
./stack/mac/amc/LteAmc.cc:    EV << NOW << " LteAmc::computeTxParams --------------::[  END  ]::--------------\n";
./stack/mac/amc/LteAmc.cc:            EV << NOW << " LteAmc::blocks2bits - CQI equal to zero on cw " << cw << ", return no blocks available" << endl;
./stack/mac/amc/LteAmc.cc:        EV << NOW << " LteAmc::blocks2bits ---::[ Codeword = " << cw << "\n";
./stack/mac/amc/LteAmc.cc:        EV << NOW << " LteAmc::blocks2bits - CQI equal to zero, return no blocks available" << endl;
./stack/mac/amc/LteAmc.cc:    const unsigned int* tbsVect = itbs2tbs(mod, info.readTxMode(), layers, iTbs - i);
./stack/mac/amc/LteAmc.cc:    return tbsVect[blocks - 1];
./stack/mac/amc/LteAmc.cc:        EV << NOW << " LteAmc::computeBitsOnNRbs_MB - CQI equal to zero, return no blocks available" << endl;
./stack/mac/amc/LteAmc.cc:    const unsigned int* tbsVect = itbs2tbs(mod, TRANSMIT_DIVERSITY, layers[0], iTbs - i);
./stack/mac/amc/LteAmc.cc:    return tbsVect[blocks - 1];
./stack/mac/amc/LteAmc.cc:        EV << NOW << " LteAmc::computeBitsPerRbBackground - CQI equal to zero, return no bytes available" << endl;
./stack/mac/amc/LteAmc.cc:    EV << NOW << " LteAmc::computeBitsPerRbBackground Modulation: " << modToA(mod) << " - iTbs: " << iTbs << " i: " << i << endl;
./stack/mac/amc/LteAmc.cc:    const unsigned int* tbsVect = itbs2tbs(mod, TRANSMIT_DIVERSITY, layers, iTbs - i);
./stack/mac/amc/LteAmc.cc:    return tbsVect[blocks - 1];
./stack/mac/amc/LteAmc.cc:    return (tbsVect[blocks - 1] / 8);
./stack/mac/amc/LteAmc.cc:                    tbsVect = itbs2tbs_16qam_1[itbs - 9];
./stack/mac/amc/LteAmc.cc:                    tbsVect = itbs2tbs_16qam_2[itbs - 9];
./stack/mac/amc/LteAmc.cc:                    tbsVect = itbs2tbs_16qam_4[itbs - 9];
./stack/mac/amc/LteAmc.cc:                    tbsVect = itbs2tbs_64qam_1[itbs - 15];
./stack/mac/amc/LteAmc.cc:                    tbsVect = itbs2tbs_64qam_2[itbs - 15];
./stack/mac/amc/LteAmc.cc:                    tbsVect = itbs2tbs_64qam_4[itbs - 15];
./stack/mac/amc/LteAmc.cc:    // - the cqi value which will be returned
./stack/mac/amc/LteAmc.cc:    // - a counter to obtain the mean
./stack/mac/amc/LteAmc.cc:    // - the mean value
./stack/mac/amc/LteAmc.cc:    // - the min value
./stack/mac/amc/LteAmc.cc:    // - the max value
./stack/mac/amc/LteAmc.cc:        EV << "LteAmc::getWbCqi - Cqi " << cqi.at(b) << " on band " << (int)b << endl;
./stack/mac/amc/LteAmc.cc:    EV << "LteAmc::getWbCqi - Cqi mean " << cqiMean << " minimum " << cqiMin << " maximum " << cqiMax << endl;
./stack/mac/amc/LteAmc.cc:        double ret = (cqiComputationWeight_ + 1.0) * ((double) cqiMean - (double) cqiMin);
./stack/mac/amc/LteAmc.cc:        cqiRet += ret - ((unsigned int) ret) > 0.5 ? (unsigned int) ret + 1 : (unsigned int) ret;
./stack/mac/amc/LteAmc.cc:        double ret = (cqiComputationWeight_) * ((double) cqiMax - (double) cqiMean);
./stack/mac/amc/LteAmc.cc:        cqiRet += ret - ((unsigned int) ret) > 0.5 ? (unsigned int) ret + 1 : (unsigned int) ret;
./stack/mac/amc/LteAmc.cc:    EV << "LteAmc::getWbCqi - Cqi " << cqiRet << " evaluated\n";
./stack/mac/amc/LteAmc.cc:    // - the pmi value which will be returned
./stack/mac/amc/LteAmc.cc:    // - a counter to obtain the mean
./stack/mac/amc/LteAmc.cc:    // - the mean value
./stack/mac/amc/LteAmc.cc:    // - the min value
./stack/mac/amc/LteAmc.cc:    // - the max value
./stack/mac/amc/LteAmc.cc:        double ret = (pmiComputationWeight_ + 1.0) * ((double) pmiMean - (double) pmiMin);
./stack/mac/amc/LteAmc.cc:        pmiRet += ret - ((unsigned int) ret) > 0.5 ? (unsigned int) ret + 1 : (unsigned int) ret;
./stack/mac/amc/LteAmc.cc:        double ret = (pmiComputationWeight_) * ((double) pmiMax - (double) pmiMean);
./stack/mac/amc/LteAmc.cc:        pmiRet += ret - ((unsigned int) ret) > 0.5 ? (unsigned int) ret + 1 : (unsigned int) ret;
./stack/mac/amc/LteAmc.cc:    EV << "LteAmc::getWbPmi - Pmi " << pmiRet << " evaluated\n";
./stack/mac/amc/LteAmc.cc:        EV << "UserTxParams - carrier[" << cit->first << "]" << endl;
./stack/mac/amc/LteAmc.h:    // utilities - do not involve pilot invocation
./stack/mac/amc/LteAmc.h:    // ---------------------------
./stack/mac/amc/NRAmc.cc:    return (numSubcarriers * symbolsPerSlot) - reSignal - nOverhead;
./stack/mac/amc/NRAmc.cc:        n = std::max((int)3, (int)(floor(log2(nInfo) - 6)));
./stack/mac/amc/NRAmc.cc:        n = floor( log2(nInfo - 24) - 5);
./stack/mac/amc/NRAmc.cc:        _nInfo = ( 1 << n ) * round( (nInfo - 24) / (1 << n));
./stack/mac/amc/NRAmc.cc:            tbs = 8 * C * ceil( (_nInfo+24) / (8*C) ) - 24;
./stack/mac/amc/NRAmc.cc:                tbs = 8 * C * ceil( (_nInfo+24) / (8*C) ) - 24;
./stack/mac/amc/NRAmc.cc:                tbs = 8 * ceil( (_nInfo+24) / 8 ) - 24;
./stack/mac/amc/NRAmc.cc:        default: throw cRuntimeError("NRAmc::computeCodewordTbs - unrecognized modulation.");
./stack/mac/amc/NRAmc.cc:            EV << NOW << " NRAmc::computeBitsOnNRbs - CQI equal to zero on cw " << cw << ", return no blocks available" << endl;
./stack/mac/amc/NRAmc.cc:        EV << NOW << " NRAmc::computeBitsOnNRbs - CQI equal to zero, return no blocks available" << endl;
./stack/mac/amc/NRAmc.cc:        EV << NOW << " NRAmc::computeBitsPerRbBackground - CQI equal to zero, return no bytes available" << endl;
./stack/mac/amc/NRAmc.cc:        default: throw cRuntimeError("NRAmc::computeCodewordTbs - unrecognized modulation.");
./stack/mac/amc/NRMcs.cc:        default: throw cRuntimeError("NRMcsTable::getMinIndex - modulation %d not supported", mod);
./stack/mac/amc/NRMcs.cc:        default: throw cRuntimeError("NRMcsTable::getMinIndex - modulation %d not supported", mod);
./stack/mac/amc/NRMcs.cc:        default: throw cRuntimeError("NRMcsTable::getMaxIndex - modulation %d not supported", mod);
./stack/mac/amc/NRMcs.cc:        default: throw cRuntimeError("NRMcsTable::getMaxIndex - modulation %d not supported", mod);
./stack/mac/amc/UserTxParams.cc:        EV << NOW << " " << s << " --------------------------\n";
./stack/mac/amc/UserTxParams.cc:        EV << NOW << " " << s << " --------------------------\n";
./stack/mac/amc/UserTxParams.cc:        EV << NOW << " " << s << " --------------------------\n";
./stack/mac/amc/UserTxParams.h:    //! Get the remote antenna set - DAS
./stack/mac/amc/UserTxParams.h:    //! Set the remote antenna set - DAS
./stack/mac/amc/UserTxParams.h:    /** Print debug information - FOR DEBUG ONLY
./stack/mac/buffer/harq/LteHarqBufferRx.cc:        macThroughput_ = getMacByMacNodeId(nodeId_)->registerSignal("macThroughputUl");
./stack/mac/buffer/harq/LteHarqBufferRx.cc:    processes_[acid]->insertPdu(cw, pkt);
./stack/mac/buffer/harq/LteHarqBufferRx.cc:            if (processes_[i]->isEvaluated(cw))
./stack/mac/buffer/harq/LteHarqBufferRx.cc:                auto pkt = processes_[i]->createFeedback(cw);
./stack/mac/buffer/harq/LteHarqBufferRx.cc:            if (processes_[i]->getUnitStatus(cw) == RXHARQ_PDU_CORRUPTED)
./stack/mac/buffer/harq/LteHarqBufferRx.cc:                EV << "LteHarqBufferRx::purgeCorruptedPdus - purged pdu with acid " << i << endl;
./stack/mac/buffer/harq/LteHarqBufferRx.cc:                processes_[i]->purgeCorruptedPdu(cw);
./stack/mac/buffer/harq/LteHarqBufferRx.cc:                processes_[i]->resetCodeword(cw);
./stack/mac/buffer/harq/LteHarqBufferRx.cc:            if (processes_[i]->isCorrect(cw))
./stack/mac/buffer/harq/LteHarqBufferRx.cc:                auto pktTemp = processes_[i]->extractPdu(cw);
./stack/mac/buffer/harq/LteHarqBufferRx.cc:                macUe_->emit(macDelay_, (NOW - pktTemp->getCreationTime()).dbl());
./stack/mac/buffer/harq/LteHarqBufferRx.cc:                double den = (NOW - getSimulation()->getWarmupPeriod()).dbl();
./stack/mac/buffer/harq/LteHarqBufferRx.cc:                EV << "LteHarqBufferRx::extractCorrectPdus H-ARQ RX: pdu (id " << ret.back()->getId()
./stack/mac/buffer/harq/LteHarqBufferRx.cc:        if (processes_[i]->isEmpty())
./stack/mac/buffer/harq/LteHarqBufferRx.cc:        ret.second = processes_[acid]->emptyUnitsIds();
./stack/mac/buffer/harq/LteHarqBufferRx.cc:    ret.second = processes_[acid]->emptyUnitsIds();
./stack/mac/buffer/harq/LteHarqBufferRx.cc:        numHarqUnits = (processes_)[i]->getNumHarqUnits();
./stack/mac/buffer/harq/LteHarqBufferRx.cc:        vus = (processes_)[i]->getProcessStatus();
./stack/mac/buffer/harq/LteHarqBufferRx.cc:        if((*it)->isHarqProcessActive()){
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        if ((*processes_)[i]->hasReadyUnits())
./stack/mac/buffer/harq/LteHarqBufferTx.cc:            currentTxTime = (*processes_)[i]->getOldestUnitTxTime();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        ret.second = (*processes_)[oldestProcessAcid]->readyUnitsIds();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    return (*processes_)[acid]->getPduLength(cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        auto pkt = (*processes_)[acid]->getPdu(cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:            auto pkt2 = (*processes_)[acid]->getPdu(cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:            (*processes_)[acid]->dropPdu(cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        (*processes_)[acid]->markSelected(cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:            (*processes_)[acid]->markSelected(*it);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        if (!(*processes_)[acid]->isEmpty())
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    if (!(*processes_)[acid]->isUnitEmpty(cw))
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    numEmptyProc_--;
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    (*processes_)[acid]->insertPdu(pkt, cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:            if ((*processes_)[i]->isEmpty())
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        ret.second = (*processes_)[acid]->emptyUnitsIds();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    ret.second = (*processes_)[acid]->emptyUnitsIds();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    EV << "LteHarqBufferTx::receiveHarqFeedback - start" << endl;
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    long unitPduId = (*processes_)[acid]->getPduId(cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    if ((*processes_)[acid]->isDropped())
./stack/mac/buffer/harq/LteHarqBufferTx.cc:     * (*processes_)[acid]->pduFeedback(harqResult, cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        auto macPdu = (*processes_)[acid]->getPdu(cw)->peekAtFront<LteMacPdu>();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    bool reset = (*processes_)[acid]->pduFeedback(harqResult, cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        EV << "LteHarqBufferTx::sendSelectedDown - no process selected in H-ARQ buffer, nothing to do" << endl;
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    CwList ul = (*processes_)[selectedAcid_]->selectedUnitsIds();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        auto pkt = (*processes_)[selectedAcid_]->extractPdu(*it);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    CwList ul = (*processes_)[acid]->readyUnitsIds();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        (*processes_)[acid]->dropPdu(*it);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    CwList ul = (*processes_)[acid]->readyUnitsIds();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        reset = (*processes_)[acid]->selfNack(*it);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    (*processes_)[acid]->forceDropProcess();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:    bool reset = (*processes_)[acid]->forceDropUnit(cw);
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        numHarqUnits = (*processes_)[i]->getNumHarqUnits();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        vus = (*processes_)[i]->getProcessStatus();
./stack/mac/buffer/harq/LteHarqBufferTx.cc:        if((*it)->isHarqProcessActive()){
./stack/mac/buffer/harq/LteHarqProcessRx.cc:    EV << "LteHarqProcessRx::insertPdu - ndi is " << ndi << endl;
./stack/mac/buffer/harq/LteHarqProcessRx.cc:        throw cRuntimeError("New data arriving in busy harq process -- this should not happen");
./stack/mac/buffer/harq/LteHarqProcessRx.cc:        auto lteInfo = pdu_[cw]->getTag<UserControlInfo>();
./stack/mac/buffer/harq/LteHarqProcessRx.cc:        if ( (NOW - rxTime_.at(cw)) >= slotDuration * (harqFbEvaluationTimer_-1))
./stack/mac/buffer/harq/LteHarqProcessRx.cc:    auto pduInfo = pdu_.at(cw)->getTag<UserControlInfo>();
./stack/mac/buffer/harq/LteHarqProcessRx.cc:    auto pdu = pdu_.at(cw)->peekAtFront<LteMacPdu>();
./stack/mac/buffer/harq/LteHarqProcessRx.cc:    pkt->addTagIfAbsent<UserControlInfo>()->setSourceId(pduInfo->getDestId());
./stack/mac/buffer/harq/LteHarqProcessRx.cc:    pkt->addTagIfAbsent<UserControlInfo>()->setDestId(pduInfo->getSourceId());
./stack/mac/buffer/harq/LteHarqProcessRx.cc:    pkt->addTagIfAbsent<UserControlInfo>()->setFrameType(HARQPKT);
./stack/mac/buffer/harq/LteHarqProcessRx.cc:    pkt->addTagIfAbsent<UserControlInfo>()->setDirection(pduInfo->getDirection());
./stack/mac/buffer/harq/LteHarqProcessRx.cc:    pkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(pduInfo->getCarrierFrequency());
./stack/mac/buffer/harq/LteHarqProcessRx.cc:        EV << "LteHarqProcessRx::createFeedback - tx number " << (unsigned int)transmissions_ << endl;
./stack/mac/buffer/harq/LteHarqProcessRx.cc:            EV << NOW << " LteHarqProcessRx::createFeedback - max number of tx reached for cw " << cw << ". Resetting cw" << endl;
./stack/mac/buffer/harq/LteHarqProcessRx.cc:                check_and_cast<LteMacEnb*>(macOwner_)->signalProcessForRtx(pduInfo->getSourceId(), pduInfo->getCarrierFrequency(), (Direction)pduInfo->getDirection());
./stack/mac/buffer/harq/LteHarqProcessRx.cc:        return pdu_.at(cw)->getByteLength();
./stack/mac/buffer/harq/LteHarqProcessRx.cc:            if (pdu_.at(i)->getOwner() == mac)
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    numEmptyUnits_ = numUnits; //++ @ insert, -- @ unit reset (ack or fourth nack)
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    numSelected_ = 0; //++ @ markSelected and insert, -- @ extract/sendDown
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    numEmptyUnits_--;
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    (*units_)[cw]->insertPdu(pkt);
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    (*units_)[cw]->markSelected();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    numSelected_--;
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    auto  pdu = (*units_)[cw]->extractPdu();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    bool reset = (*units_)[cw]->pduFeedback(fb);
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    bool reset = (*units_)[cw]->selfNack();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:        if ((*units_)[i]->isReady())
./stack/mac/buffer/harq/LteHarqProcessTx.cc:        if ((*units_)[i]->isReady())
./stack/mac/buffer/harq/LteHarqProcessTx.cc:            curTxTime = (*units_)[i]->getTxTime();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:        if ((*units_)[i]->isReady())
./stack/mac/buffer/harq/LteHarqProcessTx.cc:        if ((*units_)[i]->isEmpty())
./stack/mac/buffer/harq/LteHarqProcessTx.cc:        if ((*units_)[i]->isMarked())
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    auto temp = (*units_)[cw]->getPdu()->peekAtFront<LteMacPdu>();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->getPdu();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->getMacPduId();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:        (*units_)[i]->forceDropUnit();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    if ((*units_)[cw]->isMarked())
./stack/mac/buffer/harq/LteHarqProcessTx.cc:        numSelected_--;
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    (*units_)[cw]->forceDropUnit();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->getStatus();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    (*units_)[cw]->dropPdu();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->isEmpty();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->isReady();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->getTransmissions();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->getPduLength();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->getTxTime();
./stack/mac/buffer/harq/LteHarqProcessTx.cc:    return (*units_)[cw]->isMarked();
./stack/mac/buffer/harq/LteHarqUnitTx.cc:    EV << "LteHarqUnitTx::extractPdu - ndi set to " << ((transmissions_ == 1) ? "true" : "false") << endl;
./stack/mac/buffer/harq/LteHarqUnitTx.cc:    EV << "LteHarqUnitTx::pduFeedback - Welcome!" << endl;
./stack/mac/buffer/harq/LteHarqUnitTx.cc:                check_and_cast<LteMacEnb*>(macOwner_)->signalProcessForRtx(lteInfo->getDestId(), lteInfo->getCarrierFrequency(), (Direction)lteInfo->getDirection());
./stack/mac/buffer/harq_d2d/LteHarqBufferMirrorD2D.cc:    EV << "LteHarqBufferMirrorD2D::receiveHarqFeedback - start" << endl;
./stack/mac/buffer/harq_d2d/LteHarqBufferMirrorD2D.cc:    double carrierFrequency = pkt->getTag<UserControlInfo>()->getCarrierFrequency();
./stack/mac/buffer/harq_d2d/LteHarqBufferMirrorD2D.cc:    processes_[acid]->storeFeedback(harqResult, pduLength, d2dSenderId, carrierFrequency, cw);
./stack/mac/buffer/harq_d2d/LteHarqBufferMirrorD2D.cc:        std::vector<TxHarqPduStatus> status = processes_[i]->getProcessStatus();
./stack/mac/buffer/harq_d2d/LteHarqBufferMirrorD2D.cc:                processes_[i]->markWaiting(cw);
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:        macThroughput_ = getMacByMacNodeId(nodeId_)->registerSignal("macThroughputUl");
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:            macThroughputD2D_ = check_and_cast<LteMacUeD2D*>(macOwner_)->registerSignal("macThroughputD2D");
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:            macDelayD2D_ = check_and_cast<LteMacUeD2D*>(macOwner_)->registerSignal("macDelayD2D");
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:            macCellThroughputD2D_ = check_and_cast<LteMacEnbD2D*>(nodeB_)->registerSignal("macCellThroughputD2D");
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:    processes_[acid]->insertPdu(cw, pkt);
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:            if (processes_[i]->isEvaluated(cw))
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                auto pkt = check_and_cast<LteHarqProcessRxD2D*>(processes_[i])->createFeedbackMirror(cw);
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                    EV<<NOW<<"LteHarqBufferRxD2D::sendFeedback - cw "<< cw << " of process " << i
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                auto pktHbf = (processes_[i])->createFeedback(cw);
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                    EV<<NOW<<"LteHarqBufferRxD2D::sendFeedback - cw "<< cw << " of process " << i
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                   << cInfo ->getDestId()
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:            if (processes_[i]->isCorrect(cw))
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                auto temp = processes_[i]->extractPdu(cw);
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                    check_and_cast<LteMacUeD2D*>(macOwner_)->emit(macDelayD2D_, (NOW - temp->getCreationTime()).dbl());
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                    macUe_emit(macDelay_, (NOW - temp->getCreationTime()).dbl());
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                double den = (NOW - getSimulation()->getWarmupPeriod()).dbl();
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                        check_and_cast<LteMacEnbD2D*>(nodeB_)->emit(macCellThroughputD2D_, cellTputSample);
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                        check_and_cast<LteMacUeD2D*>(macOwner_)->emit(macThroughputD2D_, tputSample);
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                        macUe_emit(macDelay_, (NOW - temp->getCreationTime()).dbl());
./stack/mac/buffer/harq_d2d/LteHarqBufferRxD2D.cc:                EV << "LteHarqBufferRxD2D::extractCorrectPdus H-ARQ RX: pdu (id " << ret.back()->getId()
./stack/mac/buffer/harq_d2d/LteHarqBufferTxD2D.cc:    EV << "LteHarqBufferTxD2D::receiveHarqFeedback - start" << endl;
./stack/mac/buffer/harq_d2d/LteHarqBufferTxD2D.cc:    long unitPduId = (*processes_)[acid]->getPduId(cw);
./stack/mac/buffer/harq_d2d/LteHarqBufferTxD2D.cc:    if ((*processes_)[acid]->isDropped())
./stack/mac/buffer/harq_d2d/LteHarqBufferTxD2D.cc:    bool reset = (*processes_)[acid]->pduFeedback(harqResult, cw);
./stack/mac/buffer/harq_d2d/LteHarqProcessMirrorD2D.cc:            omnetpp::check_and_cast<LteMacEnb*>(macOwner_)->signalProcessForRtx(d2dSenderId, carrierFrequency, D2D);
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:    auto pduInfo = (pdu_.at(cw)->getTag<UserControlInfo>());
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:    auto pdu = pdu_.at(cw)->peekAtFront<LteMacPdu>();
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setSourceId(pduInfo->getDestId());
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setDestId(pduInfo->getSourceId());
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setFrameType(HARQPKT);
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setDirection(pduInfo->getDirection());
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(pduInfo->getCarrierFrequency());
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:            EV << NOW << " LteHarqProcessRxD2D::createFeedback - pdu for cw " << cw << " belonged to a multicast/broadcast connection. Resetting cw " << endl;
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:            EV << "LteHarqProcessRx::createFeedback - tx number " << (unsigned int)transmissions_ << endl;
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:                EV << NOW << " LteHarqProcessRxD2D::createFeedback - max number of tx reached for cw " << cw << ". Resetting cw" << endl;
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:                    check_and_cast<LteMacEnb*>(macOwner_)->signalProcessForRtx(pduInfo->getSourceId(), pduInfo->getCarrierFrequency(), (Direction)pduInfo->getDirection());
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:    auto pduInfo = pdu_.at(cw)->getTag<UserControlInfo>();
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:    auto pdu = pdu_.at(cw)->peekAtFront<LteMacPdu>();
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setSourceId(pduInfo->getDestId());
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setDestId(macOwner_->getMacCellId());
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setFrameType(HARQPKT);
./stack/mac/buffer/harq_d2d/LteHarqProcessRxD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(pduInfo->getCarrierFrequency());
./stack/mac/buffer/harq_d2d/LteHarqProcessTxD2D.cc:    numEmptyUnits_ = numUnits; //++ @ insert, -- @ unit reset (ack or fourth nack)
./stack/mac/buffer/harq_d2d/LteHarqProcessTxD2D.cc:    numSelected_ = 0; //++ @ markSelected and insert, -- @ extract/sendDown
./stack/mac/buffer/harq_d2d/LteHarqProcessTxD2D.cc:    numSelected_--;
./stack/mac/buffer/harq_d2d/LteHarqProcessTxD2D.cc:    Packet *pkt = (*units_)[cw]->extractPdu();
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            macCellPacketLossD2D_ = check_and_cast<LteMacEnbD2D*>(nodeB_)->registerSignal("macCellPacketLossD2D");
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            macPacketLossD2D_ = check_and_cast<LteMacUeD2D*>(macOwner_)->registerSignal("macPacketLossD2D");
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            harqErrorRateD2D_ = check_and_cast<LteMacUeD2D*>(dstMac_)->registerSignal("harqErrorRateD2D");
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            harqErrorRateD2D_1_ = check_and_cast<LteMacUeD2D*>(dstMac_)->registerSignal("harqErrorRate_1st_D2D");
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            harqErrorRateD2D_2_ = check_and_cast<LteMacUeD2D*>(dstMac_)->registerSignal("harqErrorRate_2nd_D2D");
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            harqErrorRateD2D_3_ = check_and_cast<LteMacUeD2D*>(dstMac_)->registerSignal("harqErrorRate_3rd_D2D");
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            harqErrorRateD2D_4_ = check_and_cast<LteMacUeD2D*>(dstMac_)->registerSignal("harqErrorRate_4th_D2D");
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:    EV << "LteHarqUnitTxD2D::pduFeedback - Welcome!" << endl;
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            check_and_cast<LteMacUeD2D*>(ue)->emit(harqErrorRateD2D_1_, sample);
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            check_and_cast<LteMacUeD2D*>(ue)->emit(harqErrorRateD2D_2_, sample);
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            check_and_cast<LteMacUeD2D*>(ue)->emit(harqErrorRateD2D_3_, sample);
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            check_and_cast<LteMacUeD2D*>(ue)->emit(harqErrorRateD2D_4_, sample);
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:        check_and_cast<LteMacUeD2D*>(ue)->emit(harqErrorRateD2D_, sample);
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            check_and_cast<LteMacUeD2D*>(ue)->emit(macPacketLossD2D_, sample);
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:            check_and_cast<LteMacEnbD2D*>(nodeB_)->emit(macCellPacketLossD2D_, sample);
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:    EV << "LteHarqUnitTxD2D::extractPdu - ndi set to " << ((transmissions_ == 1) ? "true" : "false") << endl;
./stack/mac/buffer/harq_d2d/LteHarqUnitTxD2D.cc:        EV << NOW << " LteHarqUnitTxD2D::extractPdu - the extracted pdu belongs to a multicast/broadcast connection. "
./stack/mac/buffer/LteMacBuffer.cc:    queueLength_--;
./stack/mac/buffer/LteMacBuffer.cc:    queueOccupancy_ -= pkt.first;
./stack/mac/buffer/LteMacBuffer.cc:    queueLength_--;
./stack/mac/buffer/LteMacBuffer.cc:    queueOccupancy_ -= pkt.first;
./stack/mac/buffer/LteMacQueue.cc:    return getQueueLength() > 0 ? cPacketQueue::front()->getTimestamp() : 0;
./stack/mac/buffer/LteMacQueue.cc:        // unlimited queue size -- nothing to check for
./stack/mac/buffer/LteMacQueue.cc:            int remainingFrags = (pdu->getLastSn() - pdu->getSnoFragment() + 1);
./stack/mac/buffer/LteMacQueue.cc:                EV_DEBUG << "PDU would fit but discarded frags before - rejecting fragment: " << pdu->getSnoMainPacket() << ":" << pdu->getSnoFragment() << std::endl;
./stack/mac/buffer/LteMacQueue.cc:    // no fragments or unknown type -- can always be enqueued if there is enough space in the queue
./stack/mac/buffer/LteMacQueue.h: * - Packets
./stack/mac/buffer/LteMacQueue.h: * - Occupation (in bytes)
./stack/mac/buffer/LteMacQueue.h: * - Maximum size
./stack/mac/buffer/LteMacQueue.h: * - Number of packets
./stack/mac/buffer/LteMacQueue.h: * - Head Of Line Timestamp
./stack/mac/conflict_graph/ConflictGraph.cc:    EV << " ConflictGraph::computeConflictGraph - START "<<endl;
./stack/mac/conflict_graph/ConflictGraph.cc:    // --- remove the old one --- //
./stack/mac/conflict_graph/ConflictGraph.cc:    // --- find the vertices of the graph by scanning the peering map --- //
./stack/mac/conflict_graph/ConflictGraph.cc:    EV << " ConflictGraph::computeConflictGraph - " << vertices.size() << " vertices found" << endl;
./stack/mac/conflict_graph/ConflictGraph.cc:    // --- for each CGVertex, find the interfering vertices --- //
./stack/mac/conflict_graph/ConflictGraph.cc:    EV << " ConflictGraph::computeConflictGraph - END "<<endl;
./stack/mac/conflict_graph/ConflictGraph.cc:        EV << " ConflictGraph::printConflictGraph - No reuse enabled "<<endl;
./stack/mac/conflict_graph/ConflictGraph.cc:                EV << "|      -      ";
./stack/mac/conflict_graph/ConflictGraph.h:    // print Conflict Graph - for debug
./stack/mac/conflict_graph/DistanceBasedConflictGraph.cc:    phyEnb_ = check_and_cast<LtePhyBase*>(macEnb_->getParentModule()->getSubmodule("phy"));
./stack/mac/conflict_graph/DistanceBasedConflictGraph.cc:        throw cRuntimeError("DistanceBasedConflictGraph::getDbmFromDistance - channel model is a null pointer. Abort");
./stack/mac/conflict_graph/DistanceBasedConflictGraph.cc:            //  -> P2P-P2P
./stack/mac/conflict_graph/DistanceBasedConflictGraph.cc:            //  -> P2P-P2MP
./stack/mac/conflict_graph/DistanceBasedConflictGraph.cc:            //  -> P2MP-P2P
./stack/mac/conflict_graph/DistanceBasedConflictGraph.cc:            //  -> P2MP-P2MP
./stack/mac/layer/LteMacBase.cc:        queue->getQueueSize() - queue->getByteLength() << "\n";
./stack/mac/layer/LteMacBase.cc:            double sample = (double)totalOverflowedBytes_ / (NOW - getSimulation()->getWarmupPeriod());
./stack/mac/layer/LteMacBase.cc:            queue->getQueueSize() - queue->getByteLength() << "\n";
./stack/mac/layer/LteMacBase.cc:            throw cRuntimeError("LteMacBase::bufferizePacket - cannot find mac buffer for cid %d", cid);
./stack/mac/layer/LteMacBase.cc:    assert(mbuf_[cid]->getQueueLength() == macBuffers_[cid]->getQueueLength());
./stack/mac/layer/LteMacBase.cc:            it->second.current = it->second.max - 1;
./stack/mac/layer/LteMacBase.cc:            it->second.current--;
./stack/mac/layer/LteMacBase.cc:            if(getParentModule()->findSubmodule("nrPacketFlowManager") != -1)
./stack/mac/layer/LteMacBase.cc:                EV << "LteMacBase::initialize - MAC layer is NRMac, cast the packetFlowManager to NR" << endl;
./stack/mac/layer/LteMacBase.cc:                packetFlowManager_ = check_and_cast<PacketFlowManagerBase *>(getParentModule()->getSubmodule("nrPacketFlowManager"));
./stack/mac/layer/LteMacBase.cc:            if(getParentModule()->findSubmodule("packetFlowManager") != -1)
./stack/mac/layer/LteMacBase.cc:                EV << "LteMacBase::initialize - MAC layer, nodeType: "<< cnt  << endl;
./stack/mac/layer/LteMacBase.cc:                packetFlowManager_ = check_and_cast<PacketFlowManagerBase *>(getParentModule()->getSubmodule("packetFlowManager"));
./stack/mac/layer/LteMacBase.cc:    " from port " << pkt->getArrivalGate()->getName() << endl;
./stack/mac/layer/LteMacBase.cc:    throw cRuntimeError("LteMacBase::getHarqErrorRate - unhandled direction %d", dir);
./stack/mac/layer/LteMacBase.h:    ::omnetpp::cGate* up_[2];     /// RLC <--> MAC
./stack/mac/layer/LteMacBase.h:    ::omnetpp::cGate* down_[2];   /// MAC <--> PHY
./stack/mac/layer/LteMacBase.h:    /* LCG to CID and buffers map - used for supporting LCG - based scheduler operations
./stack/mac/layer/LteMacBase.h:    //* public utility function - drops ownership of an object
./stack/mac/layer/LteMacBase.h:    //* public utility function - takes ownership of an object
./stack/mac/layer/LteMacBase.h:     * Receives and handles scheduling grants - implemented in LteMacUe
./stack/mac/layer/LteMacEnb.cc:    return check_and_cast<CellInfo*>(getParentModule()-> // Stack
./stack/mac/layer/LteMacEnb.cc:    getParentModule()-> // Enb
./stack/mac/layer/LteMacEnb.cc:            throw cRuntimeError("LteMacEnb::initialize - Unknown Pilot Mode %s \n" , modeString.c_str());
./stack/mac/layer/LteMacEnb.cc:        info->eNodeB = this->getParentModule()->getParentModule();  // reference to the eNodeB module
./stack/mac/layer/LteMacEnb.cc:        cModule* module = getParentModule()->getParentModule();
./stack/mac/layer/LteMacEnb.cc:        const char* moduleName = getParentModule()->getParentModule()->getFullName();
./stack/mac/layer/LteMacEnb.cc:        phy_ = check_and_cast<LtePhyBase*>(getParentModule()->getSubmodule("phy"));
./stack/mac/layer/LteMacEnb.cc:            bgTrafficManager_[carrierFrequency] = check_and_cast<BackgroundTrafficManager*>(getParentModule()->getSubmodule("bgTrafficGenerator",i)->getSubmodule("manager"));
./stack/mac/layer/LteMacEnb.cc:            bgTrafficManager_[carrierFrequency]->setCarrierFrequency(carrierFrequency);
./stack/mac/layer/LteMacEnb.cc:            info.max = 1 << (cellInfo_->getMaxNumerologyIndex() - it->second.numerologyIndex); // 2^(maxNumerologyIndex - numerologyIndex)
./stack/mac/layer/LteMacEnb.cc:            info.current = info.max - 1;
./stack/mac/layer/LteMacEnb.cc:    EV << "----- START LteMacEnb::macSduRequest -----\n";
./stack/mac/layer/LteMacEnb.cc:            macSduRequest->setSduSize(allocatedBytes - MAC_HEADER);    // do not consider MAC header size
./stack/mac/layer/LteMacEnb.cc:                throw cRuntimeError("LteMacEnb::macSduRequest: configured queueSize too low - requested SDU will not fit in queue!"
./stack/mac/layer/LteMacEnb.cc:    EV << "------ END LteMacEnb::macSduRequest ------\n";
./stack/mac/layer/LteMacEnb.cc:               << " - now empty" << "\n";
./stack/mac/layer/LteMacEnb.cc:                otherCw = MAX_CODEWORDS - cw;
./stack/mac/layer/LteMacEnb.cc:                throw cRuntimeError("LteMacEnb::sendGrants - schedule list is empty.");
./stack/mac/layer/LteMacEnb.cc:            EV << NOW << " LteMacEnb::sendGrants Node[" << getMacNodeId() << "] - "
./stack/mac/layer/LteMacEnb.cc:            pkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/LteMacEnb.cc:            pkt->addTagIfAbsent<UserControlInfo>()->setDestId(nodeId);
./stack/mac/layer/LteMacEnb.cc:            pkt->addTagIfAbsent<UserControlInfo>()->setFrameType(GRANTPKT);
./stack/mac/layer/LteMacEnb.cc:            pkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(cit->first);
./stack/mac/layer/LteMacEnb.cc:            const UserTxParams& ui = getAmc()->computeTxParams(nodeId, UL,cit->first);
./stack/mac/layer/LteMacEnb.cc:                EV << NOW << " LteMacEnb::sendGrants - granting " << grantedBytes << " on cw " << cw << endl;
./stack/mac/layer/LteMacEnb.cc:    EV << "----- START LteMacEnb::macPduMake -----\n";
./stack/mac/layer/LteMacEnb.cc:            // (e.g. because the size of the MAC PDU would contain only MAC header - MAC SDU requested size = 0B)
./stack/mac/layer/LteMacEnb.cc:            if (mbuf_[destCid]->getQueueLength() == 0)
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setDestId(destId);
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setDirection(DL);
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(carrierFreq);
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setUserTxParams(txPara);
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setTxMode(txmode);
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setCw(cw);
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setGrantedBlocks(rbMap);
./stack/mac/layer/LteMacEnb.cc:                pkt->addTagIfAbsent<UserControlInfo>()->setTotalGrantedBlocks(grantedBlocks);
./stack/mac/layer/LteMacEnb.cc:                macPkt->addTagIfAbsent<CreationTimeTag>()->setCreationTime(NOW);
./stack/mac/layer/LteMacEnb.cc:                if ((mbuf_[destCid]->getQueueLength()) < (int) sduPerCid)
./stack/mac/layer/LteMacEnb.cc:                        destCid, mbuf_[destCid]->getQueueLength(), sduPerCid);
./stack/mac/layer/LteMacEnb.cc:                auto pkt = check_and_cast<Packet *>(mbuf_[destCid]->popFront());
./stack/mac/layer/LteMacEnb.cc:                sduPerCid--;
./stack/mac/layer/LteMacEnb.cc:    EV << "------ END LteMacEnb::macPduMake ------\n";
./stack/mac/layer/LteMacEnb.cc:                throw cRuntimeError("LteMacEnb::bufferizePacket - cannot find mac buffer for cid %d", cid);
./stack/mac/layer/LteMacEnb.cc:        return true; // this is only a new packet indication - only buffered in virtual queue
./stack/mac/layer/LteMacEnb.cc:        queue->getQueueSize() - queue->getByteLength() << "\n";
./stack/mac/layer/LteMacEnb.cc:            EV << "LteMacBuffers : queue" << cid << " is full - cannot buffer packet " << pkt->getId()<< "\n";
./stack/mac/layer/LteMacEnb.cc:            double sample = (double)totalOverflowedBytes_ / (NOW - getSimulation()->getWarmupPeriod());
./stack/mac/layer/LteMacEnb.cc:                unsigned int rlcSno = check_and_cast<LteRlcUmDataPdu *>(pkt)->getPduSequenceNumber();
./stack/mac/layer/LteMacEnb.cc:        queue->getQueueSize() - queue->getByteLength() << "\n";
./stack/mac/layer/LteMacEnb.cc:        // new data - inform scheduler of active connection
./stack/mac/layer/LteMacEnb.cc:    EV << "-----" << "ENB MAIN LOOP -----" << endl;
./stack/mac/layer/LteMacEnb.cc:    EV << "--- END ENB MAIN LOOP ---" << endl;
./stack/mac/layer/LteMacEnb.cc:            (dir == D2D) ? &needRtxD2D_ : throw cRuntimeError("LteMacEnb::signalProcessForRtx - direction %d not valid\n", dir);
./stack/mac/layer/LteMacEnb.cc:        (*needRtx)[carrierFrequency]--;
./stack/mac/layer/LteMacEnb.cc:            (dir == D2D) ? &needRtxD2D_ : throw cRuntimeError("LteMacEnb::getProcessForRtx - direction %d not valid\n", dir);
./stack/mac/layer/LteMacEnb.cc:        cModule *rlc = getParentModule()->getSubmodule("rlc");
./stack/mac/layer/LteMacEnb.cc:            rlcUm = check_and_cast<LteRlcUm *>(getParentModule()->getSubmodule("rlc")->getSubmodule("um"));
./stack/mac/layer/LteMacEnb.cc:        cModule *pdcp = getParentModule()->getSubmodule("pdcpRrc");
./stack/mac/layer/LteMacEnb.h:    /// List of scheduled users (one per carrier) - Downlink
./stack/mac/layer/LteMacEnb.h:    /// Lte Mac Scheduler - Downlink
./stack/mac/layer/LteMacEnb.h:    /// Lte Mac Scheduler - Uplink
./stack/mac/layer/LteMacEnb.h:            throw cRuntimeError("LteMacEnb::getBackgroundTrafficManager - carrier frequency [%f] not valid.", carrierFrequency);
./stack/mac/layer/LteMacEnb.h:    * - it has buffered data in MAC RLC or PDCP layers -> ActiveSet
./stack/mac/layer/LteMacEnb.h:    * - it has data for which HARQ transmission has not yet terminated -> !EMPTY HarqBuffer
./stack/mac/layer/LteMacEnbD2D.cc:        cModule* rlc = getParentModule()->getSubmodule("rlc");
./stack/mac/layer/LteMacEnbD2D.cc:            throw cRuntimeError("LteMacEnbD2D::initialize - %s module found, must be LteRlcUmD2D. Aborting", rlcUmType.c_str());
./stack/mac/layer/LteMacEnbD2D.cc:            check_and_cast<AmcPilotD2D*>(amc_->getPilot())->setPreconfiguredTxParams(d2dCqi);
./stack/mac/layer/LteMacEnbD2D.cc:                    check_and_cast<DistanceBasedConflictGraph*>(conflictGraph_)->setThresholds(par("conflictGraphD2DInterferenceRadius"), par("conflictGraphD2DMultiTxRadius"), par("conflictGraphD2DMultiInterferenceRadius"));
./stack/mac/layer/LteMacEnbD2D.cc:                default: { throw cRuntimeError("LteMacEnbD2D::initialize - CG type unknown. Aborting"); }
./stack/mac/layer/LteMacEnbD2D.cc:            Codeword otherCw = MAX_CODEWORDS - cw;
./stack/mac/layer/LteMacEnbD2D.cc:            EV << NOW << " LteMacEnbD2D::sendGrants Node[" << getMacNodeId() << "] - "
./stack/mac/layer/LteMacEnbD2D.cc:            pkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/LteMacEnbD2D.cc:            pkt->addTagIfAbsent<UserControlInfo>()->setDestId(nodeId);
./stack/mac/layer/LteMacEnbD2D.cc:            pkt->addTagIfAbsent<UserControlInfo>()->setFrameType(GRANTPKT);
./stack/mac/layer/LteMacEnbD2D.cc:            pkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(cit->first);
./stack/mac/layer/LteMacEnbD2D.cc:            const UserTxParams& ui = getAmc()->computeTxParams(nodeId, dir, cit->first);
./stack/mac/layer/LteMacEnbD2D.cc:                EV << NOW << " LteMacEnbD2D::sendGrants - granting " << grantedBytes << " on cw " << cw << endl;
./stack/mac/layer/LteMacEnbD2D.cc:    EV << NOW << "LteMacEnbD2D::clearBsrBuffers - Clear BSR buffers of UE " << ueId << endl;
./stack/mac/layer/LteMacEnbD2D.cc:        EV << NOW << "LteMacEnbD2D::clearBsrBuffers - Clear BSR buffer for cid " << cid << endl;
./stack/mac/layer/LteMacEnbD2D.cc:        EV << NOW << "LteMacEnbD2D::clearBsrBuffers - Length was " << buf->getQueueOccupancy() << endl;
./stack/mac/layer/LteMacEnbD2D.cc:        EV << NOW << "LteMacEnbD2D::clearBsrBuffers - New length is " << buf->getQueueOccupancy() << endl;
./stack/mac/layer/LteMacEnbD2D.cc:    EV << NOW << " LteMacEnbD2D::sendModeSwitchNotification - " << srcId << " --> " << dstId << " going from " << d2dModeToA(oldMode) << " to " << d2dModeToA(newMode) << endl;
./stack/mac/layer/LteMacEnbD2D.cc:    pktTx->addTagIfAbsent<UserControlInfo>()->setSourceId(nodeId_);
./stack/mac/layer/LteMacEnbD2D.cc:    pktTx->addTagIfAbsent<UserControlInfo>()->setDestId(srcId);
./stack/mac/layer/LteMacEnbD2D.cc:    pktTx->addTagIfAbsent<UserControlInfo>()->setFrameType(D2DMODESWITCHPKT);
./stack/mac/layer/LteMacEnbD2D.cc:    pktRx->addTagIfAbsent<UserControlInfo>()->setSourceId(nodeId_);
./stack/mac/layer/LteMacEnbD2D.cc:    pktRx->addTagIfAbsent<UserControlInfo>()->setDestId(dstId);
./stack/mac/layer/LteMacEnbD2D.cc:    pktRx->addTagIfAbsent<UserControlInfo>()->setFrameType(D2DMODESWITCHPKT);
./stack/mac/layer/LteMacEnbD2D.cc:                EV << NOW << " LteMacEnbD2D::sendModeSwitchNotification - send signal for TX entity to upper layers in the eNB (cid=" << cid << ")" << endl;
./stack/mac/layer/LteMacEnbD2D.cc:                                unsigned int numUnits = hit->second->getProcess(proc)->getNumHarqUnits();
./stack/mac/layer/LteMacEnbD2D.cc:                                    hit->second->getProcess(proc)->purgeCorruptedPdu(i); // delete contained PDU
./stack/mac/layer/LteMacEnbD2D.cc:                                    hit->second->getProcess(proc)->resetCodeword(i);     // reset unit
./stack/mac/layer/LteMacEnbD2D.cc:                EV << NOW << " LteMacEnbD2D::sendModeSwitchNotification - send signal for RX entity to upper layers in the eNB (cid=" << cid << ")" << endl;
./stack/mac/layer/LteMacEnbD2D.cc:        EV << NOW << "LteMacEnbD2D::fromPhy - node " << nodeId_ << " Received HARQ Feedback pkt (mirrored)" << endl;
./stack/mac/layer/LteMacUe.cc://        LteChannelModel* chanModel = check_and_cast<LteChannelModel*>(getParentModule()->getSubmodule("channelModel", 0));
./stack/mac/layer/LteMacUe.cc://            chanModel = check_and_cast<LteChannelModel*>(getParentModule()->getSubmodule("channelModel", 0));
./stack/mac/layer/LteMacUe.cc:        info->ue = this->getParentModule()->getParentModule();  // reference to the UE module
./stack/mac/layer/LteMacUe.cc:            info->phy = check_and_cast<LtePhyBase*>(getParentModule()->getSubmodule("nrPhy"));
./stack/mac/layer/LteMacUe.cc:            info->phy = check_and_cast<LtePhyBase*>(getParentModule()->getSubmodule("phy"));
./stack/mac/layer/LteMacUe.cc:            LteAmc *amc = check_and_cast<LteMacEnb *>(getMacByMacNodeId(cellId_))->getAmc();
./stack/mac/layer/LteMacUe.cc:                if(getParentModule()->getParentModule()->findSubmodule("NRueCollector") != -1)
./stack/mac/layer/LteMacUe.cc:                    UeStatsCollector *ue = check_and_cast<UeStatsCollector *> (getParentModule()->getParentModule()->getSubmodule("NRueCollector"));
./stack/mac/layer/LteMacUe.cc:                if(getParentModule()->getParentModule()->findSubmodule("ueCollector") != -1)
./stack/mac/layer/LteMacUe.cc:                    UeStatsCollector *ue = check_and_cast<UeStatsCollector *> (getParentModule()->getParentModule()->getSubmodule("ueCollector"));
./stack/mac/layer/LteMacUe.cc:            throw new cRuntimeError("no interface entry for lte interface - cannot bind node %i", nodeId_);
./stack/mac/layer/LteMacUe.cc:            throw new cRuntimeError("no Ipv4 interface data - cannot bind node %i", nodeId_);
./stack/mac/layer/LteMacUe.cc:                    info.max = 1 << (binder_->getUeMaxNumerologyIndex(nodeId_) - *it); // 2^(maxNumerologyIndex - numerologyIndex)
./stack/mac/layer/LteMacUe.cc:                    info.current = info.max - 1;
./stack/mac/layer/LteMacUe.cc:    EV << "----- START LteMacUe::macSduRequest -----\n";
./stack/mac/layer/LteMacUe.cc:            LteMacScheduleList* scheduledBytesList = lcgScheduler_[cit->first]->getScheduledBytesList();
./stack/mac/layer/LteMacUe.cc:                throw cRuntimeError("LteMacUe::macSduRequest - cannot find entry in scheduledBytesList");
./stack/mac/layer/LteMacUe.cc:                allocatedBytes[cw] -= bit->second;
./stack/mac/layer/LteMacUe.cc:                EV << NOW <<" LteMacUe::macSduRequest - cid[" << destCid << "] - sdu size[" << bit->second << "B] - " << allocatedBytes[cw] << " bytes left on codeword " << cw << endl;
./stack/mac/layer/LteMacUe.cc:    EV << "------ END LteMacUe::macSduRequest ------\n";
./stack/mac/layer/LteMacUe.cc:    if (pkt->getBitLength() <= 1) { // no data in this packet - should not be buffered
./stack/mac/layer/LteMacUe.cc:                throw cRuntimeError("LteMacUe::bufferizePacket - cannot find mac buffer for cid %d", cid);
./stack/mac/layer/LteMacUe.cc:        queue->getQueueSize() - queue->getByteLength() << "\n";
./stack/mac/layer/LteMacUe.cc:            double sample = (double)totalOverflowedBytes_ / (NOW - getSimulation()->getWarmupPeriod());
./stack/mac/layer/LteMacUe.cc:                unsigned int rlcSno = check_and_cast<LteRlcUmDataPdu *>(pkt)->getPduSequenceNumber();
./stack/mac/layer/LteMacUe.cc:        queue->getQueueSize() - queue->getByteLength() << "\n";
./stack/mac/layer/LteMacUe.cc:                macPkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/LteMacUe.cc:                macPkt->addTagIfAbsent<UserControlInfo>()->setDestId(destId);
./stack/mac/layer/LteMacUe.cc:                macPkt->addTagIfAbsent<UserControlInfo>()->setDirection(UL);
./stack/mac/layer/LteMacUe.cc:                macPkt->addTagIfAbsent<UserControlInfo>()->setUserTxParams(schedulingGrant_[carrierFreq]->getUserTxParams()->dup());
./stack/mac/layer/LteMacUe.cc:                macPkt->addTagIfAbsent<UserControlInfo>()->setGrantId(schedulingGrant_[carrierFreq]->getGrandId());
./stack/mac/layer/LteMacUe.cc:                macPkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(carrierFreq);
./stack/mac/layer/LteMacUe.cc:                if (mbuf_[destCid]->isEmpty())
./stack/mac/layer/LteMacUe.cc:                auto pkt = check_and_cast<Packet *>(mbuf_[destCid]->popFront());
./stack/mac/layer/LteMacUe.cc:                sduPerCid--;
./stack/mac/layer/LteMacUe.cc:            size += macBuffers_[destCid]->getQueueOccupancy();
./stack/mac/layer/LteMacUe.cc:            EV << "LteMacUe::macPduMake - [Used Acid=" << (unsigned int)txList.first << "] , [curr=" << (unsigned int)currentHarq_ << "]" << endl;
./stack/mac/layer/LteMacUe.cc:            //                    fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, sending a Long BSR...\n",NOW,nodeId);
./stack/mac/layer/LteMacUe.cc:            //                availableBytes -= LONG_BSR_SIZE;
./stack/mac/layer/LteMacUe.cc:            //                    fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, sending a Short/Truncated BSR...\n",NOW,nodeId);
./stack/mac/layer/LteMacUe.cc:            //                availableBytes -= SHORT_BSR_SIZE;
./stack/mac/layer/LteMacUe.cc:            //                fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, creating uplink PDU.\n", NOW, nodeId);
./stack/mac/layer/LteMacUe.cc:                EV << "LteMacUe::macPduMake - BSR with size " << size << "created" << endl;
./stack/mac/layer/LteMacUe.cc:        requestedSdus_--;
./stack/mac/layer/LteMacUe.cc:            EV << NOW << " LteMacUe::handleMessage - incrementing counter for HARQ processes " << (unsigned int)currentHarq_ << " --> " << (currentHarq_+1)%harqProcesses_ << endl;
./stack/mac/layer/LteMacUe.cc:    EV << "----- UE MAIN LOOP -----" << endl;
./stack/mac/layer/LteMacUe.cc:    EV << NOW << "LteMacUe::handleSelfMessage " << nodeId_ << " - HARQ process " << (unsigned int)currentHarq_ << endl;
./stack/mac/layer/LteMacUe.cc:    // no grant available - if user has backlogged data, it will trigger scheduling request
./stack/mac/layer/LteMacUe.cc:                if(--expirationCounter_[carrierFreq] < 0)
./stack/mac/layer/LteMacUe.cc:                else if (--periodCounter_[carrierFreq]>0)
./stack/mac/layer/LteMacUe.cc:                    // this is periodic grant TTI - continue with frame sending
./stack/mac/layer/LteMacUe.cc:            currentHarq_ = UE_TX_HARQ_PROCESSES - 2;
./stack/mac/layer/LteMacUe.cc:                retx = currHarq->getProcess(currentHarq_)->hasReadyUnits();
./stack/mac/layer/LteMacUe.cc:                CwList cwListRetx = currHarq->getProcess(currentHarq_)->readyUnitsIds();
./stack/mac/layer/LteMacUe.cc:                    currHarq->markSelected(signal,schedulingGrant_[carrierFrequency]->getUserTxParams()->getLayers().size());
./stack/mac/layer/LteMacUe.cc:                EV << "\t cicloOuter " << cntOuter << " - bufferStatus.size=" << harqStatus.size() << endl;
./stack/mac/layer/LteMacUe.cc:                    EV << "\t\t cicloInner " << cntInner << " - jt->size=" << jt->size()
./stack/mac/layer/LteMacUe.cc:                       << " - statusCw(0/1)=" << jt->at(0).second << "/" << jt->at(1).second << endl;
./stack/mac/layer/LteMacUe.cc:    EV << "--- END UE MAIN LOOP ---" << endl;
./stack/mac/layer/LteMacUe.cc:    EV << NOW << " LteMacUe::macHandleGrant - UE [" << nodeId_ << "] - Grant received" << endl;
./stack/mac/layer/LteMacUe.cc:    EV << NOW << " LteMacUe::macHandleGrant - Direction: " << dirToA(grant->getDirection()) << " Carrier: " << carrierFrequency << endl;
./stack/mac/layer/LteMacUe.cc:        EV << "LteMacUe::macHandleRac - Ue " << nodeId_ << " won RAC" << endl;
./stack/mac/layer/LteMacUe.cc:        racBackoffTimer_--;
./stack/mac/layer/LteMacUe.cc:        raRespTimer_--;
./stack/mac/layer/LteMacUe.cc:        EV << NOW << " LteMacUe::checkRAC - waiting for previous RAC requests to complete (timer=" << raRespTimer_ << ")" << endl;
./stack/mac/layer/LteMacUe.cc:        bsrRtxTimer_--;
./stack/mac/layer/LteMacUe.cc:        EV << NOW << " LteMacUe::checkRAC - waiting for a grant, BSR rtx timer has not expired yet (timer=" << bsrRtxTimer_ << ")" << endl;
./stack/mac/layer/LteMacUe.cc:        EV << NOW << " LteMacUe::checkRAC - double RAC request" << endl;
./stack/mac/layer/LteMacUe.cc:        double carrierFrequency = phy_->getPrimaryChannelModel()->getCarrierFrequency();
./stack/mac/layer/LteMacUe.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(carrierFrequency);
./stack/mac/layer/LteMacUe.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/LteMacUe.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setDestId(getMacCellId());
./stack/mac/layer/LteMacUe.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setDirection(UL);
./stack/mac/layer/LteMacUe.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setFrameType(RACPKT);
./stack/mac/layer/LteMacUe.cc:    lteInfo->setUserTxParams(schedulingGrant_[carrierFrequency]->getUserTxParams()->dup());
./stack/mac/layer/LteMacUe.cc:    lteInfo->setTxMode(schedulingGrant_[carrierFrequency]->getUserTxParams()->readTxMode());
./stack/mac/layer/LteMacUe.cc:    int grantedBlocks = schedulingGrant_[carrierFrequency]->getTotalGrantedBlocks();
./stack/mac/layer/LteMacUe.cc:    lteInfo->setGrantedBlocks(schedulingGrant_[carrierFrequency]->getGrantedBlocks());
./stack/mac/layer/LteMacUe.h:    // configured grant - one each codeword
./stack/mac/layer/LteMacUe.h:    // perodic grant handling - one per carrier
./stack/mac/layer/LteMacUeD2D.cc:        std::string pdcpType = getParentModule()->par("LtePdcpRrcType").stdstringValue();
./stack/mac/layer/LteMacUeD2D.cc:        cModule* rlc = getParentModule()->getSubmodule("rlc");
./stack/mac/layer/LteMacUeD2D.cc:            throw cRuntimeError("LteMacUeD2D::initialize - %s module found, must be LteRlcUmD2D. Aborting", rlcUmType.c_str());
./stack/mac/layer/LteMacUeD2D.cc:            throw cRuntimeError("LteMacUeD2D::initialize - %s module found, must be LtePdcpRrcUeD2D or NRPdcpRrcUe. Aborting", pdcpType.c_str());
./stack/mac/layer/LteMacUeD2D.cc:            LteAmc *amc = check_and_cast<LteMacEnb *>(getSimulation()->getModule(binder_->getOmnetId(cellId_))->getSubmodule("cellularNic")->getSubmodule("mac"))->getAmc();
./stack/mac/layer/LteMacUeD2D.cc://                if(getParentModule()->getParentModule()->findSubmodule("NRueCollector") != -1)
./stack/mac/layer/LteMacUeD2D.cc://                    UeStatsCollector *ue = check_and_cast<UeStatsCollector *> (getParentModule()->getParentModule()->getSubmodule("NRueCollector"));
./stack/mac/layer/LteMacUeD2D.cc:    macPkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/LteMacUeD2D.cc:    macPkt->addTagIfAbsent<UserControlInfo>()->setDestId(getMacCellId());
./stack/mac/layer/LteMacUeD2D.cc:    macPkt->addTagIfAbsent<UserControlInfo>()->setDirection(UL);
./stack/mac/layer/LteMacUeD2D.cc:    EV << "LteMacUeD2D::makeBsr() - BSR with size " << size << "created" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                        info->setUserTxParams(git->second->getUserTxParams()->dup());
./stack/mac/layer/LteMacUeD2D.cc:                            throw cRuntimeError("NRMacUe::macPduMake - channel model is a null pointer. Abort.");
./stack/mac/layer/LteMacUeD2D.cc:                        EV << "LteMacUeD2D::macPduMake - BSR D2D created with size " << sizeBsr << "created" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/LteMacUeD2D.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setDestId(destId);
./stack/mac/layer/LteMacUeD2D.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setDirection(dir);
./stack/mac/layer/LteMacUeD2D.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setLcid(MacCidToLcid(SHORT_BSR));
./stack/mac/layer/LteMacUeD2D.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(carrierFreq);
./stack/mac/layer/LteMacUeD2D.cc:                        macPkt->addTagIfAbsent<UserControlInfo>()->setUserTxParams(preconfiguredTxParams_->dup());
./stack/mac/layer/LteMacUeD2D.cc:                        macPkt->addTagIfAbsent<UserControlInfo>()->setUserTxParams(schedulingGrant_[carrierFreq]->getUserTxParams()->dup());
./stack/mac/layer/LteMacUeD2D.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setGrantId(schedulingGrant_[carrierFreq]->getGrandId());
./stack/mac/layer/LteMacUeD2D.cc:                    if (mbuf_[destCid]->isEmpty())
./stack/mac/layer/LteMacUeD2D.cc:                    auto pkt = check_and_cast<Packet *>(mbuf_[destCid]->popFront());
./stack/mac/layer/LteMacUeD2D.cc:                            macPkt->getTagForUpdate<UserControlInfo>()->setMulticastGroupId(groupId);
./stack/mac/layer/LteMacUeD2D.cc:                        sduPerCid--;
./stack/mac/layer/LteMacUeD2D.cc:                        throw cRuntimeError("LteMacUeD2D::macPduMake - extracted SDU is NULL. Abort.");
./stack/mac/layer/LteMacUeD2D.cc:                size += macBuffers_[destCid]->getQueueOccupancy();
./stack/mac/layer/LteMacUeD2D.cc:            EV << "LteMacUeD2D::macPduMake - [Used Acid=" << (unsigned int)txList.first << "] , [curr=" << (unsigned int)currentHarq_ << "]" << endl;
./stack/mac/layer/LteMacUeD2D.cc:            //                    fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, sending a Long BSR...\n",NOW,nodeId);
./stack/mac/layer/LteMacUeD2D.cc:            //                availableBytes -= LONG_BSR_SIZE;
./stack/mac/layer/LteMacUeD2D.cc:            //                    fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, sending a Short/Truncated BSR...\n",NOW,nodeId);
./stack/mac/layer/LteMacUeD2D.cc:            //                availableBytes -= SHORT_BSR_SIZE;
./stack/mac/layer/LteMacUeD2D.cc:            //                fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, creating uplink PDU.\n", NOW, nodeId);
./stack/mac/layer/LteMacUeD2D.cc:                EV << "LteMacUeD2D::macPduMake - BSR created with size " << size << endl;
./stack/mac/layer/LteMacUeD2D.cc:            EV << "LteMacUeD2D::handleMessage - Received packet " << pkt->getName() <<
./stack/mac/layer/LteMacUeD2D.cc:            " from port " << pkt->getArrivalGate()->getName() << endl;
./stack/mac/layer/LteMacUeD2D.cc:    EV << NOW << " LteMacUeD2D::macHandleGrant - UE [" << nodeId_ << "] - Grant received " << endl;
./stack/mac/layer/LteMacUeD2D.cc:    EV << NOW << " LteMacUeD2D::macHandleGrant - Direction: " << dirToA(grant->getDirection()) << " Carrier: " << carrierFrequency << endl;
./stack/mac/layer/LteMacUeD2D.cc:        racBackoffTimer_--;
./stack/mac/layer/LteMacUeD2D.cc:        raRespTimer_--;
./stack/mac/layer/LteMacUeD2D.cc:        EV << NOW << " LteMacUeD2D::checkRAC - waiting for previous RAC requests to complete (timer=" << raRespTimer_ << ")" << endl;
./stack/mac/layer/LteMacUeD2D.cc:        bsrRtxTimer_--;
./stack/mac/layer/LteMacUeD2D.cc:        EV << NOW << " LteMacUe::checkRAC - waiting for a grant, BSR rtx timer has not expired yet (timer=" << bsrRtxTimer_ << ")" << endl;
./stack/mac/layer/LteMacUeD2D.cc:        EV << NOW << " LteMacUeD2D::checkRAC - double RAC request" << endl;
./stack/mac/layer/LteMacUeD2D.cc:        EV << NOW << " LteMacUeD2D::checkRAC - double RAC request" << endl;
./stack/mac/layer/LteMacUeD2D.cc:        double carrierFrequency = phy_->getPrimaryChannelModel()->getCarrierFrequency();
./stack/mac/layer/LteMacUeD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(carrierFrequency);
./stack/mac/layer/LteMacUeD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/LteMacUeD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setDestId(getMacCellId());
./stack/mac/layer/LteMacUeD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setDirection(UL);
./stack/mac/layer/LteMacUeD2D.cc:        pkt->addTagIfAbsent<UserControlInfo>()->setFrameType(RACPKT);
./stack/mac/layer/LteMacUeD2D.cc:        EV << "LteMacUeD2D::macHandleRac - Ue " << nodeId_ << " won RAC" << endl;
./stack/mac/layer/LteMacUeD2D.cc:    EV << "----- UE MAIN LOOP -----" << endl;
./stack/mac/layer/LteMacUeD2D.cc:    EV << NOW << " LteMacUeD2D::handleSelfMessage " << nodeId_ << " - HARQ process " << (unsigned int)currentHarq_ << endl;
./stack/mac/layer/LteMacUeD2D.cc:    // no grant available - if user has backlogged data, it will trigger scheduling request
./stack/mac/layer/LteMacUeD2D.cc:                if(--expirationCounter_[carrierFreq] < 0)
./stack/mac/layer/LteMacUeD2D.cc:                else if (--periodCounter_[carrierFreq]>0)
./stack/mac/layer/LteMacUeD2D.cc:                    // this is periodic grant TTI - continue with frame sending
./stack/mac/layer/LteMacUeD2D.cc:            currentHarq_ = UE_TX_HARQ_PROCESSES - 2;
./stack/mac/layer/LteMacUeD2D.cc:                bool ready = currHarq->getProcess(currentHarq_)->hasReadyUnits();
./stack/mac/layer/LteMacUeD2D.cc:                CwList cwListRetx = currHarq->getProcess(currentHarq_)->readyUnitsIds();
./stack/mac/layer/LteMacUeD2D.cc:                    auto info = currHarq->getProcess(currentHarq_)->getPdu(cw)->getTag<UserControlInfo>();
./stack/mac/layer/LteMacUeD2D.cc:                    if (info->getDirection() == schedulingGrant_[carrierFrequency]->getDirection())
./stack/mac/layer/LteMacUeD2D.cc:                    currHarq->markSelected(signal,schedulingGrant_[carrierFrequency]->getUserTxParams()->getLayers().size());
./stack/mac/layer/LteMacUeD2D.cc:                EV << "LteMacUeD2D::handleSelfMessage - running LCG scheduler for carrier [" << carrierFrequency << "]" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                EV << "LteMacUeD2D::handleSelfMessage - scheduled " << carrierScheduleList->size() << " connections on carrier " << carrierFrequency << endl;
./stack/mac/layer/LteMacUeD2D.cc:                EV << "\t cicloOuter " << cntOuter << " - bufferStatus.size=" << harqStatus.size() << endl;
./stack/mac/layer/LteMacUeD2D.cc:                    EV << "\t\t cicloInner " << cntInner << " - jt->size=" << jt->size()
./stack/mac/layer/LteMacUeD2D.cc:                       << " - statusCw(0/1)=" << jt->at(0).second << "/" << jt->at(1).second << endl;
./stack/mac/layer/LteMacUeD2D.cc:    EV << "--- END UE MAIN LOOP ---" << endl;
./stack/mac/layer/LteMacUeD2D.cc:        throw cRuntimeError("LteMacUeD2D::getPreconfiguredTxParams - CQI %hu is not a valid value. Aborting", cqi);
./stack/mac/layer/LteMacUeD2D.cc:        throw cRuntimeError("LteMacUeD2D::getPreconfiguredTxParams - cellInfo is a NULL pointer. Aborting");
./stack/mac/layer/LteMacUeD2D.cc:    EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - Start" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - found old connection with cid " << cid << ", erasing buffered data" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                        EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - erasing buffered data" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                        EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - interrupting H-ARQ processes" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                    EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - clearing LCG map" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - send switch signal to the RLC TX entity corresponding to the old mode, cid " << cid << endl;
./stack/mac/layer/LteMacUeD2D.cc:                EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - send switch signal to the RLC TX entity corresponding to the new mode, cid " << cid << endl;
./stack/mac/layer/LteMacUeD2D.cc:                EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - found old connection with cid " << cid << ", send signal to the RLC RX entity" << endl;
./stack/mac/layer/LteMacUeD2D.cc:                                    unsigned int numUnits = hit->second->getProcess(proc)->getNumHarqUnits();
./stack/mac/layer/LteMacUeD2D.cc:                                        hit->second->getProcess(proc)->purgeCorruptedPdu(i); // delete contained PDU
./stack/mac/layer/LteMacUeD2D.cc:                                        hit->second->getProcess(proc)->resetCodeword(i);     // reset unit
./stack/mac/layer/LteMacUeD2D.cc:                EV << NOW << " LteMacUeD2D::macHandleD2DModeSwitch - found new connection with cid " << cid << ", send signal to the RLC RX entity" << endl;
./stack/mac/layer/NRMacUe.cc:    EV << "----- UE MAIN LOOP -----" << endl;
./stack/mac/layer/NRMacUe.cc:    EV << NOW << "NRMacUe::handleSelfMessage " << nodeId_ << " - HARQ process " << (unsigned int)currentHarq_ << endl;
./stack/mac/layer/NRMacUe.cc:    // no grant available - if user has backlogged data, it will trigger scheduling request
./stack/mac/layer/NRMacUe.cc:                if(--expirationCounter_[carrierFreq] < 0)
./stack/mac/layer/NRMacUe.cc:                else if (--periodCounter_[carrierFreq]>0)
./stack/mac/layer/NRMacUe.cc:                    // this is periodic grant TTI - continue with frame sending
./stack/mac/layer/NRMacUe.cc:             currentHarq_ = UE_TX_HARQ_PROCESSES - 2;
./stack/mac/layer/NRMacUe.cc:                         auto info = currProc->getPdu(cw)->getTag<UserControlInfo>();
./stack/mac/layer/NRMacUe.cc:                         if (info->getDirection() == schedulingGrant_[carrierFrequency]->getDirection())
./stack/mac/layer/NRMacUe.cc:                         currHarq->markSelected(signal,schedulingGrant_[carrierFrequency]->getUserTxParams()->getLayers().size());
./stack/mac/layer/NRMacUe.cc:                EV << "NRMacUe::handleSelfMessage - running LCG scheduler for carrier [" << carrierFrequency << "]" << endl;
./stack/mac/layer/NRMacUe.cc:                EV << "NRMacUe::handleSelfMessage - scheduled " << carrierScheduleList->size() << " connections on carrier " << carrierFrequency << endl;
./stack/mac/layer/NRMacUe.cc:                EV << "\t cicloOuter " << cntOuter << " - bufferStatus.size=" << harqStatus.size() << endl;
./stack/mac/layer/NRMacUe.cc:                    EV << "\t\t cicloInner " << cntInner << " - jt->size=" << jt->size()
./stack/mac/layer/NRMacUe.cc:                       << " - statusCw(0/1)=" << jt->at(0).second << "/" << jt->at(1).second << endl;
./stack/mac/layer/NRMacUe.cc:        EV << NOW << " NRMacUe::handleSelfMessage - incrementing counter for HARQ processes " << (unsigned int)currentHarq_ << " --> " << (currentHarq_+1)%harqProcesses_ << endl;
./stack/mac/layer/NRMacUe.cc:    EV << "--- END UE MAIN LOOP ---" << endl;
./stack/mac/layer/NRMacUe.cc:    EV << "----- START NRMacUe::macSduRequest -----\n";
./stack/mac/layer/NRMacUe.cc:            LteMacScheduleList* scheduledBytesList = lcgScheduler_[cit->first]->getScheduledBytesList();
./stack/mac/layer/NRMacUe.cc:                throw cRuntimeError("NRMacUe::macSduRequest - cannot find entry in scheduledBytesList");
./stack/mac/layer/NRMacUe.cc:                allocatedBytes[cw] -= bit->second;
./stack/mac/layer/NRMacUe.cc:                EV << NOW <<" NRMacUe::macSduRequest - cid[" << destCid << "] - sdu size[" << bit->second << "B] - " << allocatedBytes[cw] << " bytes left on codeword " << cw << endl;
./stack/mac/layer/NRMacUe.cc:    EV << "------ END NRMacUe::macSduRequest ------\n";
./stack/mac/layer/NRMacUe.cc:                        info->setUserTxParams(git->second->getUserTxParams()->dup());
./stack/mac/layer/NRMacUe.cc:                            throw cRuntimeError("NRMacUe::macPduMake - channel model is a null pointer. Abort.");
./stack/mac/layer/NRMacUe.cc:                        EV << "NRMacUe::macPduMake - BSR D2D created with size " << sizeBsr << "created" << endl;
./stack/mac/layer/NRMacUe.cc:                    macPkt->addTagIfAbsent<CreationTimeTag>()->setCreationTime(NOW);
./stack/mac/layer/NRMacUe.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setSourceId(getMacNodeId());
./stack/mac/layer/NRMacUe.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setDestId(destId);
./stack/mac/layer/NRMacUe.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setDirection(dir);
./stack/mac/layer/NRMacUe.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setLcid(MacCidToLcid(SHORT_BSR));
./stack/mac/layer/NRMacUe.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setCarrierFrequency(carrierFreq);
./stack/mac/layer/NRMacUe.cc:                    macPkt->addTagIfAbsent<UserControlInfo>()->setGrantId(schedulingGrant_[carrierFreq]->getGrandId());
./stack/mac/layer/NRMacUe.cc:                        macPkt->addTagIfAbsent<UserControlInfo>()->setUserTxParams(preconfiguredTxParams_->dup());
./stack/mac/layer/NRMacUe.cc:                        macPkt->addTagIfAbsent<UserControlInfo>()->setUserTxParams(schedulingGrant_[carrierFreq]->getUserTxParams()->dup());
./stack/mac/layer/NRMacUe.cc:                    if (mbuf_[destCid]->isEmpty())
./stack/mac/layer/NRMacUe.cc:                    auto pkt = check_and_cast<Packet *>(mbuf_[destCid]->popFront());
./stack/mac/layer/NRMacUe.cc:                            macPkt->getTagForUpdate<UserControlInfo>()->setMulticastGroupId(groupId);
./stack/mac/layer/NRMacUe.cc:                        sduPerCid--;
./stack/mac/layer/NRMacUe.cc:                        throw cRuntimeError("NRMacUe::macPduMake - extracted SDU is NULL. Abort.");
./stack/mac/layer/NRMacUe.cc:                size += macBuffers_[destCid]->getQueueOccupancy();
./stack/mac/layer/NRMacUe.cc:            UnitList txList = (pit->second->getTag<UserControlInfo>()->getDirection() == D2D_MULTI) ? txBuf->getEmptyUnits(currentHarq_) : txBuf->firstAvailable();
./stack/mac/layer/NRMacUe.cc:            EV << "NRMacUe::macPduMake - [Used Acid=" << (unsigned int)txList.first << "]" << endl;
./stack/mac/layer/NRMacUe.cc:            //                    fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, sending a Long BSR...\n",NOW,nodeId);
./stack/mac/layer/NRMacUe.cc:            //                availableBytes -= LONG_BSR_SIZE;
./stack/mac/layer/NRMacUe.cc:            //                    fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, sending a Short/Truncated BSR...\n",NOW,nodeId);
./stack/mac/layer/NRMacUe.cc:            //                availableBytes -= SHORT_BSR_SIZE;
./stack/mac/layer/NRMacUe.cc:            //                fprintf(stderr, "%.9f LteSchedulerUeUl::schedule - Node %d, creating uplink PDU.\n", NOW, nodeId);
./stack/mac/layer/NRMacUe.cc:                EV << "NRMacUe::macPduMake - BSR created with size " << size << endl;
./stack/mac/LteMac.ned:        // number of eNodeBs - set to 0 if unknown
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteHarqFeedback' as cValue -- field index out of range?", field);
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteHarqFeedbackMirror' as cValue -- field index out of range?", field);
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteHarqFeedback_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu.h:      // the ControlInfo - iterate over all packets and restore ControlInfo if necessary
./stack/mac/packet/LteMacPdu.h:        macPduLength_ -= pkt->getByteLength();
./stack/mac/packet/LteMacPdu_m.cc:    // field sdu is abstract or custom -- please do packing in customized class
./stack/mac/packet/LteMacPdu_m.cc:    // field sdu is abstract or custom -- please do unpacking in customized class
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteMacPdu_Base' as cValue -- field index out of range?", field);
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MacControlElement' as cValue -- field index out of range?", field);
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MacBsr' as cValue -- field index out of range?", field);
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacPdu_m.h:    virtual inet::Packet& getSduForUpdate(size_t k) { handleChange();return const_cast<inet::Packet&>(const_cast<LteMacPdu_Base*>(this)->getSdu(k));}
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteMacSduRequest_Base' as cValue -- field index out of range?", field);
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteMacSduRequest_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteRac' as cValue -- field index out of range?", field);
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteRac_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:    // field grantedCwBytes is abstract or custom -- please do packing in customized class
./stack/mac/packet/LteSchedulingGrant_m.cc:    // field grantedCwBytes is abstract or custom -- please do unpacking in customized class
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteSchedulingGrant_Base' as cValue -- field index out of range?", field);
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/packet/LteSchedulingGrant_m.cc:        field -= base->getFieldCount();
./stack/mac/scheduler/LcgScheduler.cc:        EV << NOW << " LcgScheduler::schedule - Node  " << mac_->getMacNodeId() << ", Starting priority service for traffic class " << i << endl;
./stack/mac/scheduler/LcgScheduler.cc:        // -------------------------------------------------------------------------------------------------- //
./stack/mac/scheduler/LcgScheduler.cc:        // -------------------------------------------------------------------------------------------------- //
./stack/mac/scheduler/LcgScheduler.cc:                double bucket = elem->bucket_; // TODO parameters -> bucket ;
./stack/mac/scheduler/LcgScheduler.cc:                double maximumBucketSize = 10000.0; // TODO  parameters -> maxBurst;
./stack/mac/scheduler/LcgScheduler.cc:                EV << NOW << " LcgScheduler::schedule Bucket size: " << bucket << " bytes (max size " << maximumBucketSize << " bytes) - BEFORE SERVICE " << endl;
./stack/mac/scheduler/LcgScheduler.cc:                    simtime_t localTimeInterval = NOW - 0/* TODO desc->parameters_.startTime_ */;
./stack/mac/scheduler/LcgScheduler.cc:                EV << NOW << " LcgScheduler::schedule Bucket size: " << bucket << " bytes (max size " << maximumBucketSize << " bytes) - AFTER SERVICE " << endl;
./stack/mac/scheduler/LcgScheduler.cc:            EV << NOW << " LcgScheduler::schedule - Node " << mac_->getMacNodeId() << ", remaining grant: " << availableBytes << " bytes " << endl;
./stack/mac/scheduler/LcgScheduler.cc:            EV << NOW << " LcgScheduler::schedule - Node " << mac_->getMacNodeId() << " buffer Size: " << toServe << " bytes " << endl;
./stack/mac/scheduler/LcgScheduler.cc://    TODO                        desc->parameters_.bucket_ -= sduSize;
./stack/mac/scheduler/LcgScheduler.cc:                        alloc -= MAC_HEADER;
./stack/mac/scheduler/LcgScheduler.cc:                        alloc -= RLC_HEADER_UM;
./stack/mac/scheduler/LcgScheduler.cc:                        alloc -= RLC_HEADER_AM;
./stack/mac/scheduler/LcgScheduler.cc:                    availableBytes -= toServe;
./stack/mac/scheduler/LcgScheduler.cc:                    EV << NOW << " LcgScheduler::schedule - Node " << mac_->getMacNodeId() << ",  SDU of size " << elem->sentData_ << " selected for transmission" << endl;
./stack/mac/scheduler/LcgScheduler.cc:                    EV << NOW << " LcgScheduler::schedule - Node " << mac_->getMacNodeId() << ", remaining grant: " << availableBytes << " bytes" << endl;
./stack/mac/scheduler/LcgScheduler.cc:                    EV << NOW << " LcgScheduler::schedule - Node " << mac_->getMacNodeId() << " buffer Size: " << toServe << " bytes" << endl;
./stack/mac/scheduler/LcgScheduler.cc://    TODO                        desc->parameters_.bucket_ -= sduSize;
./stack/mac/scheduler/LcgScheduler.cc:                        alloc -= MAC_HEADER;
./stack/mac/scheduler/LcgScheduler.cc:                        alloc -= RLC_HEADER_UM;
./stack/mac/scheduler/LcgScheduler.cc:                        alloc -= RLC_HEADER_AM;
./stack/mac/scheduler/LcgScheduler.cc:                            newPktInfo.first = newPktInfo.first - alloc;
./stack/mac/scheduler/LcgScheduler.cc:                            alloc -= newPktInfo.first;
./stack/mac/scheduler/LcgScheduler.cc:                    toServe -= availableBytes;
./stack/mac/scheduler/LcgScheduler.cc:                    EV << NOW << " LcgScheduler::schedule - Node " << mac_->getMacNodeId() << ",  SDU of size " << elem->sentData_ << " selected for transmission" << endl;
./stack/mac/scheduler/LcgScheduler.cc:                    EV << NOW << " LcgScheduler::schedule - Node " << mac_->getMacNodeId() << ", remaining grant: " << availableBytes << " bytes" << endl;
./stack/mac/scheduler/LcgScheduler.cc:                    EV << NOW << " LcgScheduler::schedule - Node " << mac_->getMacNodeId() << " buffer Size: " << toServe << " bytes" << endl;
./stack/mac/scheduler/LcgScheduler.cc://                        fprintf(stderr,"%.9f LcgScheduler::schedule - Node %d, this flow priority: %u (old lowest priority %u) - LOWEST FOR NOW\n", NOW, nodeId_, desc->parameters_.priority_, lowestBackloggedPriority_);
./stack/mac/scheduler/LcgScheduler.cc://                        fprintf(stderr,"%.9f LcgScheduler::schedule - Node %d, this flow priority: %u (old highest priority %u) - HIGHEST FOR NOW\n", NOW, nodeId_, desc->parameters_.priority_, highestBackloggedPriority_);
./stack/mac/scheduler/LcgScheduler.cc:                EV << "LcgScheduler::schedule - Node" << mac_->getMacNodeId() << ", Starting best effort service" << endl;
./stack/mac/scheduler/LcgScheduler.h:    // schedule List - returned by reference on scheduler invocation
./stack/mac/scheduler/LteScheduler.cc:    bandLimit_ = mac_->getCellInfo()->getCarrierBandLimit(carrierFrequency_);
./stack/mac/scheduler/LteScheduler.cc://    EV << "LteScheduler::initializeBandLimit - Set Band Limit for this carrier: " << endl;
./stack/mac/scheduler/LteScheduler.cc://        EV << " - Band[" << it->band_ << "] limit[";
./stack/mac/scheduler/LteScheduler.cc:    // 2^(maxNumerologyIndex - numerologyIndex)
./stack/mac/scheduler/LteScheduler.cc:    maxSchedulingPeriodCounter_ = 1 << (maxNumerologyIndex - numerologyIndex_);
./stack/mac/scheduler/LteScheduler.cc:    currentSchedulingPeriodCounter_ = maxSchedulingPeriodCounter_ - 1;
./stack/mac/scheduler/LteScheduler.cc:        currentSchedulingPeriodCounter_ = maxSchedulingPeriodCounter_ - 1;
./stack/mac/scheduler/LteScheduler.cc:        currentSchedulingPeriodCounter_--;
./stack/mac/scheduler/LteScheduler.cc://    EV << "LteScheduler::requestGrant - Set Band Limit for this carrier: " << endl;
./stack/mac/scheduler/LteScheduler.cc://        EV << " - Band[" << it->band_ << "] limit[";
./stack/mac/scheduler/LteScheduler.h:            return uniform(omnetpp::getEnvir()->getRNG(0),0,1) < 0.5;
./stack/mac/scheduler/LteScheduler.h:     *  - in the first phase, carried out by the prepareSchedule(),
./stack/mac/scheduler/LteScheduler.h:     *  - in the second phase, carried out by the storeSchedule(),
./stack/mac/scheduler/LteSchedulerEnb.cc:    const CarrierInfoMap* carriers = mac_->getCellInfo()->getCarrierInfoMap();
./stack/mac/scheduler/LteSchedulerEnb.cc:    const CarrierInfoMap* carriers = mac_->getCellInfo()->getCarrierInfoMap();
./stack/mac/scheduler/LteSchedulerEnb.cc:        (*it)->initializeSchedulerPeriodCounter(maxNumerologyIndex);
./stack/mac/scheduler/LteSchedulerEnb.cc:            EV << " LteSchedulerEnb::schedule - not my turn (counter=" << counter << ")"<< endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:    const UserTxParams& txParams = mac_->getAmc()->computeTxParams(nodeId, dir,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnb.cc:    EV << "LteSchedulerEnb::grant - deciding allowed Bands" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:            unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnb.cc:                    EV << "- Codeword " << j << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:        unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnb.cc:    EV << "LteSchedulerEnb::grant --------------------::[ START GRANT ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:        MacNodeId peer = mac_->getAmc()->computeMuMimoPairing(nodeId, dir);
./stack/mac/scheduler/LteSchedulerEnb.cc:            //1) register pairing  - if pairing is already registered false is returned
./stack/mac/scheduler/LteSchedulerEnb.cc:    // Retrieve the first free codeword checking the eligibility - check eligibility could modify current cw index.
./stack/mac/scheduler/LteSchedulerEnb.cc:        EV << "LteSchedulerEnb::grant --------------------::[  END GRANT  ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:        EV << "LteSchedulerEnb::scheduleGrant - scheduled connection is no more active . Exiting grant " << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:        EV << "LteSchedulerEnb::grant --------------------::[  END GRANT  ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:            EV << "LteSchedulerEnb::grant --- BAND " << b << " LIMIT " << limit << "---" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:                bandAvailableBytes = mac_->getAmc()->computeBytesOnNRbs(nodeId, b, cw, bandAvailableBlocks, dir,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnb.cc:            unsigned int uBlocks = mac_->getAmc()->computeReqRbs(nodeId, b, cw, uBytes, dir,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnb.cc:                (*bandLim).at(i).limit_.at(cw) -= uBlocks;
./stack/mac/scheduler/LteSchedulerEnb.cc:            toServe = (uBytes > toServe) ? 0 : toServe - uBytes;
./stack/mac/scheduler/LteSchedulerEnb.cc:        unsigned int consumedBytes = (cwAllocatedBytes == 0) ? 0 : cwAllocatedBytes - (MAC_HEADER + RLC_HEADER_UM);  // TODO RLC may be either UM or AM
./stack/mac/scheduler/LteSchedulerEnb.cc:                consumedBytes -= vPktSize;
./stack/mac/scheduler/LteSchedulerEnb.cc:                EV << "LteSchedulerEnb::grant - the first SDU/BSR is served entirely, remove it from the virtual buffer, remaining bytes to serve[" << consumedBytes << "]" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:                newPktInfo.first = newPktInfo.first - consumedBytes;
./stack/mac/scheduler/LteSchedulerEnb.cc:                EV << "LteSchedulerEnb::grant - the first SDU/BSR is partially served, update its size [" << newPktInfo.first << "]" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:    EV << "LteSchedulerEnb::grant --------------------::[  END GRANT  ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:    EV << "LteSchedulerEnb::grant - deciding allowed Bands" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:            unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnb.cc:    EV << "LteSchedulerEnb::scheduleGrantBackground --------------------::[ START GRANT ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:        EV << "LteSchedulerEnb::scheduleGrantBackground - scheduled connection is no more active . Exiting grant " << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:        EV << "LteSchedulerEnb::scheduleGrantBackground --------------------::[  END GRANT  ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:            EV << "LteSchedulerEnb::scheduleGrantBackground --- BAND " << b << " LIMIT " << limit << "---" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:                (*bandLim).at(i).limit_.at(cw) -= uBlocks;
./stack/mac/scheduler/LteSchedulerEnb.cc:            toServe = (uBytes > toServe) ? 0 : toServe - uBytes;
./stack/mac/scheduler/LteSchedulerEnb.cc:        unsigned int consumedBytes = (cwAllocatedBytes == 0) ? 0 : cwAllocatedBytes - (MAC_HEADER + RLC_HEADER_UM);  // TODO RLC may be either UM or AM
./stack/mac/scheduler/LteSchedulerEnb.cc:        if (consumedBytes <= (queueLength - (MAC_HEADER + RLC_HEADER_UM)) )
./stack/mac/scheduler/LteSchedulerEnb.cc:            toConsume = queueLength - (MAC_HEADER + RLC_HEADER_UM);
./stack/mac/scheduler/LteSchedulerEnb.cc:            LteChannelModel* channelModel = mac_->getPhy()->getChannelModel(carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnb.cc:    EV << "LteSchedulerEnb::grant --------------------::[  END GRANT  ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:    EV << "LteSchedulerEnb::backlog - backlogged data for Logical Cid " << cid << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:        (*it)->notifyActiveConnection(cid);
./stack/mac/scheduler/LteSchedulerEnb.cc:    Band startingBand = mac_->getCellInfo()->getCarrierStartingBand(carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnb.cc:    Band lastBand = mac_->getCellInfo()->getCarrierLastBand(carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnb.cc:    allocator_->init(resourceBlocks_, mac_->getCellInfo()->getNumBands());
./stack/mac/scheduler/LteSchedulerEnb.cc:    allocator_->reset(resourceBlocks_, mac_->getCellInfo()->getNumBands());
./stack/mac/scheduler/LteSchedulerEnb.cc:    unsigned int bytes = mac_->getAmc()->computeBytesOnNRbs(id, b, cw, blocks, dir,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnb.cc:        EV << "LteSchedulerEnb::availableBytes - No blocks available on band " << b << endl;
./stack/mac/scheduler/LteSchedulerEnb.cc:    unsigned int bytesPerBlock = mac_->getBackgroundTrafficManager(carrierFrequency)->getBackloggedUeBytesPerBlock(id, dir);
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    const UserTxParams& txParams = mac_->getAmc()->computeTxParams(nodeId, direction_,carrierFrequency);    // get the user info
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    // TODO SK Get the number of codewords - FIX with correct mapping
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    EV << NOW << "LteSchedulerEnbDl::rtxAcid - Node [" << mac_->getMacNodeId() << "], User[" << nodeId << "],  Codeword [" << cw << "]  of [" << codewords << "] , ACID [" << (int)acid << "] " << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        MacNodeId peer = mac_->getAmc()->computeMuMimoPairing(nodeId);
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            //1) register pairing  - if pairing is already registered false is returned
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        throw cRuntimeError("LteSchedulerEnbDl::schedulePerAcidRtx - HARQ Buffer not found for carrier %f", carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    std::vector<UnitStatus> pStatus = currHarq->getProcess(acid)->getProcessStatus();
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        EV << "LteSchedulerEnbDl::schedulePerAcidRtx --- BAND " << b << " LIMIT " << limit << "---" << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            EV << "LteSchedulerEnbDl::schedulePerAcidRtx - skipping logical band according to limit value" << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            available = mac_->getAmc()->computeBytesOnNRbs(nodeId, b, remappedCw, b1, direction_,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        EV << NOW << "LteSchedulerEnbDl::rtxAcid ----- BAND " << b << "-----" << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            bytes -= available;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            unsigned int blocks = mac_->getAmc()->computeReqRbs(nodeId, b, remappedCw, allocation, direction_,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        --codewords;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        EV << NOW << "LteSchedulerEnbDl::scheduleBgRtx - Node[" << mac_->getMacNodeId() << ", User[" << bgUeId << "]" << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:                // signal end loop - all data have been serviced
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            toServe -= servedBytes;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            // process couldn't be served - no sufficient space on available bands
./stack/mac/scheduler/LteSchedulerEnbDl.cc:                    EV << NOW << " LteSchedulerEnbDl::scheduleBgRtx - adding " << assignedBlocks.at(i) << " to band " << i << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    EV << NOW << " LteSchedulerEnbDl::rtxschedule --------------------::[ START RTX-SCHEDULE ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            const UserTxParams& txParams = mac_->getAmc()->computeTxParams(nodeId, direction_, carrierFrequency);// get the user info
./stack/mac/scheduler/LteSchedulerEnbDl.cc:            // TODO SK Get the number of codewords - FIX with correct mapping
./stack/mac/scheduler/LteSchedulerEnbDl.cc:                        check_and_cast<LteMacEnb*>(mac_)->signalProcessForRtx(nodeId, carrierFrequency, DL, false);
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    EV << "    LteSchedulerEnbDl::rtxschedule --------------------::[  END RTX-SCHEDULE  ]::-------------------- " << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    EV << NOW << " LteSchedulerEnbDl::rtxscheduleBackground --------------------::[ START RTX-SCHEDULE-BACKGROUND ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    // --- Schedule RTX for background UEs --- //
./stack/mac/scheduler/LteSchedulerEnbDl.cc:        EV << NOW << "LteSchedulerEnbDl::rtxschedule BG UE " << bgUeId << " - allocated bytes : " << rtxBytes << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    EV << "    LteSchedulerEnbDl::rtxscheduleBackground --------------------::[  END RTX-SCHEDULE-BACKGROUND  ]::-------------------- " << endl;
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    bool ret = mac_->getAmc()->getPilotUsableBands(ueId, usableBands);
./stack/mac/scheduler/LteSchedulerEnbDl.cc:    unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbDl.h:    //---------------------------------------------
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        std::vector<RxUnitStatus> status = ulHarq->getProcess(currentAcid)->getProcessStatus();
./stack/mac/scheduler/LteSchedulerEnbUl.cc:    EV << NOW << " LteSchedulerEnbUl::racschedule --------------------::[ START RAC-SCHEDULE ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:    unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            const UserTxParams& txParams = mac_->getAmc()->computeTxParams(nodeId, UL, carrierFrequency);    // get the user info
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    EV << "LteSchedulerEnbUl::racschedule - skipping logical band according to limit value" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    unsigned int bytes = mac_->getAmc()->computeBytesOnNRbs(nodeId,b,cw,blocks,UL,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:    unsigned int availableBlocks = numBands - racAllocatedBlocks;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:    EV << NOW << " LteSchedulerEnbUl::racschedule --------------------::[  END RAC-SCHEDULE  ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:    EV << NOW << " LteSchedulerEnbUl::racscheduleBackground - scheduling RAC for background UEs" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:    unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                EV << "LteSchedulerEnbUl::racscheduleBackground - skipping logical band according to limit value" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        EV << NOW << " LteSchedulerEnbUl::rtxschedule --------------------::[ START RTX-SCHEDULE ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    // UE has left the simulation - erase queue and continue
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                const UserTxParams& txParams = mac_->getAmc()->computeTxParams(nodeId, direction_,carrierFrequency);// get the user info
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                        --codewords;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                        check_and_cast<LteMacEnb*>(mac_)->signalProcessForRtx(nodeId, carrierFrequency, UL, false);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            // --- START Schedule D2D retransmissions --- //
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            HarqBuffersMirrorD2D* harqBuffersMirrorD2D = check_and_cast<LteMacEnbD2D*>(mac_)->getHarqBuffersMirrorD2D(carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                        // UE has left the simulation - erase queue and continue
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                        // UE has left the simulation - erase queue and continue
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    EV << NOW << " LteSchedulerEnbUl::rtxschedule - D2D UE: " << senderId << " Acid: " << (unsigned int)currentAcid << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    const UserTxParams& txParams = mac_->getAmc()->computeTxParams(senderId, dir,carrierFrequency);// get the user info
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                            --codewords;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                            check_and_cast<LteMacEnb*>(mac_)->signalProcessForRtx(senderId, carrierFrequency, D2D, false);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    EV << NOW << " LteSchedulerEnbUl::rtxschedule - D2D UE: " << senderId << " allocated bytes : " << allocatedBytes << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            // --- END Schedule D2D retransmissions --- //
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        EV << NOW << " LteSchedulerEnbUl::rtxschedule --------------------::[  END RTX-SCHEDULE  ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        EV << NOW << " LteSchedulerEnbUl::rtxscheduleBackground --------------------::[ START RTX-SCHEDULE-BACKGROUND ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        // --- Schedule RTX for background UEs --- //
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            EV << NOW << "LteSchedulerEnbUl::rtxscheduleBackground BG UE " << bgUeId << " - allocated bytes : " << rtxBytes << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        EV << NOW << " LteSchedulerEnbUl::rtxscheduleBackground --------------------::[  END RTX-SCHEDULE-BACKGROUND ]::--------------------" << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        const UserTxParams& txParams = mac_->getAmc()->computeTxParams(nodeId, direction_,carrierFrequency);    // get the user info
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        EV << NOW << "LteSchedulerEnbUl::rtxAcid - Node[" << mac_->getMacNodeId() << ", User[" << nodeId << ", Codeword[ " << cw << "], ACID[" << (unsigned int)acid << "] " << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        LteHarqProcessRx* currentProcess = harqRxBuffers_->at(carrierFrequency).at(nodeId)->getProcess(acid);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        std::pair<unsigned int, Codeword> scListMirrorId = std::pair<unsigned int, Codeword>(idToMacCid(nodeId,SHORT_BSR), MAX_CODEWORDS - cw - 1);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                allocatedCw = MAX_CODEWORDS - cw - 1;
./stack/mac/scheduler/LteSchedulerEnbUl.cc://                    ((allocatedCw == MAX_CODEWORDS) ? availableBytes(nodeId,antenna, b, cw) : mac_->getAmc()->blocks2bytes(nodeId, b, cw, allocator_->getBlocks(antenna,b,nodeId) , direction_));    // available space
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                // signal end loop - all data have been serviced
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            unsigned int servedBlocks = mac_->getAmc()->computeReqRbs(nodeId, b, cw, servedBytes, direction_,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            toServe -= servedBytes;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            // process couldn't be served - no sufficient space on available bands
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    EV << NOW << " LteSchedulerEnbUl::rtxAcid - adding " << assignedBlocks.at(i) << " to band " << i << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        const UserTxParams& txParams = mac_->getAmc()->computeTxParams(senderId, dir,carrierFrequency);    // get the user info
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        EV << NOW << "LteSchedulerEnbUl::schedulePerAcidRtxD2D - Node[" << mac_->getMacNodeId() << ", User[" << senderId << ", Codeword[ " << cw << "], ACID[" << (unsigned int)acid << "] " << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        HarqBuffersMirrorD2D* harqBuffersMirrorD2D = check_and_cast<LteMacEnbD2D*>(mac_)->getHarqBuffersMirrorD2D(carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        LteHarqProcessMirrorD2D* currentProcess = harqBuffersMirrorD2D->at(pair)->getProcess(acid);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        std::pair<unsigned int, Codeword> scListMirrorId = std::pair<unsigned int, Codeword>(idToMacCid(senderId, D2D_SHORT_BSR), MAX_CODEWORDS - cw - 1);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                allocatedCw = MAX_CODEWORDS - cw - 1;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            //((allocatedCw == MAX_CODEWORDS) ? availableBytes(nodeId,antenna, b, cw) : mac_->getAmc()->blocks2bytes(nodeId, b, cw, allocator_->getBlocks(antenna,b,nodeId) , direction_));    // available space
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                // signal end loop - all data have been serviced
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            unsigned int servedBlocks = mac_->getAmc()->computeReqRbs(senderId, b, cw, servedBytes, dir,carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            toServe -= servedBytes;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            // process couldn't be served - no sufficient space on available bands
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    EV << NOW << " LteSchedulerEnbUl::schedulePerAcidRtxD2D - adding " << assignedBlocks.at(i) << " to band " << i << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduler/LteSchedulerEnbUl.cc:        EV << NOW << "LteSchedulerEnbUl::scheduleBgRtx - Node[" << mac_->getMacNodeId() << ", User[" << bgUeId << "]"<< endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                // signal end loop - all data have been serviced
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            toServe -= servedBytes;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            // process couldn't be served - no sufficient space on available bands
./stack/mac/scheduler/LteSchedulerEnbUl.cc:                    EV << NOW << " LteSchedulerEnbUl::scheduleBgRtx - adding " << assignedBlocks.at(i) << " to band " << i << endl;
./stack/mac/scheduler/LteSchedulerEnbUl.cc:            LteChannelModel* channelModel = mac_->getPhy()->getChannelModel(carrierFrequency);
./stack/mac/scheduler/LteSchedulerEnbUl.h:    //---------------------------------------------
./stack/mac/scheduler/LteSchedulerEnbUl.h:    //! Uplink Synchronous H-ARQ process counter - keeps track of currently active process on connected UES.
./stack/mac/scheduler/LteSchedulerUeUl.cc:    EV << NOW << " LteSchedulerUeUl::schedule - Scheduling node " << nodeId << endl;
./stack/mac/scheduler/LteSchedulerUeUl.cc:        EV << NOW << " LteSchedulerUeUl::schedule - Node " << mac_->getMacNodeId() << " available data from grant are "
./stack/mac/scheduler/LteSchedulerUeUl.cc:           << " blocks " << availableBlocks << " [" << availableBytes << " - Bytes]  on codeword " << cw << endl;
./stack/mac/scheduler/LteSchedulerUeUl.h:    // Inner Scheduler - default to Standard LCG
./stack/mac/scheduler/NRSchedulerGnbUl.cc:        EV << NOW << " NRSchedulerGnbUl::rtxschedule --------------------::[ START RTX-SCHEDULE ]::--------------------" << endl;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:        EV << NOW << " NRSchedulerGnbUl::rtxschedule eNodeB: " << mac_->getMacCellId() << " - Direction: " << (direction_ == UL ? "UL" : "DL") << endl;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                    // UE has left the simulation - erase queue and continue
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                const UserTxParams& txParams = mac_->getAmc()->computeTxParams(nodeId, direction_, carrierFrequency);// get the user info
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                // TODO SK Get the number of codewords - FIX with correct mapping
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                            EV << NOW << " NRSchedulerGnbUl::rtxschedule UE " << nodeId << " - detected Acid: " << process << " in status " << currProc->getUnitStatus(cw) << endl;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                            --codewords;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                            check_and_cast<LteMacEnb*>(mac_)->signalProcessForRtx(nodeId, carrierFrequency, UL, false);
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                    EV << NOW << "NRSchedulerGnbUl::rtxschedule UE " << nodeId << " - allocated bytes : " << allocatedBytes << endl;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:            // --- START Schedule D2D retransmissions --- //
./stack/mac/scheduler/NRSchedulerGnbUl.cc:            HarqBuffersMirrorD2D* harqBuffersMirrorD2D = check_and_cast<LteMacEnbD2D*>(mac_)->getHarqBuffersMirrorD2D(carrierFrequency);
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                        // UE has left the simulation - erase queue and continue
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                        // UE has left the simulation - erase queue and continue
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                    const UserTxParams& txParams = mac_->getAmc()->computeTxParams(senderId, dir,carrierFrequency);// get the user info
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                    EV << NOW << " NRSchedulerGnbUl::rtxschedule D2D TX UE: " << senderId << " - RX UE: " << destId <<endl;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                            EV << NOW << " NRSchedulerGnbUl::rtxschedule ------- CODEWORD " << cw << endl;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                                --codewords;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                                check_and_cast<LteMacEnb*>(mac_)->signalProcessForRtx(senderId, carrierFrequency, D2D, false);
./stack/mac/scheduler/NRSchedulerGnbUl.cc:                        EV << NOW << " NRSchedulerGnbUl::rtxschedule - D2D UE: " << senderId << " allocated bytes : " << allocatedBytes << endl;
./stack/mac/scheduler/NRSchedulerGnbUl.cc:            // --- END Schedule D2D retransmissions --- //
./stack/mac/scheduler/NRSchedulerGnbUl.cc:        EV << NOW << " NRSchedulerGnbUl::rtxschedule --------------------::[  END RTX-SCHEDULE  ]::--------------------" << endl;
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:            throw cRuntimeError("LteAllocatorBestFit::prepareSchedule - conflictGraph is a NULL pointer");
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:    int firstUnallocatedBandIM = eNbScheduler_->getResourceBlocks() - 1;
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:        const UserTxParams& info = eNbScheduler_->mac_->getAmc()->computeTxParams(nodeId,dir,carrierFrequency_);
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:                availableBytes += eNbScheduler_->mac_->getAmc()->computeBytesOnNRbs(nodeId,*it, availableBlocks, dir,carrierFrequency_);
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:        const UserTxParams& txParams = mac_->getAmc()->computeTxParams(nodeId,dir,carrierFrequency_);
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:        req_Bytes1RB = eNbScheduler_->mac_->getAmc()->computeBytesOnNRbs(nodeId,0,cw,1,dir,carrierFrequency_); // The band (here equals to 0) is useless
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:        unsigned int numBands = mac_->getCellInfo()->getNumBands();
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:                 * - the band is occupied by a non-reuse-enabled node.
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc://                    std::cout << NOW << " UE " << nodeId << " --- skipping band " << band << endl;
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:            for( band=firstUnallocatedBandIM; band>=0; band-- )
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:                EV << NOW << " LteAllocatorBestFit - UE " << nodeId << ": allocated RB " << band << " [" <<blocks<<"]" << endl;
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:            for( band=candidate.index; band > end; band-- )
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:                EV << NOW << " LteAllocatorBestFit - UE " << nodeId << ": allocated RB " << band << " [" <<blocks<<"]" << endl;
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:                conn->front().first -= (blocks*req_Bytes1RB - MAC_HEADER - RLC_HEADER_UM); // Otherwise update the BSR size
./stack/mac/scheduling_modules/LteAllocatorBestFit.cc:    int numbands = eNbScheduler_->mac_->getAmc()->getSystemNumBands();
./stack/mac/scheduling_modules/LteDrr.cc:        // check if node is still a valid node in the simulation - might have been dynamically removed
./stack/mac/scheduling_modules/LteDrr.cc:        if(getBinder()->getOmnetId(nodeId) == 0){
./stack/mac/scheduling_modules/LteDrr.cc:            EV << "CID " << cid << " of node "<< nodeId << " removed from active connection set - no OmnetId in Binder known.";
./stack/mac/scheduling_modules/LteDrr.cc:            eligible--;
./stack/mac/scheduling_modules/LteDrr.cc:        if (desc.deficit_ - scheduled < 0)
./stack/mac/scheduling_modules/LteDrr.cc:        desc.deficit_ -= scheduled;
./stack/mac/scheduling_modules/LteDrr.cc:            eligible--;              // decrement the number of eligible conns
./stack/mac/scheduling_modules/LteDrr.cc:            desc.deficit_ -= desc.quantum_;
./stack/mac/scheduling_modules/LteDrr.cc:        const UserTxParams& info = eNbScheduler_->mac_->getAmc()->computeTxParams(nodeId, direction_,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCi.cc:                // node has left the simulation - erase corresponding CIDs
./stack/mac/scheduling_modules/LteMaxCi.cc:        const UserTxParams& info = eNbScheduler_->mac_->getAmc()->computeTxParams(nodeId,dir,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCi.cc:                availableBytes += eNbScheduler_->mac_->getAmc()->computeBytesOnNRbs(nodeId,*it, availableBlocks, dir,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCi.cc:            // - the most significant 16 bits are set to the background UE id (BGUE_MIN_ID+index)
./stack/mac/scheduling_modules/LteMaxCi.cc:            // - the least significant 16 bits are set to 0 (lcid=0)
./stack/mac/scheduling_modules/LteMaxCiComp.cc:    bool ret = eNbScheduler_->mac_->getAmc()->getPilotUsableBands(ueId, usableBands);
./stack/mac/scheduling_modules/LteMaxCiComp.cc:    unsigned int numBands = eNbScheduler_->mac_->getCellInfo()->getNumBands();
./stack/mac/scheduling_modules/LteMaxCiComp.cc:            // node has left the simulation - erase corresponding CIDs
./stack/mac/scheduling_modules/LteMaxCiComp.cc:        const UserTxParams& info = eNbScheduler_->mac_->getAmc()->computeTxParams(nodeId,direction_,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCiComp.cc:                availableBytes += eNbScheduler_->mac_->getAmc()->computeBytesOnNRbs(nodeId,*it, availableBlocks, direction_,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCiMultiband.cc:        cout << NOW << " LteMaxCiMultiband::prepareSchedule - Tot Active Connections:"<< activeConnectionTempSet_.size() << endl;
./stack/mac/scheduling_modules/LteMaxCiMultiband.cc:            // node has left the simulation - erase corresponding CIDs
./stack/mac/scheduling_modules/LteMaxCiMultiband.cc:        std::vector<Cqi> vect = eNbScheduler_->mac_->getAmc()->readMultiBandCqi(nodeId,direction_,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCiMultiband.cc:            cout << NOW << " LteMaxCiMultiband::prepareSchedule - per band cqi for UE[" << nodeId << "]" << endl;
./stack/mac/scheduling_modules/LteMaxCiMultiband.cc:            availableBytes_MB = eNbScheduler_->mac_->getAmc()->computeBytesOnNRbs_MB(nodeId,band, availableBlocks, direction_,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCiMultiband.cc:            availableBytes = eNbScheduler_->mac_->getAmc()->computeBytesOnNRbs(nodeId,band, availableBlocks, direction_,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCiMultiband.cc:                cout << "\t"<< band << ") CQI=" << vect[band] << " - Blocks="<< availableBlocks
./stack/mac/scheduling_modules/LteMaxCiMultiband.cc:                     << " - Bytes_MB="<< availableBytes_MB<< " - Bytes="<< availableBytes<< endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc: *  - reads the per band CQI for each UE and stores them in the "cqiPerBandMatrix" structure ( < ueID , CQIs > )
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc: *  - for each band configuration, computes the minimum CQI between the bands active within it, and stores
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc: *  - generate the optimization problem storing it into the file specified by "problemFile_"
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://        cout << NOW << " LteMaxCiOptMB::generateProblem - No Active Connections" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        EV << NOW <<" LteMaxCiOptMB::generateProblem - No Available RBs" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        cqiPerBandMatrix.insert(pair< MacNodeId,std::vector<Cqi> >(ueId,eNbScheduler_->mac_->getAmc()->readMultiBandCqi(ueId,direction_,carrierFrequency_)));
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:            unsigned int availableBytes_MB = eNbScheduler_->mac_->getAmc()->computeBytesOnNRbs_MB(ueId,iBand, availableBlocks, direction_,carrierFrequency_);
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:         *  - sorting the bands by CQI value
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:         *  - for each bandConfig, browse the sorted list and select the first CQI whose band belongs to the bandConfig
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        appFileStream << "v" << ueList_[iUe] << " - p" << ueList_[iUe];
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:    appFileStream << "\\ Ue= " << totUes << " - totBands= " << totBandConfig << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:            appFileStream << "v" << ueList_[iUe] << "_" << iBandConf << " - "
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:            appFileStream << "v" << ueId<< "_" << iBandConf << " - " ;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:                        appFileStream << " - ";
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:            appFileStream << " - v" << ueId << "_" << iBandConf;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://        cout << "\t CID["<< it->first << "] - ";
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        if(it == mac_->getMacBuffers()->end())
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://        appFileStream << iUe<< ")UE=" << ueList[iUe] << " - cid=" << cidList[iUe] << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        appFileStream << "v" << ueId << " - p" << ueId << " <= " << queue << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://            appFileStream << "\\ BandConf[" << iBandConf<< "] - minBand[" << cqiPerConfig[iBandConf-1]
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://                          << "] - minCqi[" << cqiPerBand[cqiPerConfig[iBandConf-1]] << "]" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:                          << " <= " << (cqiPerBand[cqiPerConfig[iBandConf-1]] + MAX_RATE - 1) << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:            appFileStream << " - s" << ueId << "_" << iBand << " <= 0"<< endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:            appFileStream << "s" << ueId << "_" << iBand << " - ";
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:                         appFileStream << " - ";
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:    EV << "LteMaxCiOptMB::prepareSchedule - TEST" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        EV << NOW << " LteMaxCiOptMB::prepareSchedule - Launching problem..." << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        EV << NOW << " LteMaxCiOptMB::prepareSchedule - Problem Solved" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://        cRuntimeError("FATAL! LteMaxCiOptMB::readSolution - No solution file found. Aborting");
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:////        cout << NOW << " LteMaxCiOptMB::readSolution - TagName[" << nodeName << "]" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://        cRuntimeError("FATAL! LteMaxCiOptMB::readSolution - Cannot find TAG Variables. Aborting");
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:////            cout  << NOW << " LteMaxCiOptMB::readSolution - name[" << name << "/"<< nameString<<"] - value[" << value << "]" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://            cout  << NOW << " LteMaxCiOptMB::readSolution - Ue[" << ue<<"] - band[" << band<<"] - value[" << value << "]" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc://        cout  << NOW << " LteMaxCiOptMB::readSolution - Ue[" << ue<<"] - band[" << band<<"] - value[" << value << "]" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:            EV << " LteMaxCiOptMB::readSolution - Adding usable band[" << bandLimit.band_ << "] for UE[" <<  atoi(ue.c_str()) << "]" << endl;
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        eNbScheduler_->mac_->getAmc()->setPilotUsableBands(ueId,itUsable->second);
./stack/mac/scheduling_modules/LteMaxCiOptMB.cc:        cRuntimeError("LteMaxCiOptMB::applyScheduling - number of CIDs and schedulingDecision size doesn't match. Aborting...");
./stack/mac/scheduling_modules/LtePf.cc:            // node has left the simulation - erase corresponding CIDs
./stack/mac/scheduling_modules/LtePf.cc:        // check if node is still a valid node in the simulation - might have been dynamically removed
./stack/mac/scheduling_modules/LtePf.cc:        if(getBinder()->getOmnetId(nodeId) == 0){
./stack/mac/scheduling_modules/LtePf.cc:            EV << "CID " << cid << " of node "<< nodeId << " removed from active connection set - no OmnetId in Binder known.";
./stack/mac/scheduling_modules/LtePf.cc:        const UserTxParams& info = eNbScheduler_->mac_->getAmc()->computeTxParams(nodeId,dir,carrierFrequency_);
./stack/mac/scheduling_modules/LtePf.cc:                availableBytes += eNbScheduler_->mac_->getAmc()->computeBytesOnNRbs(nodeId,*it, availableBlocks, dir, carrierFrequency_);
./stack/mac/scheduling_modules/LtePf.cc:        else if(availableBlocks > 0) s = ((availableBytes / availableBlocks) / pfRate_[cid]) + uniform(getEnvir()->getRNG(0),-scoreEpsilon_/2.0, scoreEpsilon_/2.0);
./stack/mac/scheduling_modules/LtePf.cc:        EV << NOW << "LtePf::execSchedule CID " << cid << "- Score = " << s << endl;
./stack/mac/scheduling_modules/LtePf.cc:        longTermRate = (1.0 - pfAlpha_) * longTermRate + pfAlpha_ * shortTermRate;
./stack/NRNic.ned:        //# PDCP <-> RLC
./stack/NRNic.ned:        pdcpRrc.UM_Sap++ <--> nrRlc.UM_Sap;
./stack/NRNic.ned:        pdcpRrc.AM_Sap++ <--> nrRlc.AM_Sap;
./stack/NRNic.ned:        pdcpRrc.TM_Sap++ <--> nrRlc.TM_Sap;
./stack/NRNic.ned:        //# RLC <-> MAC
./stack/NRNic.ned:        nrRlc.RLC_to_MAC --> nrMac.RLC_to_MAC;
./stack/NRNic.ned:        nrRlc.MAC_to_RLC <-- nrMac.MAC_to_RLC;
./stack/NRNic.ned:        nrMac.MAC_to_PHY --> nrPhy.upperGateIn;
./stack/NRNic.ned:        nrMac.PHY_to_MAC <-- nrPhy.upperGateOut;
./stack/NRNic.ned:        nrRadioIn --> nrPhy.radioIn;
./stack/packetFlowManager/PacketFlowManagerBase.cc:        LteMacBase *mac= check_and_cast<LteMacBase *>(getParentModule()->getSubmodule("mac"));
./stack/packetFlowManager/PacketFlowManagerBase.h: *  - detect PDCP SDU discarded (no part transmitted)
./stack/packetFlowManager/PacketFlowManagerBase.h: *  - calculate the delay time of a pkt, from PDCP SDU to last Harq ACK of the
./stack/packetFlowManager/PacketFlowManagerEnb.cc://        pdcp_ = check_and_cast<LtePdcpRrcEnb *>(getParentModule()->getSubmodule("pdcpRrc"));
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        throw cRuntimeError("%s::initLcid - Logical CID %d already present. Aborting",pfmType.c_str(),  lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << NOW << " node id "<< nodeId << " " << pfmType << "::initLcid - initialized lcid " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " " << pfmType << "::clearLcid - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << NOW << " node id "<< connectionMap_[lcid].nodeId_ << " " << pfmType << "::clearLcid - cleared data structures for lcid " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << NOW << " " << pfmType << "::clearAllLcid - cleared data structures for all lcids "<< endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        throw cRuntimeError("%s::initPdcpStatus - PdcpStatus for PDCP sno [%d] already present for node %d, this should not happen. Abort",pfmType.c_str(),  pdcp, desc->nodeId_);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << pfmType << "::initPdcpStatus - PDCP PDU " << pdcp << "  with header size " << sduHeaderSize << " added" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    int sduSize= (B(pduSize) - header->getChunkLength()).get();
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    int sduSizeBits = (b(pdcpPkt->getBitLength()) - header->getChunkLength()).get();
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV << pfmType << "::insertPdcpSdu - DL PDPC sdu bits: " << sduSizeBits << " sent to node: " << nodeId << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV << pfmType << "::insertPdcpSdu - DL PDPC sdu bits: " << sduDataVolume_[nodeId].dlBits << " sent to node: " << nodeId << " in this perdiod" <<  endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        // EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::insertRlcPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        throw cRuntimeError("%s::insertPdcpSdu - Logical CID %d not present. It must be initialized before",pfmType.c_str(),  lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << NOW << " node id "<< desc->nodeId_<<" " << pfmType << "::insertPdcpSdu - PDCP status for PDCP PDU SN " << pdcpSno<<" added. Logical cid " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV << pfmType << "::insertPdcpSdu - UL PDPC sdu bits: " << sduDataVolume_[nodeId].ulBits << " received from node: " << nodeId << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:     EV << pfmType << "::insertRlcPdu - Logical Cid: " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             // EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::insertRlcPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             throw cRuntimeError("%s::insertRlcPdu - Logical CID %d not present. It must be initialized before",pfmType.c_str(),  lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:         EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::insertRlcPdu - Logical CID " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             throw cRuntimeError("%s::insertRlcPdu - RLC PDU SN %d already present for logical CID %d. Aborting",pfmType.c_str(),  rlcSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                 throw cRuntimeError("%s::insertRlcPdu - node %d and lcid %d . RLC burst status START incompatible with local status %d. Aborting",pfmType.c_str(),  desc->nodeId_, lcid, desc->burstState_ );
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                 throw cRuntimeError("%s::insertRlcPdu - node %d and lcid %d . RLC burst status STOP incompatible with local status %d. Aborting",pfmType.c_str(),  desc->nodeId_, lcid, desc->burstState_ );
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             simtime_t elapsedTime = simTime() - desc->burstStatus_[desc->burstId_].startBurstTransmission;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                 throw cRuntimeError("%s::insertRlcPdu - node %d and lcid %d . RLC burst status INACTIVE incompatible with local status %d. Aborting",pfmType.c_str(),  desc->nodeId_, lcid,  desc->burstState_);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                 throw cRuntimeError("%s::insertRlcPdu - node %d and lcid %d . RLC burst status ACTIVE incompatible with local status %d. Aborting",pfmType.c_str(),  desc->nodeId_, lcid,  desc->burstState_ );
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                 throw cRuntimeError("%s::insertRlcPdu - node %d and lcid %d . Burst status not found during active burst. Aborting",pfmType.c_str(),  desc->nodeId_, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             auto rlcSdu = (*lit)->peekAtFront<LteRlcSdu>();
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             EV <<  "PacketFlowManagerEnb::insertRlcPdu - pdcpSdu " << pdcpSno << " with length: " << pdcpPduLength << "bytes" <<  endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                 throw cRuntimeError("%s::insertRlcPdu - PdcpStatus for PDCP sno [%d] not present, this should not happen. Abort",pfmType.c_str(),  pdcpSno);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             if(lit != rlcSduList->end() && lit == --rlcSduList->end()){
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                 // means -> Last byte of the Data field does not correspond to the last byte of a RLC SDU.
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             // OLD piece of code that counted the pdcp sdu size as the burst dimension -
./stack/packetFlowManager/PacketFlowManagerEnb.cc://                     rlcSduSize += (pdcpPduLength - (lteInfo->getRlcType() == UM ? PDCP_HEADER_UM : PDCP_HEADER_AM) - headerCompressedSize_ + pit->second.pdcpSduSize);
./stack/packetFlowManager/PacketFlowManagerEnb.cc://                     rlcSduSize += (pdcpPduLength - (lteInfo->getRlcType() == UM ? PDCP_HEADER_UM : PDCP_HEADER_AM) - headerCompressedSize_ + pit->second.pdcpSduSize);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::insertRlcPdu - lcid[" << lcid << "], insert PDCP PDU " << pdcpSno << " in RLC PDU " << rlcSno << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:              * NEW piece of code that counts the RLC sdu size as the burst dimension -
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             rlcSduSize = (B(rlcPdu->getChunkLength()) - B(RLC_HEADER_UM)).get(); // RLC pdu size - RLC header
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                 throw cRuntimeError("%s::insertRlcPdu - node %d and lcid %d . Burst status not found during active burst. Aborting",pfmType.c_str(),  desc->nodeId_, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:             EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::insertRlcPdu - lcid[" << lcid << "], insert RLC SDU of size " << rlcSduSize <<endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        // EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::discardRlcPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        throw cRuntimeError("%s::discardRlcPdu - Logical CID %d not present. It must be initilized before",pfmType.c_str(),  lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        throw cRuntimeError("%s::discardRlcPdu - RLC PDU SN %d not present for logical CID %d. Aborting",pfmType.c_str(),  rlcSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    SequenceNumberSet pdcpSnoSet = desc->rlcSdusPerPdu_.find(rlcSno)->second;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        // find sdu -> rlcs for this pdcp
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::discardRlcPdu - PdcpStatus for PDCP sno [%d] with lcid [%d] not present, this should not happen. Abort",pfmType.c_str(),  pdcpSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::discardRlcPdu - PdcpStatus for PDCP sno [%d] already present, this should not happen. Abort",pfmType.c_str(),  pdcpSno);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        // ---> all PDCP has been discarded at eNB before star its transmission
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::discardRlcPdu - lcid[" << lcid << "], discarded PDCP PDU " << pdcpSno << " in RLC PDU " << rlcSno << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        throw cRuntimeError("%s::macPduArrived - macPdu has no Rlc pdu! This, here, should not happen",pfmType.c_str());
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        int lcid = lteInfo ->getLcid();
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            // EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::insertMacPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::insertMacPdu - Logical CID %d not present. It must be initilized before",pfmType.c_str(),  lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::insertMacPdu - MAC PDU ID %d already present for logical CID %d. Aborting",pfmType.c_str(),  macPduId, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            unsigned int rlcSno =rlcPdu.peekAtFront<LteRlcUmDataPdu>()->getPduSequenceNumber();
./stack/packetFlowManager/PacketFlowManagerEnb.cc:               throw cRuntimeError("%s::insertMacPdu - RLC PDU ID %d not present in the status descriptor of lcid %d ",pfmType.c_str(),  rlcSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::insertMacPdu - lcid[" << lcid << "], insert RLC PDU " << rlcSno << " in MAC PDU " << macPduId << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                    throw cRuntimeError("%s::insertMacPdu - PdcpStatus for PDCP sno [%d] not present, this should not happen. Abort",pfmType.c_str(),  *pit);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        throw cRuntimeError("%s::macPduArrived - macPdu has no Rlc pdu! This, here, should not happen",pfmType.c_str());
./stack/packetFlowManager/PacketFlowManagerEnb.cc:         int lcid = lteInfo ->getLcid();
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            // EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::notifyHarqProcess - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::macPduArrived - Logical CID %d not present. It must be initilized before",pfmType.c_str(),  lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::macPduArrived - MAC PDU "<< macPduId << " of lcid " << lcid << " arrived." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::macPduArrived - Get MAC PDU ID [" << macPduId << "], which contains:" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            EV << NOW << " " << pfmType << "::insertMacPdu - The process does not contain entire SDUs" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::macPduArrived - MAC PDU ID %d not present for logical CID %d. Aborting",pfmType.c_str(),  macPduId, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::macPduArrived - --> RLC PDU [" << rlcPduSno << "], which contains:" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                throw cRuntimeError("%s::macPduArrived - RLC PDU SN %d not present for logical CID %d. Aborting",pfmType.c_str(),  rlcPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::macPduArrived - ----> PDCP PDU [" << pdcpPduSno << "]" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                    throw cRuntimeError("%s::macPduArrived - PDCP PDU SN %d not present for logical CID %d. Aborting",pfmType.c_str(),  pdcpPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                     throw cRuntimeError("%s::macPduArrived - RLC PDU SN %d not present in the set of PDCP PDU SN %d for logical CID %d. Aborting",pfmType.c_str(),  pdcpPduSno, rlcPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                    throw cRuntimeError("%s::macPduArrived - PdcpStatus for PDCP sno [%d] not present for lcid [%d], this should not happen. Abort",pfmType.c_str(),  pdcpPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                        throw cRuntimeError("%s::macPduArrived - PDCP PDU SN %d of Lcid %d has not an entry time timestamp, this should not happen. Aborting",pfmType.c_str(),  pdcpPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                        EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::macPduArrived - ----> PDCP PDU [" << pdcpPduSno << "] has been completely sent, remove from PDCP buffer" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                        double time = (simTime() - pit->second.entryTime).dbl() ;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                        EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::macPduArrived - PDCP PDU "<< pdcpPduSno << " of lcid " << lcid << " acknowledged. Delay time: " << time << "s"<< endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                        dit->second.time += (simTime() - pit->second.entryTime);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        throw cRuntimeError("%s::macPduArrived - macPdu has no Rlc pdu! This, here, should not happen",pfmType.c_str());
./stack/packetFlowManager/PacketFlowManagerEnb.cc:       int lcid = lteInfo ->getLcid();
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            // EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::notifyHarqProcess - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::discardMacPdu - Logical CID %d not present. It must be initilized before",pfmType.c_str(),  lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::discardMacPdu - MAC PDU "<< macPduId << " of lcid " << lcid << " arrived." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " node id "<< desc->nodeId_<< " " << pfmType << "::discardMacPdu - Get MAC PDU ID [" << macPduId << "], which contains:" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            EV << NOW << " " << pfmType << "::discardMacPdu - The process does not contain entire SDUs" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::discardMacPdu - MAC PDU ID %d not present for logical CID %d. Aborting",pfmType.c_str(),  macPduId, lcid);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                tit->second.pktSizeCount += bsit->second.burstSize; //*8 --> bits
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                tit->second.time += (simTime() - bsit->second.startBurstTransmission);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                double tp = ((double)bsit->second.burstSize)/(simTime() - bsit->second.startBurstTransmission).dbl();
./stack/packetFlowManager/PacketFlowManagerEnb.cc:                EV_FATAL << NOW << " node id "<< desc->nodeId_  << " " << pfmType << "::removePdcpBurst Burst "<< bsit->first << " length " << simTime() - bsit->second.startBurstTransmission<< "s, with size " << bsit->second.burstSize <<"B -> tput: "<< tp <<" B/s" <<endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc://        throw cRuntimeError("%s::resetCounterPerUe - nodeId [%d] not present",pfmType.c_str(),  id);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        //throw cRuntimeError("%s::getTotalDiscardedPckPerUe - nodeId [%d] not present",pfmType.c_str(),  id);
./stack/packetFlowManager/PacketFlowManagerEnb.cc://        EV << NOW << " " << pfmType << "::insertHarqProcess - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc://    // record the associaton MAC PDU - HARQ process only if the MAC PDU contains a RLC PDU that, in turn, contains at least one entire SDU
./stack/packetFlowManager/PacketFlowManagerEnb.cc://        EV << NOW << " " << pfmType << "::insertMacPdu - lcid[" << lcid << "], insert MAC PDU " << macPduId << " in HARQ PROCESS " << harqProcId << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            throw cRuntimeError("%s::grantSent - grant [%d] for nodeId [%d] already present",pfmType.c_str(), grantId, nodeId);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << NOW << " " << pfmType << "::grantSent - Added grant " << grantId << " for nodeId " << nodeId << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            simtime_t time = simTime() - it->sendTimestamp;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:            EV_FATAL << NOW << " " << pfmType << "::ulMacPduArrived - TB received from nodeId " << nodeId << " related to grantId " << grantId << " after " << time.dbl() << "seconds" << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    throw cRuntimeError("%s::ulMacPduArrived - grant [%d] for nodeId [%d] not present",pfmType.c_str(), grantId, nodeId);
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " " << pfmType << "::getDelayStatsPerUe - Delay Stats for Node Id " << id << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << NOW << " " << pfmType << "::getDelayStatsPerUe - Delay Stats for Node Id " << id << " total time: "<< (it->second.time.dbl())*1000 << "ms, pckcount: " <<it->second.pktCount   << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " " << pfmType << "::getUlDelayStatsPerUe - Delay Stats for Node Id " << id << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << NOW << " " << pfmType << "::getUlDelayStatsPerUe - Delay Stats for Node Id " << id << " total time: "<< (it->second.time.dbl())*1000 << "ms, pckcount: " <<it->second.pktCount   << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:       EV_FATAL << NOW << " " << pfmType << "::resetDelayCounterPerUe - Delay Stats for Node Id " << id << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:       EV_FATAL << NOW << " " << pfmType << "::resetUlDelayCounterPerUe - Ul Delay Stats for Node Id " << id << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " " << pfmType << "::getThroughputStatsPerUe - Throughput Stats for Node Id " << id << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:    EV_FATAL << NOW << " " << pfmType << "::getThroughputStatsPerUe - Throughput Stats for Node Id " << id << " " << throughput << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:        EV_FATAL << NOW << " " << pfmType << "::resetThroughputCounterPerUe - Throughput Stats for Node Id " << id << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerEnb.cc:       throw cRuntimeError("PacketFlowManagerEnb::getDataVolume - Wrong direction");
./stack/packetFlowManager/PacketFlowManagerEnb.cc:      throw cRuntimeError("PacketFlowManagerEnb::getDataVolume - Wrong direction");
./stack/packetFlowManager/PacketFlowManagerEnb.h: *  - detect PDCP SDU discarded (no part transmitted)
./stack/packetFlowManager/PacketFlowManagerEnb.h: *  - calculate the delay time of a pkt, from PDCP SDU to last Harq ACK of the
./stack/packetFlowManager/PacketFlowManagerUe.cc://        pdcp_ = check_and_cast<LtePdcpRrcUe *>(getParentModule()->getSubmodule("pdcpRrc"));
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::initLcid - Logical CID %d already present. Aborting", pfmType.c_str(), lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:    EV_FATAL << NOW << "node id "<< nodeId << " " << pfmType.c_str() <<"::initLcid - initialized lcid " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        EV_FATAL << NOW << " " << pfmType.c_str() <<"::clearLcid - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:    EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::clearLcid - cleared data structures for lcid " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:    EV_FATAL << NOW << " " << pfmType.c_str() <<"::clearAllLcid - cleared data structures for all lcids "<< endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::initPdcpStatus - PdcpStatus for PDCP sno [%d] already present, this should not happen. Abort", pfmType.c_str(), pdcp);
./stack/packetFlowManager/PacketFlowManagerUe.cc:           // EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::insertRlcPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:           throw cRuntimeError("%s::insertPdcpSdu - Logical CID %d not present. It must be initialized before", pfmType.c_str(), lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:       EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 <<" " << pfmType.c_str() <<"::insertPdcpSdu - PDCP status for PDCP PDU SN " << pdcpSno<<" added. Logicl cid " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc://        // EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::insertRlcPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc://        throw cRuntimeError("%s::insertRlcPdu - Logical CID %d not present. It must be initialized before", pfmType.c_str(), lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc://        throw cRuntimeError("%s::insertRlcPdu - RLC PDU SN %d already present for logical CID %d. Aborting", pfmType.c_str(), rlcSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc://    EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::insertRlcPdu - Logical CID " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc://            throw cRuntimeError("%s::insertRlcPdu - PdcpStatus for PDCP sno [%d] not present, this should not happen. Abort", pfmType.c_str(), pdcpSno);
./stack/packetFlowManager/PacketFlowManagerUe.cc://        if(sit != pdcpSnoSet.end() && sit == --pdcpSnoSet.end()){
./stack/packetFlowManager/PacketFlowManagerUe.cc://        EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::insertRlcPdu - lcid[" << lcid << "], insert PDCP PDU " << pdcpSno << " in RLC PDU " << rlcSno << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            // EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::insertRlcPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::insertRlcPdu - Logical CID %d not present. It must be initialized before", pfmType.c_str(), lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::insertRlcPdu - RLC PDU SN %d already present for logical CID %d. Aborting", pfmType.c_str(), rlcSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::insertRlcPdu - Logical CID " << lcid << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            auto rlcSdu = (*lit)->peekAtFront<LteRlcSdu>();
./stack/packetFlowManager/PacketFlowManagerUe.cc:            EV << pfmType.c_str() <<"::insertRlcPdu - pdcpSdu " << pdcpSno << " with length: " << pdcpPduLength << "bytes" <<  endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:                throw cRuntimeError("%s::insertRlcPdu - PdcpStatus for PDCP sno [%d] not present, this should not happen. Abort", pfmType.c_str(), pdcpSno);
./stack/packetFlowManager/PacketFlowManagerUe.cc:            if(lit != rlcSduList->end() && lit == --rlcSduList->end()){
./stack/packetFlowManager/PacketFlowManagerUe.cc:                // means -> Last byte of the Data field does not correspond to the last byte of a RLC SDU.
./stack/packetFlowManager/PacketFlowManagerUe.cc:            EV_FATAL << NOW  << " " << pfmType.c_str() <<"::insertRlcPdu - lcid[" << lcid << "], insert PDCP PDU " << pdcpSno << " in RLC PDU " << rlcSno << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        // EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::discardRlcPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::discardRlcPdu - Logical CID %d not present. It must be initilized before", pfmType.c_str(), lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::discardRlcPdu - RLC PDU SN %d not present for logical CID %d. Aborting", pfmType.c_str(), rlcSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:    SequenceNumberSet pdcpSnoSet = desc->rlcSdusPerPdu_.find(rlcSno)->second;
./stack/packetFlowManager/PacketFlowManagerUe.cc://        if(desc->nodeId_ - 1025 == 7)
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::discardRlcPdu - PdcpStatus for PDCP sno [%d] with lcid [%d] not present, this should not happen. Abort", pfmType.c_str(), pdcpSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::discardRlcPdu - PdcpStatus for PDCP sno [%d] already present, this should not happen. Abort", pfmType.c_str(), pdcpSno);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        // ---> all PDCP has been discard at eNB before start its trasmission
./stack/packetFlowManager/PacketFlowManagerUe.cc:            EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::discardRlcPdu - lcid[" << lcid << "], discarded PDCP PDU " << pdcpSno << " in RLC PDU " << rlcSno << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::macPduArrived - macPdu has no Rlc pdu! This, here, should not happen",pfmType.c_str());
./stack/packetFlowManager/PacketFlowManagerUe.cc:        int lcid = lteInfo ->getLcid();
./stack/packetFlowManager/PacketFlowManagerUe.cc:            // EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::insertMacPdu - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::insertMacPdu - Logical CID %d not present. It must be initilized before", pfmType.c_str(), lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::insertMacPdu - MAC PDU ID %d already present for logical CID %d. Aborting", pfmType.c_str(), macPduId, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        int ll = ee ->getLcid();
./stack/packetFlowManager/PacketFlowManagerUe.cc:        // record the associaton RLC PDU - MAC PDU only if the RLC PDU contains at least one entire SDU
./stack/packetFlowManager/PacketFlowManagerUe.cc:           throw cRuntimeError("%s::insertMacPdu - RLC PDU ID %d not present in the status descriptor of lcid %d ", pfmType.c_str(), rlcSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::insertMacPdu - lcid[" << lcid << "], insert RLC PDU " << rlcSno << " in MAC PDU " << macPduId << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:                throw cRuntimeError("%s::insertMacPdu - PdcpStatus for PDCP sno [%d] not present, this should not happen. Abort", pfmType.c_str(), *pit);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::macPduArrived - macPdu has no Rlc pdu! This, here, should not happen",pfmType.c_str());
./stack/packetFlowManager/PacketFlowManagerUe.cc:         int lcid = lteInfo ->getLcid();
./stack/packetFlowManager/PacketFlowManagerUe.cc:            // EV_FATAL << NOW << " node id "<< desc->nodeId_<< " PacketFlowManagerEnb::notifyHarqProcess - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::macPduArrived - Logical CID %d not present. It must be initilized before", pfmType.c_str(),lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::macPduArrived - Get MAC PDU ID [" << macPduId << "], which contains:" << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::macPduArrived - MAC PDU "<< macPduId << " of lcid " << lcid << " arrived." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            EV << NOW << " " << pfmType.c_str() <<"::insertMacPdu - The process does not contain entire SDUs" << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::macPduArrived - MAC PDU ID %d not present for logical CID %d. Aborting", pfmType.c_str(), macPduId, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::macPduArrived - RLC sno [%d] not present in rlcSnoSet structure for MAC PDU ID %d not present for logical CID %d. Aborting", pfmType.c_str(),rlcSno, macPduId, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::macPduArrived - --> RLC PDU [" << rlcPduSno << "], which contains:" << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::macPduArrived - RLC PDU SN %d not present for logical CID %d. Aborting", pfmType.c_str(), rlcPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:            EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::macPduArrived - ----> PDCP PDU [" << pdcpPduSno << "]" << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:                throw cRuntimeError("%s::macPduArrived - PDCP PDU SN %d not present for logical CID %d. Aborting", pfmType.c_str(), pdcpPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:                 throw cRuntimeError("%s::macPduArrived - RLC PDU SN %d not present in the set of PDCP PDU SN %d for logical CID %d. Aborting", pfmType.c_str(), pdcpPduSno, rlcPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:                throw cRuntimeError("%s::macPduArrived - PdcpStatus for PDCP sno [%d] not present for lcid [%d], this should not happen. Abort", pfmType.c_str(), pdcpPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:    //                    throw cRuntimeError("%s::macPduArrived - PDCP PDU SN %d of Lcid %d has not an entry time timestamp, this should not happen. Aborting", pfmType.c_str(), pdcpPduSno, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:                    EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::macPduArrived - ----> PDCP PDU [" << pdcpPduSno << "] has been completely sent, remove from PDCP buffer" << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:                    double time = (simTime() - pit->second.entryTime).dbl();
./stack/packetFlowManager/PacketFlowManagerUe.cc:                    EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::macPduArrived - PDCP PDU "<< pdcpPduSno << " of lcid " << lcid << " acknowledged. Delay time: " << time << "s"<< endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        throw cRuntimeError("%s::macPduArrived - macPdu has no Rlc pdu! This, here, should not happen",pfmType.c_str());
./stack/packetFlowManager/PacketFlowManagerUe.cc:        int lcid = lteInfo ->getLcid();
./stack/packetFlowManager/PacketFlowManagerUe.cc:            // EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::notifyHarqProcess - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::discardMacPdu - Logical CID %d not present. It must be initilized before", pfmType.c_str(), lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:        EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::discardMacPdu - Get MAC PDU ID [" << macPduId << "], which contains:" << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:        EV_FATAL << NOW << "node id "<< desc->nodeId_-1025 << " " << pfmType.c_str() <<"::discardMacPdu - MAC PDU "<< macPduId << " of lcid " << lcid << " arrived." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            EV << NOW << " " << pfmType.c_str() <<"::discardMacPdu - The process does not contain entire SDUs" << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc:            throw cRuntimeError("%s::discardMacPdu - MAC PDU ID %d not present for logical CID %d. Aborting", pfmType.c_str(), macPduId, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc:           throw cRuntimeError("%s::macPduArrived - RLC sno [%d] not present in rlcSnoSet structure for MAC PDU ID %d not present for logical CID %d. Aborting", pfmType.c_str(),rlcSno, macPduId, lcid);
./stack/packetFlowManager/PacketFlowManagerUe.cc://        EV << NOW << " " << pfmType.c_str() <<"::insertHarqProcess - Logical CID " << lcid << " not present." << endl;
./stack/packetFlowManager/PacketFlowManagerUe.cc://    // record the associaton MAC PDU - HARQ process only if the MAC PDU contains a RLC PDU that, in turn, contains at least one entire SDU
./stack/packetFlowManager/PacketFlowManagerUe.cc://        EV << NOW << " " << pfmType.c_str() <<"::insertMacPdu - lcid[" << lcid << "], insert MAC PDU " << macPduId << " in HARQ PROCESS " << harqProcId << endl;
./stack/packetFlowManager/PacketFlowManagerUe.h: *  - detect PDCP SDU discarded (no part transmitted)
./stack/packetFlowManager/PacketFlowManagerUe.h: *  - calculate the delay time of a pkt, from PDCP SDU to last Harq ACK of the
./stack/pdcp_rrc/ConnectionsTable.h:     *             - 0xFFFF if no entry was found
./stack/pdcp_rrc/ConnectionsTable.h:     *             - LCID if it was found
./stack/pdcp_rrc/ConnectionsTable.h:     *             - 0xFFFF if no entry was found
./stack/pdcp_rrc/ConnectionsTable.h:     *             - LCID if it was found
./stack/pdcp_rrc/layer/entity/LteRxPdcpEntity.cc:    EV << NOW << " LteRxPdcpEntity::handlePacketFromLowerLayer - LCID[" << lcid_ << "] - processing packet from RLC layer" << endl;
./stack/pdcp_rrc/layer/entity/LteRxPdcpEntity.cc:    EV << NOW << " LteRxPdcpEntity::handlePdcpSdu - processing PDCP SDU with SN[" << controlInfo->getSequenceNumber() << "]" << endl;
./stack/pdcp_rrc/layer/entity/LteTxPdcpEntity.cc:    EV << NOW << " LteTxPdcpEntity::handlePacketFromUpperLayer - LCID[" << lteInfo->getLcid() << "] - processing packet from IP layer" << endl;
./stack/pdcp_rrc/layer/entity/LteTxPdcpEntity.cc:    pkt->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&LteProtocol::pdcp);
./stack/pdcp_rrc/layer/entity/LteTxPdcpEntity.cc:    EV << NOW << " LteTxPdcpEntity::handlePacketFromUpperLayer - LCID[" << lteInfo->getLcid() << "] - sending PDCP PDU to the RLC layer" << endl;
./stack/pdcp_rrc/layer/entity/LteTxPdcpEntity.h: * - mantain numbering of one logical connection
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:    EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - processing PDCP SDU with SN[" << rcvdSno << "]" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - Deliver SDU SN[" << rcvdSno << "] to upper layer" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - the SN[" << rcvdSno << "] <  was already considered for reordering. Discard the SDU" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:    int index = rcvdSno - rxWindowDesc_.rxDeliv_;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - the SN[" << rcvdSno << "] <  is too large with respect to the window size. Advance the window and deliver out-of-sequence SDUs" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - the SN[" << rcvdSno << "] <  has already been received. Discard the SDU" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - Deliver SDU SN[" << rcvdSno << "] to upper layer" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:            EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - Deliver SDU buffered at index[" << pos << "] to upper layer" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - shifting window by " << pos << " positions" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        for (unsigned int i = pos; i < rxWindowDesc_.rxNext_ - rxWindowDesc_.rxDeliv_; ++i)
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        EV << NOW << " NRRxPdcpEntity::handlePdcpSdu - SDU SN[" << rcvdSno << "] received out of sequence. Buffer at index[" << index << "]" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:            int pos = rxWindowDesc_.rxDeliv_ - old;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:                EV << NOW << " NRRxPdcpEntity::handleMessage - Deliver SDU buffered at index[" << pos << "] to upper layer" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        while (received_.at(rxWindowDesc_.rxDeliv_ - old) == true)
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:            EV << NOW << " NRRxPdcpEntity::handleMessage - Deliver SDU buffered at index[" << (rxWindowDesc_.rxDeliv_ - old) << "] to upper layer" << endl;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:            cPacket* sdu = check_and_cast<cPacket*>(sduBuffer_.remove(rxWindowDesc_.rxDeliv_ - old));
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        int offset = rxWindowDesc_.rxDeliv_ - old;
./stack/pdcp_rrc/layer/entity/NRRxPdcpEntity.cc:        EV << NOW << " NRRxPdcpEntity::handleMessage - shifting window by " << offset << " positions" << endl;
./stack/pdcp_rrc/layer/entity/NRTxPdcpEntity.cc:        EV << NOW << " NRTxPdcpEntity::deliverPdcpPdu - LCID[" << lteInfo->getLcid() << "] - send packet to lower layer" << endl;
./stack/pdcp_rrc/layer/entity/NRTxPdcpEntity.cc:                throw cRuntimeError("NRTxPdcpEntity::deliverPdcpPdu - the destination is not a UE but Dual Connectivity is not enabled.");
./stack/pdcp_rrc/layer/entity/NRTxPdcpEntity.cc:            EV << NOW << " NRTxPdcpEntity::deliverPdcpPdu - LCID[" << lteInfo->getLcid() << "] - the destination is a UE. Send packet to lower layer" << endl;
./stack/pdcp_rrc/layer/entity/NRTxPdcpEntity.cc:                    throw cRuntimeError("NRTxPdcpEntity::deliverPdcpPdu - the destination is a UE under the control of a secondary node, but the packet has not been marked as NR packet.");;
./stack/pdcp_rrc/layer/entity/NRTxPdcpEntity.cc:                EV << NOW << " NRTxPdcpEntity::deliverPdcpPdu - LCID[" << lteInfo->getLcid() << "] useNR[" << useNR << "] - the destination is a UE. Send packet to lower layer." << endl;
./stack/pdcp_rrc/layer/entity/NRTxPdcpEntity.cc:                    throw cRuntimeError("NRTxPdcpEntity::deliverPdcpPdu - the packet has been marked as NR packet, but destination is not the secondary node");
./stack/pdcp_rrc/layer/entity/NRTxPdcpEntity.cc:                EV << NOW << " NRTxPdcpEntity::deliverPdcpPdu - LCID[" << lteInfo->getLcid() << "] - the destination is under the control of a secondary node" << endl;
./stack/pdcp_rrc/layer/entity/NRTxPdcpEntity.h: * - mantain numbering of one logical connection
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:            EV_WARN << "LtePdcp : unknown transport header - cannot perform transport header compression";
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:            EV_WARN << "LtePdcp : unknown transport header - cannot perform transport header decompression";
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:    pkt->addTagIfAbsent<PacketProtocolTag>()->setProtocol(&Protocol::ipv4);
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:        if(getParentModule()->findSubmodule("packetFlowManager")!= -1)
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:            EV << "LtePdcpRrcBase::initialize - PacketFlowManager present" << endl;
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:            packetFlowManager_ = check_and_cast<PacketFlowManagerBase *> (getParentModule()->getSubmodule("packetFlowManager"));
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:        if(getParentModule()->findSubmodule("nrPacketFlowManager")!= -1)
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:            EV << "LtePdcpRrcBase::initialize - NRpacketFlowManager present" << endl;
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:            NRpacketFlowManager_ = check_and_cast<PacketFlowManagerBase *> (getParentModule()->getSubmodule("nrPacketFlowManager"));
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:       << pkt->getArrivalGate()->getName() << endl;
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:        EV << "LtePdcpRrcBase::getTxEntity - Added new TxPdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:        EV << "LtePdcpRrcBase::getTxEntity - Using old TxPdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:        EV << "LtePdcpRrcBase::getRxEntity - Added new RxPdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:        EV << "LtePdcpRrcBase::getRxEntity - Using old RxPdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:            (tit->second)->deleteModule();  // Delete Entity
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:            (rit->second)->deleteModule();  // Delete Entity
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:        (tit->second)->deleteModule();  // Delete Entity
./stack/pdcp_rrc/layer/LtePdcpRrc.cc:        (rit->second)->deleteModule();  // Delete Entity
./stack/pdcp_rrc/layer/LtePdcpRrc.h: * - Header compression/decompression
./stack/pdcp_rrc/layer/LtePdcpRrc.h: * - association of the terminal with its eNodeB, thus storing its MacNodeId.
./stack/pdcp_rrc/layer/LtePdcpRrc.h: * - Binding the Local IP Address of this Terminal with
./stack/pdcp_rrc/layer/LtePdcpRrc.h: * - Assign a Logical Connection IDentifier (LCID)
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - On UE use masterId
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - On ENODEB:
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     *   - Use source Ip for directly attached UEs
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - direction is downlink for ENODEB
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - direction is uplink for UE
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - If compression is enabled, header is compressed
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - Reads the source port to determine if a
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     *    - If it was established, sends the packet with the proper CID
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     *    - Otherwise, encapsulates packet in a sap message and sends it
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - decompresses the header, restoring original packet
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - decapsulates the packet
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - sends the packet to the application layer
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - decompresses the header, restoring original packet
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - decapsulates the packet
./stack/pdcp_rrc/layer/LtePdcpRrc.h:     * - sends the PDCP SDU to the IP layer
./stack/pdcp_rrc/layer/LtePdcpRrc.h:    /// Hash Table used for CID <-> Connection mapping
./stack/pdcp_rrc/layer/LtePdcpRrcEnbD2D.cc:        EV << "LtePdcpRrcEnbD2D::handleMessage - Received packet " << pkt->getName() << " from port " << pkt->getArrivalGate()->getName() << endl;
./stack/pdcp_rrc/layer/LtePdcpRrcEnbD2D.cc:    EV << NOW << " LtePdcpRrcEnbD2D::pdcpHandleD2DModeSwitch - peering with UE " << peerId << " set to " << d2dModeToA(newMode) << endl;
./stack/pdcp_rrc/layer/LtePdcpRrcUeD2D.cc:        EV << "LtePdcpRrcUeD2D::handleMessage - Received packet " << pktAux->getName() << " from port " << pktAux->getArrivalGate()->getName() << endl;
./stack/pdcp_rrc/layer/LtePdcpRrcUeD2D.cc:    EV << NOW << " LtePdcpRrcUeD2D::pdcpHandleD2DModeSwitch - peering with UE " << peerId << " set to " << d2dModeToA(newMode) << endl;
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:            dualConnectivityManager_ = check_and_cast<DualConnectivityManager*>(getParentModule()->getSubmodule("dualConnectivityManager"));
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:        EV << NOW << " NRPdcpRrcEnb::fromLowerLayer - forward packet to the master node - id [" << masterId << "]" << endl;
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:        EV << "NRPdcpRrcEnb::getEntity - Added new PdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:        EV << "NRPdcpRrcEnb::getEntity - Using old PdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:        EV << "NRPdcpRrcEnb::getRxEntity - Added new RxPdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:        EV << "NRPdcpRrcEnb::getRxEntity - Using old RxPdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:   EV << NOW << " NRPdcpRrcEnb::forwardDataToTargetNode - Send PDCP packet to node with id " << targetNode << endl;
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:       EV << NOW << " NRPdcpRrcEnb::receiveDataFromSourceNode - Received PDCP PDU from master node with id " << sourceNode << " - destination node[" << destId << "]" << endl;
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.cc:       EV << NOW << " NRPdcpRrcEnb::receiveDataFromSourceNode - Received PDCP PDU from secondary node with id " << sourceNode << endl;
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.h:     * - decompresses the header, restoring original packet
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.h:     * - decapsulates the packet
./stack/pdcp_rrc/layer/NRPdcpRrcEnb.h:     * - sends the packet to the application layer
./stack/pdcp_rrc/layer/NRPdcpRrcUe.cc:        EV << "NRPdcpRrcUe::getEntity - Added new PdcpEntity for Lcid: " << lcid << "\n";
./stack/pdcp_rrc/layer/NRPdcpRrcUe.cc:        EV << "NRPdcpRrcUe::getEntity - Using old PdcpEntity for Lcid: " << lcid << "\n";
./stack/pdcp_rrc/layer/NRPdcpRrcUe.cc:        EV << "NRPdcpRrcUe::getRxEntity - Added new RxPdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/NRPdcpRrcUe.cc:        EV << "NRPdcpRrcUe::getRxEntity - Using old RxPdcpEntity for Cid: " << cid << "\n";
./stack/pdcp_rrc/layer/NRPdcpRrcUe.cc:            (tit->second)->deleteModule();  // Delete Entity
./stack/pdcp_rrc/layer/NRPdcpRrcUe.cc:            (rit->second)->deleteModule();  // Delete Entity
./stack/pdcp_rrc/layer/NRPdcpRrcUe.cc:                EV << "LteTxPdcpEntity::handlePacketFromUpperLayer - notify NRpacketFlowManager_" << endl;
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LtePdcpPdu' as cValue -- field index out of range?", field);
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LtePdcpPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteRohcPdu' as cValue -- field index out of range?", field);
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/pdcp_rrc/packet/LteRohcPdu_m.cc:        field -= base->getFieldCount();
./stack/phy/ChannelModel/LteChannelModel.cc:        componentCarrier_ = check_and_cast<ComponentCarrier*>(getModuleByPath("carrierAggregation")->getSubmodule("componentCarrier", componentCarrierIndex));
./stack/phy/ChannelModel/LteChannelModel.cc:        cModule* cInfo = getParentModule()->getParentModule()->getSubmodule("cellInfo");
./stack/phy/ChannelModel/LteChannelModel.ned:    // Pathloss scenario from ITU -->   
./stack/phy/ChannelModel/LteChannelModel.ned:    // eNodeB height -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Building height -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Target bler used to compute feedback -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // HARQ reduction -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Rank indicator tracefile -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Antenna Gain of UE -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Antenna Gain of eNodeB -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Antenna Gain of Micro node -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Thermal Noise for 10 MHz of Bandwidth -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Ue noise figure -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // eNodeB noise figure -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Cable Loss -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // If true enable the possibility to switch dinamically the LOS/NLOS pathloss computation -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // If dynamic-los is false this parameter, if true, compute LOS pathloss otherwise compute NLOS pathloss -->
./stack/phy/ChannelModel/LteChannelModel.ned:    // Enable/disable fading -->  
./stack/phy/ChannelModel/LteChannelModel.ned:    // Fading type (JAKES or RAYGHLEY) -->  
./stack/phy/ChannelModel/LteChannelModel.ned:    // If jakes fading this parameter specify the number of path (tap channel) -->  
./stack/phy/ChannelModel/LteChannelModel.ned:    // if true, enables the inter-cell interference computation for UL and DL connections from background cells -->  
./stack/phy/ChannelModel/LteChannelModel.ned:    // if true, enables the inter-cell interference computation for DL connections from external cells (maybe this is obsolete and should be removed) -->  
./stack/phy/ChannelModel/LteChannelModel.ned:    // if true, enables the inter-cell interference computation for DL connections -->  
./stack/phy/ChannelModel/LteChannelModel.ned:    // if true, enables the interference computation for UL connections -->
./stack/phy/ChannelModel/LteChannelModel.ned:	// if true, enables the interference computation for D2D connections -->  
./stack/phy/ChannelModel/LteDummyChannelModel.cc:   double totalPer = per_ * pow(harqReduction_, nTx - 1);
./stack/phy/ChannelModel/LteDummyChannelModel.cc:          << ") -> do not receive." << endl;
./stack/phy/ChannelModel/LteDummyChannelModel.cc:      << ") -> Receive AirFrame." << endl;
./stack/phy/ChannelModel/LteDummyChannelModel.cc:   double totalPer = per_ * pow(harqReduction_, nTx - 1);
./stack/phy/ChannelModel/LteDummyChannelModel.cc:          << ") -> do not receive." << endl;
./stack/phy/ChannelModel/LteDummyChannelModel.cc:      << ") -> Receive AirFrame." << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "LteRealisticChannelModel::getAttenuation - computed attenuation at distance " << sqrDistance << " for eNb is " << attenuation << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "LteRealisticChannelModel::getAttenuation - computed attenuation at distance " << sqrDistance << " for UE2 is " << attenuation << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:        throw cRuntimeError("LteRealisticChannelModel::computeShadowing - actualShadowingMap not found (nullptr)");
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    else if ((NOW - actualShadowingMap->at(nodeId).first).dbl() * speed
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:        time = (NOW - actualShadowingMap->at(nodeId).first).dbl();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:        att = a * old + sqrt(1 - pow(a, 2)) * normal(mean, stdDev);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double time = (NOW.dbl()) - (positionHistory_[nodeId].front().first.dbl());
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   relx = point.x - center.x;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   rely = point.y - center.y;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       angle = 180.0 - arcoSen;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       angle = 180.0 - arcoSen;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   //    EV << "computeAngle: angle[" << angle <<"] - arcoSen[" << arcoSen <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   //          "] - relativePos[" << relx << "," << rely <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   //          "] - siny[" << rely/dist << "] - senx[" << relx/dist <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           std::cout << "LteRealisticChannelModel::getSINR - time["<<time<<"] rsrq["<<rsrq<<"]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "------------ GET SINR ----------------" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "LteRealisticChannelModel::getSINR - srcId=" << lteInfo->getSourceId()
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - destId=" << lteInfo->getDestId()
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - DIR=" << (( dir==DL )?"DL" : "UL")
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - frameType=" << ((lteInfo->getFrameType()==FEEDBACKPKT)?"feedback":"other")
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << eNbTypeString << " - txPwr " << lteInfo->getTxPower()
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - ueCoord[" << ueCoord << "] - enbCoord[" << enbCoord << "] - ueId[" << ueId << "] - enbId[" << eNbId << "]" <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "\t using parameters - noiseFigure=" << noiseFigure << " - antennaGainTx=" << antennaGainTx << " - antennaGainRx=" << antennaGainRx <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           " - txPwr=" << lteInfo->getTxPower() << " - for ueId=" << ueId << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= attenuation; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= cableLoss_; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       omnetpp::cModule* eNbModule = getSimulation()->getModule(binder_->getOmnetId(eNbId));
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:          check_and_cast<LtePhyBase*>(eNbModule->getSubmodule("cellularNic")->getSubmodule("phy")) :
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double recvAngle = fabs(txAngle - ueAngle);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               recvAngle = 360 - recvAngle;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           recvPower -= angolarAtt;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           finalRecvPower -= 3;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    * SINR = ---------
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "LteRealisticChannelModel::getSINR - distance from my eNb=" << enbCoord.distance(ueCoord) << " - DIR=" << (( dir==DL )?"DL" : "UL") << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       EV << "\t bgCell[" << bgCellInterference[i] << "] - ext[" << extCellInterference[i] << "] - multi[" << multiCellInterference[i] << "] - recvPwr["
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:          << dBmToLinear(snrVector[i]) << "] - sinr[" << snrVector[i]-den << "]\n";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       snrVector[i] -= den;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       LteChannelModel* ueChannelModel = check_and_cast<LtePhyUe*>(getPhyByMacNodeId(ueId))->getChannelModel(lteInfo->getCarrierFrequency());
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           std::cout << "LteRealisticChannelModel::getRSRP - time["<<time<<"] rsrq["<<rsrq<<"]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "------------ GET SINR ----------------" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "LteRealisticChannelModel::getRSRP - srcId=" << lteInfo->getSourceId()
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - destId=" << lteInfo->getDestId()
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - DIR=" << (( dir==DL )?"DL" : "UL")
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - frameType=" << ((lteInfo->getFrameType()==FEEDBACKPKT)?"feedback":"other")
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << eNbTypeString << " - txPwr " << lteInfo->getTxPower()
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - ueCoord[" << ueCoord << "] - enbCoord[" << enbCoord << "] - ueId[" << ueId << "] - enbId[" << eNbId << "]" <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "\t using parameters - noiseFigure=" << noiseFigure << " - antennaGainTx=" << antennaGainTx << " - antennaGainRx=" << antennaGainRx <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           " - txPwr=" << lteInfo->getTxPower() << " - for ueId=" << ueId << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= attenuation; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= cableLoss_; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       omnetpp::cModule* eNbModule = getSimulation()->getModule(binder_->getOmnetId(eNbId));
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:          check_and_cast<LtePhyBase*>(eNbModule->getSubmodule("cellularNic")->getSubmodule("phy")) :
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double recvAngle = fabs(txAngle - ueAngle);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               recvAngle = 360 - recvAngle;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           recvPower -= angolarAtt;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           finalRecvPower -= 3;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       LteChannelModel* ueChannelModel = check_and_cast<LtePhyUe*>(getPhyByMacNodeId(ueId))->getChannelModel(lteInfo->getCarrierFrequency());
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "------------ GET SINR for background UE ----------------" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "LteRealisticChannelModel::getSINR_bgUe - DIR=" << (( dir==DL )?"DL" : "UL")
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " " << eNbTypeString << " - txPwr " << lteInfo->getTxPower()
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - ueCoord[" << ueCoord << "] - enbCoord[" << enbCoord << "] - enbId[" << eNbId << "]" <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= attenuation; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= cableLoss_; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       omnetpp::cModule* eNbModule = getSimulation()->getModule(binder_->getOmnetId(eNbId));
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:          check_and_cast<LtePhyBase*>(eNbModule->getSubmodule("cellularNic")->getSubmodule("phy")) :
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double recvAngle = fabs(txAngle - ueAngle);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               recvAngle = 360 - recvAngle;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           recvPower -= angolarAtt;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           finalRecvPower -= 3;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    * SINR = ---------
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       EV << "\t bgCell[" << bgCellInterference[i] << "] - ext[" << extCellInterference[i] << "] - multi[" << multiCellInterference[i] << "] - recvPwr["
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:          << dBmToLinear(snrVector[i]) << "] - sinr[" << snrVector[i]-den << "]\n";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       snrVector[i] -= den;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    EV << "LteRealisticChannelModel::getReceivedPower_bgUe - DIR=" << (( dir==DL )?"DL" : "UL")
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                       << " - txPwr " << txPower << " - txPos[" << txPos << "] - rxPos[" << rxPos << "] " << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    double recvPower = txPower - attenuation; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    recvPower -= cableLoss_; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:        omnetpp::cModule* bsModule = getSimulation()->getModule(binder_->getOmnetId(bsId));
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:        LtePhyBase* phy = bsModule ? check_and_cast<LtePhyBase*>(bsModule->getSubmodule("cellularNic")->getSubmodule("phy")) : nullptr;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:            double recvAngle = fabs(txAngle - ueAngle);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                recvAngle = 360 - recvAngle;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:            recvPower -= angolarAtt;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "------------ GET RSRP D2D----------------" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "LteRealisticChannelModel::getRSRP_D2D - srcId=" << sourceId
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - destId=" << destId
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - DIR=" << dirToA(dir)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - frameType=" << ((lteInfo_1->getFrameType()==FEEDBACKPKT)?"feedback":"other")
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - txPwr " << recvPower
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - ue1_Coord[" << sourceCoord << "] - ue2_Coord[" << destCoord << "] - ue1_Id[" << sourceId << "] - ue2_Id[" << destId << "]" <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "\t using parameters - noiseFigure=" << noiseFigure << " - antennaGainTx=" << antennaGainTx << " - antennaGainRx=" << antennaGainRx <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   " - txPwr=" << recvPower << " - for ueId=" << sourceId << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= attenuation; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= cableLoss_; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           finalRecvPower -= 3;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "------------ GET SINR D2D ----------------" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "LteRealisticChannelModel::getSINR_d2d - srcId=" << sourceId
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - destId=" << destId
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - DIR=" << dirToA(dir)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - frameType=" << ((lteInfo->getFrameType()==FEEDBACKPKT)?"feedback":"other")
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - txPwr " << recvPower
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - ue1_Coord[" << sourceCoord << "] - ue2_Coord[" << destCoord << "] - ue1_Id[" << sourceId << "] - ue2_Id[" << destId << "]" <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "\t using parameters - noiseFigure=" << noiseFigure << " - antennaGainTx=" << antennaGainTx << " - antennaGainRx=" << antennaGainRx <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   " - txPwr=" << recvPower << " - for ueId=" << sourceId << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= attenuation; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   recvPower -= cableLoss_; // (dBm-dB)=dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           finalRecvPower -= 3;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    * SINR = ---------
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    * following direction D2D_Tx--->D2D_Rx or D2D_Tx<---D2D_Rx (This happens due to the different positions of the
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << "LteRealisticChannelModel::getSINR - distance from my Peer = " << destCoord.distance(sourceCoord) << " - DIR=" << dirToA(dir)  << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               EV << "\t ext[" << extCellInterference << "] - in[" << d2dInterference[i] << "] - recvPwr["
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                       << dBmToLinear(snrVector[i]) << "] - sinr[" << snrVector[i]-den << "]\n";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               snrVector[i] -= den;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           snrVector[i] -=  (noiseFigure + thermalNoise_);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << "LteRealisticChannelModel::getSINR_d2d - distance from my Peer = " << destCoord.distance(sourceCoord) << " - DIR=" << dirToA(dir) << " - snr[" << snrVector[i] << "]\n";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "------------ GET SINR D2D----------------" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    * SINR = ---------
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:    * following direction D2D_Tx--->D2D_Rx or D2D_Tx<---D2D_Rx (This happens due to the different positions of the
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << "LteRealisticChannelModel::getSINR - distance from my Peer = " << destCoord.distance(sourceCoord) << " - DIR=" << dirToA(dir)  << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               EV << "\t ext[" << extCellInterference << "] - in[" << d2dInterference[i] << "] - recvPwr["
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                       << dBmToLinear(snrVector[i]) << "] - sinr[" << snrVector[i]-den << "]\n";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               snrVector[i] -= den;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           snrVector[i] -=  (noiseFigure + thermalNoise_);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << "LteRealisticChannelModel::getSINR_D2D - distance from my Peer = " << destCoord.distance(sourceCoord) << " - DIR=" << dirToA(dir) << " - snr[" << snrVector[i] << "]\n";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           finalSnr -= 3;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           getCellInfo(id)->getLambda(id)->channelIndex + band);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   simtime_t t = simTime().dbl() - 0.001;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       double phi = 2.00 * M_PI * (phi_d * t.dbl() - phi_i);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       im_h = im_h - attenuation * sin(phi);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       //        EV << "ID=" << nodeId << " - t[" << t << "] - dopplerShift[" << doppler_shift << "] - phiD[" <<
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       //                phi_d << "] - phiI[" << phi_i << "] - phi[" << phi << "] - attenuation[" << attenuation << "] - f["
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       //                << f << "] - Band[" << band << "] - cos(phi)["
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   int size = lteInfo->getUserTxParams()->readCqiVector().size();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   Cqi cqi = lteInfo->getUserTxParams()->readCqiVector()[cw];
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               bler = binder_->phyPisaData.getBler(itxmode, cqi - 1, snr);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << "\t bler computation: [itxMode=" << itxmode << "] - [cqi-1=" << cqi-1
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   << "] - [snr=" << snr << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double success = 1 - bler;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double per = 1 - finalSuccess;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double totalPer = per * pow(harqReduction_, nTx - 1);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                      << " - CQI[" << cqi << "]- random error extracted[" << er << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           LteChannelModel* ueChannelModel = check_and_cast<LtePhyUe*>(getPhyByMacNodeId(id))->getChannelModel(lteInfo->getCarrierFrequency());
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               << ") -> do not receive." << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           << ") -> Receive AirFrame." << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   int size = lteInfo->getUserTxParams()->readCqiVector().size();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   Cqi cqi = lteInfo->getUserTxParams()->readCqiVector()[cw];
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   //ROSSALI-------END------------------------------------------------
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   bler = binder_->phyPisaData.getBler(itxmode, cqi - 1, snr);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << "\t bler computation: [itxMode=" << itxmode << "] - [cqi-1=" << cqi-1
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:              << "] - [snr=" << snr << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double success = 1 - bler;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double per = 1 - finalSuccess;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double totalPer = per * pow(harqReduction_, nTx - 1);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:      << " - CQI[" << cqi << "]- random error extracted[" << er << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       EV << "This is NOT your lucky day (" << er << " < " << totalPer << ") -> do not receive." << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << "This is your lucky day (" << er << " > " << totalPer << ") -> Receive AirFrame." << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           p = exp((-1) * ((d - 18) / 27));
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       p = (((18 / d) > 1) ? 1 : 18 / d) * (1 - exp(-1 * d / 36))
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       p = (((18 / d) > 1) ? 1 : 18 / d) * (1 - exp(-1 * d / 36))
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           p = exp(-1 * (d - 10) / 200);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           p = exp(-1 * (d - 10) / 1000);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double dbp = 4 * (hNodeB_ - 1) * (hUe_ - 1)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           return 40 * log10(d) + 7.8 - 18 * log10(hNodeB_ - 1)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       - 18 * log10(hUe_ - 1) + 2 * log10(carrierFrequency_);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double dbp = 4 * (hNodeB_ - 1) * (hUe_ - 1)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           return 40 * log10(d) + 7.8 - 18 * log10(hNodeB_ - 1)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       - 18 * log10(hUe_ - 1) + 2 * log10(carrierFrequency_);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double att = 161.04 - 7.1 * log10(wStreet_) + 7.5 * log10(hBuilding_)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   - (24.37 - 3.7 * pow(hBuilding_ / hNodeB_, 2)) * log10(hNodeB_)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   + (43.42 - 3.1 * log10(hNodeB_)) * (log10(d) - 3)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   - (3.2 * (pow(log10(11.75 * hUe_), 2)) - 4.97);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   dbp = 4 * (hNodeB_ - 1) * (hUe_ - 1)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           return primo + secondo - b + quarto;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       + a * log10(dbp) - b + 0.002 * log10(hBuilding_) * dbp
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double att = 161.04 - 7.1 * log10(wStreet_) + 7.5 * log10(hBuilding_)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   - (24.37 - 3.7 * pow(hBuilding_ / hNodeB_, 2)) * log10(hNodeB_)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   + (43.42 - 3.1 * log10(hNodeB_)) * (log10(d) - 3)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   - (3.2 * (pow(log10(11.75 * hUe_), 2)) - 4.97);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   dbp = 4 * (hNodeB_ - 1) * (hUe_ - 1)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       + a * log10(d) - b + 0.002 * log10(hBuilding_) * d;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       + a * log10(dbp) - b + 0.002 * log10(hBuilding_) * dbp
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   double att = 161.04 - 7.1 * log10(wStreet_) + 7.5 * log10(hBuilding_)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   - (24.37 - 3.7 * pow(hBuilding_ / hNodeB_, 2)) * log10(hNodeB_)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   + (43.42 - 3.1 * log10(hNodeB_)) * (log10(d) - 3)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   - (3.2 * (pow(log10(11.75 * hUe_), 2)) - 4.97);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       c = (*it)->getPosition();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               "] and extCell[" << c.x << "," << c.y << "] is -> "
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       if ((*it)->getTxDirection() == OMNI)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double recvAngle = fabs((*it)->getTxAngle() - ueAngle);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               recvAngle = 360 - recvAngle;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       // TODO do we need to use (- cableLoss_ + antennaGainEnB_) in ext cells too?
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       recvPwrDBm = (*it)->getTxPower() - att - angolarAtt - cableLoss_ + antennaGainEnB_ + antennaGainUe_;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       unsigned int numBands = std::min(numBands_, (*it)->getNumBands());
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       EV << " - shared bands [" << numBands << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               occ = (*it)->getBandStatus(i);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               occ = (*it)->getPrevBandStatus(i);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           c = (*it)->getPosition();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   "] and backgroundCell[" << c.x << "," << c.y << "] is -> "
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           txPwr = (*it)->getTxPower();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           if ((*it)->getTxDirection() == OMNI)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               double recvAngle = fabs((*it)->getTxAngle() - ueAngle);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   recvAngle = 360 - recvAngle;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           // TODO do we need to use (- cableLoss_ + antennaGainEnB_) in ext cells too?
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           recvPwrDBm = txPwr - att - angolarAtt - cableLoss_ + antennaGainEnB_ + antennaGainUe_;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           unsigned int numBands = std::min(numBands_, (*it)->getNumBands());
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << " - shared bands [" << numBands << "]\t";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << " - interfering bands[";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   occ = (*it)->getBandStatus(i, DL);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   occ = (*it)->getPrevBandStatus(i, DL);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           unsigned int numBands = std::min(numBands_, (*it)->getNumBands());
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           EV << " - shared bands [" << numBands << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   occ = (*it)->getBandStatus(i, UL);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                       bgUe = (*it)->getBandInterferingUe(i);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   occ = (*it)->getPrevBandStatus(i, UL);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                       bgUe = (*it)->getPrevBandInterferingUe(i);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                           "] and backgroundUE[" << c.x << "," << c.y << "] is -> "
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   recvPwrDBm = txPwr - att - angolarAtt - cableLoss_ + antennaGainEnB_ + antennaGainBgUe;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   //    EV << "LteRealisticChannelModel::computeExtCellPathLoss:" << scenario_ << "-" << shadowing_ << "\n";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc://       //        if ((NOW - lastComputedSF_.at(nodeId).first).dbl() * speed > correlationDistance_)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc://       //            time = (NOW - lastComputedSF_.at(nodeId).first).dbl();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc://       //            att = a * old + sqrt(1 - pow(a, 2)) * normal(getEnvir()->getRNG(0), mean, stdDev);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:        throw cRuntimeError("LteRealisticChannelModel::obtainUeJakesMap - channel model is a null pointer. Abort.");
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       MacNodeId id = (*it)->id;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       if(!(*it)->init)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           (*it)->phy = check_and_cast<LtePhyBase*>(getSimulation()->getModule(binder_->getOmnetId(id))->getSubmodule("cellularNic")->getSubmodule("phy"));
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           (*it)->txPwr = (*it)->phy->getTxPwr();//dBm
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           (*it)->txDirection = (*it)->phy->getTxDirection();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           (*it)->txAngle = (*it)->phy->getTxAngle();
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           (*it)->mac = check_and_cast<LteMacEnb*>(getMacByMacNodeId(id));
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           (*it)->init = true;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       LteRealisticChannelModel* interfChanModel = dynamic_cast<LteRealisticChannelModel *>((*it)->phy->getChannelModel(carrierFrequency));
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       EV << "EnbId [" << id << "] - attenuation [" << att << "]";
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       if ((*it)->txDirection == ANISOTROPIC)
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double txAngle = (*it)->txAngle;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:           double recvAngle = fabs(txAngle - ueAngle);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               recvAngle = 360 - recvAngle;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       txPwr = (*it)->txPwr - angolarAtt - cableLoss_ + antennaGainEnB_ + antennaGainUe_;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:       EV << " - shared bands [" << numBands << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               temp = (*it)->mac->getDlBandStatus(i);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:               temp = (*it)->mac->getDlPrevBandStatus(i);
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   EV<<NOW<<" LteRealisticChannelModel::computeUplinkInterference - Interference from UE: "<< ueId << "(dir " << dirToA(dir) << ") on band[" << i << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   double rxPwr = txPwr - cableLoss_ + antennaGainUe_ + antennaGainEnB_;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   EV<<NOW<<" LteRealisticChannelModel::computeUplinkInterference - Interference from UE: "<< ueId << "(dir " << dirToA(dir) << ") on band[" << i << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   double rxPwr = txPwr - cableLoss_ + antennaGainUe_ + antennaGainEnB_;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << NOW << " LteRealisticChannelModel::computeUplinkInterference - Final Band Interference Status: "<<endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   EV<<NOW<<" LteRealisticChannelModel::computeD2DInterference - Interference from UE: "<< ueId << "(dir " << dirToA(dir) << ") on band[" << i << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   double rxPwr = txPwr - cableLoss_ + 2 * antennaGainUe_;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   EV<<NOW<<" LteRealisticChannelModel::computeD2DInterference - Interference from UE: "<< ueId << "(dir " << dirToA(dir) << ") on band[" << i << "]" << endl;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:                   double rxPwr = txPwr - cableLoss_ + 2 * antennaGainUe_;
./stack/phy/ChannelModel/LteRealisticChannelModel.cc:   EV << NOW << " LteRealisticChannelModel::computeD2DInterference - Final Band Interference Status: "<<endl;
./stack/phy/ChannelModel/NRChannelModel.cc:   EV << "NRChannelModel::getAttenuation - computed attenuation at distance " << threeDimDistance << " for eNb is " << attenuation << endl;
./stack/phy/ChannelModel/NRChannelModel.cc:    // --- compute horizontal pattern attenuation --- //
./stack/phy/ChannelModel/NRChannelModel.cc:    // --- compute vertical pattern attenuation --- //
./stack/phy/ChannelModel/NRChannelModel.cc:    double vAngolarAtt = 12 * pow( (vAngle - vTilt) / 65.0, 2);
./stack/phy/ChannelModel/NRChannelModel.cc:           p = (18 / d) + exp(-1 * d / 36) * (1 - (18 / d));
./stack/phy/ChannelModel/NRChannelModel.cc:           p = ( (18 / d) + exp(-1 * d / 63) * (1 - (18 / d)) ) * ( 1 + C * (5.0/4.0) * pow(d/100.0,3) * exp(-1 * d/150.0) );
./stack/phy/ChannelModel/NRChannelModel.cc:           p = exp(-1 * (d - 10) / 1000);
./stack/phy/ChannelModel/NRChannelModel.cc:   double hNodeB = hNodeB_ - 1.0;
./stack/phy/ChannelModel/NRChannelModel.cc:   double hUe = hUe_ - 1.0;
./stack/phy/ChannelModel/NRChannelModel.cc:       pLoss_los = 40 * log10(threeDimDistance) + 28 + 20 * log10(carrierFrequency_) - 9 * log10( (dbp * dbp + (hNodeB_ - hUe_) * (hNodeB_ - hUe_) ) );
./stack/phy/ChannelModel/NRChannelModel.cc:           + 26 * log10(carrierFrequency_) - 0.3 * (hUe_ - 1.5);
./stack/phy/ChannelModel/NRChannelModel.cc:           pLoss_tw = 5 - 10 * log10( 0.7 * pow(10,(-Lglass/10)) + 0.7 * pow(10,(-Lconcrete/10)) ) + normal(0.0,4.4);
./stack/phy/ChannelModel/NRChannelModel.cc:       double bound = hUe_ - 1.5;
./stack/phy/ChannelModel/NRChannelModel.cc:   double hNodeB = hNodeB_ - hEnvir;
./stack/phy/ChannelModel/NRChannelModel.cc:   double hUe = hUe_ - hEnvir;
./stack/phy/ChannelModel/NRChannelModel.cc:       pLoss_los = 40 * log10(threeDimDistance) + 28 + 20 * log10(carrierFrequency_) - 9 * log10( (dbp * dbp + (hNodeB_ - hUe_) * (hNodeB_ - hUe_) ) );
./stack/phy/ChannelModel/NRChannelModel.cc:   double pLoss_nlos = 161.04 - 7.1 * log10(wStreet_) + 7.5 * log10(hBuilding_)
./stack/phy/ChannelModel/NRChannelModel.cc:   - (24.37 - 3.7 * pow(hBuilding_ / hNodeB_, 2)) * log10(hNodeB_)
./stack/phy/ChannelModel/NRChannelModel.cc:   + (43.42 - 3.1 * log10(hNodeB_)) * (log10(threeDimDistance) - 3) + 20 * log10(carrierFrequency_)
./stack/phy/ChannelModel/NRChannelModel.cc:   - (3.2 * (pow(log10(17.625), 2)) - 4.97) - 0.6 * (hUe_ - 1.5);
./stack/phy/ChannelModel/NRChannelModel.cc:                   + a * log10(threeDimDistance) - b + 0.002 * log10(hBuilding_) * threeDimDistance;
./stack/phy/ChannelModel/NRChannelModel.cc:                   + a * log10(dbp) - b + 0.002 * log10(hBuilding_) * dbp
./stack/phy/ChannelModel/NRChannelModel.cc:    double pLoss_nlos = 161.04 - 7.1 * log10(wStreet_) + 7.5 * log10(hBuilding_)
./stack/phy/ChannelModel/NRChannelModel.cc:                 - (24.37 - 3.7 * pow(hBuilding_ / hNodeB_, 2)) * log10(hNodeB_)
./stack/phy/ChannelModel/NRChannelModel.cc:                 + (43.42 - 3.1 * log10(hNodeB_)) * (log10(threeDimDistance) - 3) + 20 * log10(carrierFrequency_)
./stack/phy/ChannelModel/NRChannelModel.cc:                 - (3.2 * (pow(log10(11.75 * hUe_), 2)) - 4.97);
./stack/phy/ChannelModel/NRChannelModel.cc:       c = (*it)->getPosition();
./stack/phy/ChannelModel/NRChannelModel.cc:               "] and extCell[" << c.x << "," << c.y << "] is -> "
./stack/phy/ChannelModel/NRChannelModel.cc:       if ((*it)->getTxDirection() == OMNI)
./stack/phy/ChannelModel/NRChannelModel.cc:           double recvAngle = fabs((*it)->getTxAngle() - ueAngle);
./stack/phy/ChannelModel/NRChannelModel.cc:               recvAngle = 360 - recvAngle;
./stack/phy/ChannelModel/NRChannelModel.cc:       // TODO do we need to use (- cableLoss_ + antennaGainEnB_) in ext cells too?
./stack/phy/ChannelModel/NRChannelModel.cc:       recvPwrDBm = (*it)->getTxPower() - att - angolarAtt - cableLoss_ + antennaGainEnB_ + antennaGainUe_;
./stack/phy/ChannelModel/NRChannelModel.cc:       int numBands = std::min(numBands_, (*it)->getNumBands());
./stack/phy/ChannelModel/NRChannelModel.cc:       EV << " - shared bands [" << numBands << "]" << endl;
./stack/phy/ChannelModel/NRChannelModel.cc:               occ = (*it)->getBandStatus(i);
./stack/phy/ChannelModel/NRChannelModel.cc:               occ = (*it)->getPrevBandStatus(i);
./stack/phy/ChannelModel/NRChannelModel.cc:   //    EV << "LteRealisticChannelModel::computeExtCellPathLoss:" << scenario_ << "-" << shadowing_ << "\n";
./stack/phy/ChannelModel/NRChannelModel.cc:       //        if ((NOW - lastComputedSF_.at(nodeId).first).dbl() * speed > correlationDistance_)
./stack/phy/ChannelModel/NRChannelModel.cc:       //            time = (NOW - lastComputedSF_.at(nodeId).first).dbl();
./stack/phy/ChannelModel/NRChannelModel.cc:       //            att = a * old + sqrt(1 - pow(a, 2)) * normal(getEnvir()->getRNG(0), mean, stdDev);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:            p = (18.0 / d) + exp(-1 * d / 36.0) * (1.0 - (18.0 / d));
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:           p = ( (18 / d) + exp(-1 * d / 63) * (1 - (18 / d)) ) * ( 1 + C * (5.0/4.0) * pow(d/100.0,3) * exp(-1 * d/150.0) );
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:            p = exp(-1 * (d - 10.0) / 1000);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:               p = exp(-1 * (d - 5.0) / 70.8);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:               p = exp(-1 * (d - 49.0) / 211.7);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:            pLoss_tw = 5 - 10 * log10( 0.7 * pow(10,(-Lglass/10)) + 0.3 * pow(10,(-Lconcrete/10)) ) + normal(0.0,4.4);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:            pLoss_tw = 5 - 10 * log10( 0.3 * pow(10,(-LiirGlass/10)) + 0.7 * pow(10,(-Lconcrete/10)) ) + normal(0.0,6.5);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:       double bound = hUe_ - 1.5;
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:   double hNodeB = hNodeB_ - hEnvir;
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:   double hUe = hUe_ - hEnvir;
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:       pLoss_los = 28 + 40 * log10(threeDimDistance) + 20 * log10(carrierFrequency_) - 9 * log10( (dbp * dbp + (hNodeB_ - hUe_) * (hNodeB_ - hUe_) ) );
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:       double pLoss_nlos = 13.54 + 39.08 * log10(threeDimDistance) + 20 * log10(carrierFrequency_) - 0.6 * (hUe_ - 1.5);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:   double hNodeB = hNodeB_ - hEnvir;
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:   double hUe = hUe_ - hEnvir;
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:       pLoss_los = 32.4 + 40 * log10(threeDimDistance) + 20 * log10(carrierFrequency_) - 9.5 * log10( (dbp * dbp + (hNodeB_ - hUe_) * (hNodeB_ - hUe_) ) );
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:       double pLoss_nlos = 35.3 * log10(threeDimDistance) + 22.4 + 21.3 * log10(carrierFrequency_) - 0.3 * (hUe_ - 1.5);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:       pLoss_los = 20 * log10(40 * M_PI * threeDimDistance * (carrierFrequency_ / 3.0)) + min1 * log10(threeDimDistance) - min2 + 0.002 * log10(h) * threeDimDistance;
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:       pLoss_los = 20 * log10(40 * M_PI * dbp * (carrierFrequency_ / 3.0)) + min1 * log10(dbp) - min2 + 0.002 * log10(h) * dbp
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:       double pLoss_nlos = 161.04 - 7.1 * log10(W) + 7.5 * log10(h) - (24.37 - 3.7 * pow(h/hNodeB_,2)) * log10(hNodeB_)
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:               + (43.42 - 3.1 * log10(hNodeB_)) * (log10(threeDimDistance) - 3.0) + 20 * log10(carrierFrequency_)
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:               - (3.2 * pow((log10(11.75 * hUe_)),2) - 4.97);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:        throw cRuntimeError("NRChannelModel_3GPP38_901::computeShadowing - actualShadowingMap not found (nullptr)");
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:    else if ((NOW - actualShadowingMap->at(nodeId).first).dbl() * speed
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:        time = (NOW - actualShadowingMap->at(nodeId).first).dbl();
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:        att = a * old + sqrt(1 - pow(a, 2)) * normal(mean, stdDev);
./stack/phy/ChannelModel/NRChannelModel_3GPP38_901.cc:    EV <<  " NRChannelModel_3GPP38_901::computeShadowing - shadowing att = " << att << endl;
./stack/phy/das/DasFilter.cc:    cModule* module = getSimulation()->getModule(binder_->getOmnetId(masterId));
./stack/phy/das/DasFilter.cc:        das_ = check_and_cast<LtePhyEnb*>(module->getSubmodule("cellularNic")->getSubmodule("phy"))->getDasFilter();
./stack/phy/das/DasFilter.cc:            throw cRuntimeError("DasFilter::receiveBroadcast - channel model is a null pointer. Abort.");
./stack/phy/das/DasFilter.h: * - Report Set handling (for LteFeedback).
./stack/phy/das/DasFilter.h: * - Remote Antenna Set Physical Properties (for LtePhy)
./stack/phy/das/DasFilter.h: * - eNodeB:
./stack/phy/das/DasFilter.h: *   - Stores the Remote Antenna Set (provided by the cellInfo at startup)
./stack/phy/das/DasFilter.h: * - On UEs attached to eNodeBs:
./stack/phy/das/DasFilter.h: *   - Retrieves the Remote Antenna Set from the master
./stack/phy/das/DasFilter.h: *   - Reads broadcast packet to find out which Antennas
./stack/phy/das/DasFilter.h:     * - For each antenna in the master remote set,
./stack/phy/das/DasFilter.h:     * - If the distance is below a threshold, it is added
./stack/phy/das/DasFilter.h:     * - If the UE is attached to a relay sets the RAS to NULL
./stack/phy/das/DasFilter.h:     * - Otherwise it calls the getRemoteAntennaSet of the master
./stack/phy/feedback/LteDlFeedbackGenerator.cc:        fbPeriod_ = (simtime_t)(int(par("fbPeriod")) * TTI);// TTI -> seconds
./stack/phy/feedback/LteDlFeedbackGenerator.cc:        fbDelay_ = (simtime_t)(int(par("fbDelay")) * TTI);// TTI -> seconds
./stack/phy/feedback/LteDlFeedbackGenerator.cc:            tmp = dynamic_cast<LtePhyUe*>(getParentModule()->getSubmodule("nrPhy"));
./stack/phy/feedback/LteDlFeedbackGenerator.cc:            tmp = dynamic_cast<LtePhyUe*>(getParentModule()->getSubmodule("phy"));
./stack/phy/feedback/LteDlFeedbackGenerator.cc:    EV << "DLFeedbackGenerator - nodeid: " << nodeId_ << " cellInfo taken" << endl;
./stack/phy/feedback/LteDlFeedbackGenerator.cc:        throw cRuntimeError("LteDlFeedbackGenerator::initCellInfo - cellInfo is NULL pointer. Aborting");
./stack/phy/feedback/LteDlFeedbackGenerator.cc:    EV << "DLFeedbackGenerator - nodeid: " << nodeId_
./stack/phy/feedback/LteDlFeedbackGenerator.cc:        (dynamic_cast<LtePhyUe*>(getParentModule()->getSubmodule("nrPhy")))->sendFeedback(fb, fb, feedbackReq);
./stack/phy/feedback/LteDlFeedbackGenerator.cc:        (dynamic_cast<LtePhyUe*>(getParentModule()->getSubmodule("phy")))->sendFeedback(fb, fb, feedbackReq);
./stack/phy/feedback/LteDlFeedbackGenerator.cc:        EV << NOW << " LteDlFeedbackGenerator::handleHandover - Master ID updated to " << masterId_ << endl;
./stack/phy/feedback/LteFeedback.cc:    EV << NOW << " " << s << " -------------------------\n";
./stack/phy/feedback/LteFeedback.cc:    EV << NOW << " " << s << " -------------------------\n";
./stack/phy/feedback/LteFeedback.h:    //! \test DAS SUPPORT - Antenna identifier
./stack/phy/feedback/LteFeedback.h:    //! \test DAS support - Get the remote Antenna identifier
./stack/phy/feedback/LteFeedback.h:    //! \test DAS support - Set the remote Antenna identifier
./stack/phy/feedback/LteFeedback.h:        return node - UE_MIN_ID;
./stack/phy/feedback/LteFeedbackComputationRealistic.cc:    phyPisaData_ = &(getBinder()->phyPisaData);
./stack/phy/feedback/LteFeedbackComputationRealistic.cc:        double diff = targetBler_ - tmp;
./stack/phy/feedback/LteFeedbackComputationRealistic.cc:        for (int z = 0; z < DL_NUM_TXMODE - 1; z++)
./stack/phy/feedback/LteFeedbackComputationRealistic.cc:                fb.setWideBandPmi(intuniform(getEnvir()->getRNG(0), 1, pow(rank, (double) 2)));
./stack/phy/feedback/LteFeedbackComputationRealistic.cc:            fb.setWideBandPmi(intuniform(getEnvir()->getRNG(0), 1, pow(rank, (double) 2)));
./stack/phy/feedback/LteFeedbackComputationRealistic.cc:        fb.setWideBandPmi(intuniform(getEnvir()->getRNG(0), 1, pow(rank, (double) 2)));
./stack/phy/feedback/LteSummaryFeedback.cc:    simtime_t delta = simTime() - creationTime;
./stack/phy/feedback/LteSummaryFeedback.cc:            - (delta - confidenceLowerBound_)
./stack/phy/feedback/LteSummaryFeedback.cc:                    / (confidenceUpperBound_ - confidenceLowerBound_));
./stack/phy/feedback/LteSummaryFeedback.cc:        EV << NOW << " " << s << " -------------------------\n";
./stack/phy/feedback/testFeedback/FeedbackTester.cc:    generator_ = check_and_cast<LteDlFeedbackGenerator*>(getSimulation()->getModuleByPath("lteDlFbGenerator"));
./stack/phy/layer/LtePhyBase.cc:    EV << " LtePhyBase::handleMessage - new message received" << endl;
./stack/phy/layer/LtePhyBase.cc:    else if (msg->getArrivalGate()->getId() == radioInGate_)
./stack/phy/layer/LtePhyBase.cc:    else if (msg->getArrivalGate()->getId() == upperGateIn_)
./stack/phy/layer/LtePhyBase.cc:    frame->setControlInfo(lteInfo.get()->dup());
./stack/phy/layer/LtePhyBase.cc:    primaryChannelModel_ = check_and_cast<LteChannelModel*>(getParentModule()->getSubmodule(moduleName.c_str(),0));
./stack/phy/layer/LtePhyBase.cc:        chanModel = check_and_cast<LteChannelModel*>(getParentModule()->getSubmodule(moduleName.c_str(),index));
./stack/phy/layer/LtePhyBase.cc:        getSimulation()->getModule(omid)->getSubmodule("cellularNic")->getSubmodule(
./stack/phy/layer/LtePhyBase.cc:            "mac"))->getAmc();
./stack/phy/layer/LtePhyBase.cc:        throw cRuntimeError("LtePhyBase::sendMulticast - Error. Group ID %d is not valid.", groupId);
./stack/phy/layer/LtePhyBase.cc:            EV << NOW << " LtePhyBase::sendMulticast - node " << destId << " is in the multicast group"<< endl;
./stack/phy/layer/LtePhyBase.cc:            cModule *receiver = getSimulation()->getModule(nodeIt->second);
./stack/phy/layer/LtePhyBase.cc:                recvPhy =  (isNrUe(destId)) ? check_and_cast<LtePhyBase *>(receiver->getSubmodule("cellularNic")->getSubmodule("nrPhy"))
./stack/phy/layer/LtePhyBase.cc:                                  : check_and_cast<LtePhyBase *>(receiver->getSubmodule("cellularNic")->getSubmodule("phy"));
./stack/phy/layer/LtePhyBase.cc:                    EV << NOW << " LtePhyBase::sendMulticast - node too far (" << dist << " > " << multicastD2DRange_ << ". skipping transmission" << endl;
./stack/phy/layer/LtePhyBase.cc:            EV << NOW << " LtePhyBase::sendMulticast - sending frame to node " << destId << endl;
./stack/phy/layer/LtePhyBase.cc:    cModule *receiver = getSimulation()->getModule(destOmnetId);
./stack/phy/layer/LtePhyBase.h:                return channelModel_.begin()->second;
./stack/phy/layer/LtePhyBase.h:     * - If airframe is a broadcast/feedback packet and host is
./stack/phy/layer/LtePhyBase.h:     * - If airframe is received by a UE attached to a Relay
./stack/phy/layer/LtePhyBase.h:     * - If airframe is received by eNodeB it performs a loop over
./stack/phy/layer/LtePhyBase.h:     * - If airframe is received by UE attached to eNB it performs a loop over
./stack/phy/layer/LtePhyEnb.cc:        EV << "LtePhyEnb::handleAirFrame - received handover packet from another eNodeB. Ignore it." << endl;
./stack/phy/layer/LtePhyEnb.cc:    int sourceId = getBinder()->getOmnetId(connectedNodeId_);
./stack/phy/layer/LtePhyEnb.cc:    int senderId = getBinder()->getOmnetId(lteInfo->getDestId());
./stack/phy/layer/LtePhyEnb.cc:    RemoteSet r = lteInfo->getUserTxParams()->readAntennaSet();
./stack/phy/layer/LtePhyEnb.cc:    if (getEnvir()->isGUI())
./stack/phy/layer/LtePhyEnb.cc:        throw cRuntimeError("LtePhyEnbD2D::requestFeedback - channelModel is null pointer. Abort");
./stack/phy/layer/LtePhyEnb.cc:            //Prepare  parameters for next loop iteration - in order to compute SNR in DL
./stack/phy/layer/LtePhyEnb.cc:                throw cRuntimeError("LtePhyEnbD2D::requestFeedback - channelModel is null pointer. Abort");
./stack/phy/layer/LtePhyEnbD2D.cc:        throw cRuntimeError("LtePhyEnbD2D::requestFeedback - channelModel is null pointer. Abort");
./stack/phy/layer/LtePhyEnbD2D.cc:            //Prepare  parameters for next loop iteration - in order to compute SNR in DL
./stack/phy/layer/LtePhyEnbD2D.cc:                throw cRuntimeError("LtePhyEnbD2D::requestFeedback - channelModel is null pointer. Abort");
./stack/phy/layer/LtePhyEnbD2D.cc:                    MacNodeId peerId = (*it)->id;
./stack/phy/layer/LtePhyEnbD2D.cc:                         Coord peerCoord = (*it)->phy->getCoord();
./stack/phy/layer/LtePhyEnbD2D.cc:                             throw cRuntimeError("LtePhyEnbD2D::requestFeedback - channelModel is null pointer. Abort");
./stack/phy/layer/LtePhyEnbD2D.cc:    EV << "LtePhyEnbD2D::handleAirFrame - received new LteAirFrame with ID " << frame->getId() << " from channel" << endl;
./stack/phy/layer/LtePhyEnbD2D.cc:        EV << "LtePhyEnbD2D::handleAirFrame - received handover packet from another eNodeB. Ignore it." << endl;
./stack/phy/layer/LtePhyEnbD2D.cc:    // Check if the frame is for us ( MacNodeId matches or - if this is a multicast communication - enrolled in multicast group)
./stack/phy/layer/LtePhyEnbD2D.cc:    RemoteSet r = lteInfo->getUserTxParams()->readAntennaSet();
./stack/phy/layer/LtePhyEnbD2D.cc:    if (getEnvir()->isGUI())
./stack/phy/layer/LtePhyUe.cc:        handoverAttachment_ = handoverLatency_ - handoverDetachment_;
./stack/phy/layer/LtePhyUe.cc:                getParentModule()-> // nic
./stack/phy/layer/LtePhyUe.cc:                getParentModule()-> // nic
./stack/phy/layer/LtePhyUe.cc:                getSubmodule("nrRlc")->
./stack/phy/layer/LtePhyUe.cc:                getParentModule()-> // nic
./stack/phy/layer/LtePhyUe.cc:                getParentModule()-> // nic
./stack/phy/layer/LtePhyUe.cc:                getSubmodule("rlc")->
./stack/phy/layer/LtePhyUe.cc:            getParentModule()-> // nic
./stack/phy/layer/LtePhyUe.cc:                if (isNr_ && (*it)->nodeType != GNODEB)
./stack/phy/layer/LtePhyUe.cc:                if (!isNr_ && (*it)->nodeType != ENODEB)
./stack/phy/layer/LtePhyUe.cc:                MacNodeId cellId = (*it)->id;
./stack/phy/layer/LtePhyUe.cc:                LtePhyBase* cellPhy = check_and_cast<LtePhyBase*>((*it)->eNodeB->getSubmodule("cellularNic")->getSubmodule("phy"));
./stack/phy/layer/LtePhyUe.cc:                EV << "LtePhyUe::initialize - RSSI from cell " << cellId << ": " << rssi << " dB (current candidate cell " << candidateMasterId_ << ": " << candidateMasterRssi_ << " dB)" << endl;
./stack/phy/layer/LtePhyUe.cc:        EV << "LtePhyUe::initialize - Attaching to eNodeB " << masterId_ << endl;
./stack/phy/layer/LtePhyUe.cc:            int index = intuniform(0, binder_->phyPisaData.maxChannel() - 1);
./stack/phy/layer/LtePhyUe.cc:        EV << "Signal too weak from a candidate master - minRssi[" << minRssi_ << "]" << endl;
./stack/phy/layer/LtePhyUe.cc:        EV << NOW << " LtePhyUe::triggerHandover - UE " << nodeId_ << " lost its connection to eNB " << masterId_ << ". Now detaching... " << endl;
./stack/phy/layer/LtePhyUe.cc:        EV << NOW << " LtePhyUe::triggerHandover - UE " << nodeId_ << " is starting attachment procedure to eNB " << candidateMasterId_ << "... " << endl;
./stack/phy/layer/LtePhyUe.cc:        EV << NOW << " LtePhyUe::triggerHandover - UE " << nodeId_ << " is starting handover to eNB " << candidateMasterId_ << "... " << endl;
./stack/phy/layer/LtePhyUe.cc:    IP2Nic* ip2nic =  check_and_cast<IP2Nic*>(getParentModule()->getSubmodule("ip2nic"));
./stack/phy/layer/LtePhyUe.cc:        IP2Nic* enbIp2Nic =  check_and_cast<IP2Nic*>(getSimulation()->getModule(binder_->getOmnetId(masterId_))->getSubmodule("cellularNic")->getSubmodule("ip2nic"));
./stack/phy/layer/LtePhyUe.cc:    if(getParentModule()->getParentModule()->findSubmodule("ueCollector") != -1)
./stack/phy/layer/LtePhyUe.cc:        LteMacEnb* newMacEnb =  check_and_cast<LteMacEnb*>(getSimulation()->getModule(binder_->getOmnetId(candidateMasterId_))->getSubmodule("cellularNic")->getSubmodule("mac"));
./stack/phy/layer/LtePhyUe.cc:            int index = intuniform(0, binder_->phyPisaData.maxChannel() - 1);
./stack/phy/layer/LtePhyUe.cc:    fbGen = check_and_cast<LteDlFeedbackGenerator*>(getParentModule()->getSubmodule("dlFbGen"));
./stack/phy/layer/LtePhyUe.cc:        EV << NOW << " LtePhyUe::doHandover - UE " << nodeId_ << " detached from the network" << endl;
./stack/phy/layer/LtePhyUe.cc:        EV << NOW << " LtePhyUe::doHandover - UE " << nodeId_ << " has completed handover to eNB " << masterId_ << "... " << endl;
./stack/phy/layer/LtePhyUe.cc:    IP2Nic* ip2nic =  check_and_cast<IP2Nic*>(getParentModule()->getSubmodule("ip2nic"));
./stack/phy/layer/LtePhyUe.cc:        IP2Nic* enbIp2Nic =  check_and_cast<IP2Nic*>(getSimulation()->getModule(binder_->getOmnetId(masterId_))->getSubmodule("cellularNic")->getSubmodule("ip2nic"));
./stack/phy/layer/LtePhyUe.cc:        if (lteInfo->getUserTxParams()->readCqiVector().size() == 1)
./stack/phy/layer/LtePhyUe.cc:        double cqi = lteInfo->getUserTxParams()->readCqiVector()[cw];
./stack/phy/layer/LtePhyUe.cc:    RemoteSet r = lteInfo->getUserTxParams()->readAntennaSet();
./stack/phy/layer/LtePhyUe.cc:    if (getEnvir()->isGUI())
./stack/phy/layer/LtePhyUe.cc:        throw cRuntimeError("LtePhyUe::handleUpperMessage - Carrier frequency [%f] not supported by any channel model", carrierFreq);
./stack/phy/layer/LtePhyUe.cc:        double cqi = lteInfo->getUserTxParams()->readCqiVector()[lteInfo->getCw()];
./stack/phy/layer/LtePhyUe.cc:            err = avgCqi - *it;
./stack/phy/layer/LtePhyUe.cc:            err = avgCqi - *it;
./stack/phy/layer/LtePhyUe.cc:    if (getSimulation()->getSimulationStage() != CTX_FINISH)
./stack/phy/layer/LtePhyUeD2D.cc:        cModule* enb = getSimulation()->getModule(binder_->getOmnetId(masterId_));
./stack/phy/layer/LtePhyUeD2D.cc:        D2DModeSelectionBase *d2dModeSelection = check_and_cast<D2DModeSelectionBase*>(enb->getSubmodule("cellularNic")->getSubmodule("d2dModeSelection"));
./stack/phy/layer/LtePhyUeD2D.cc:    // Check if the frame is for us ( MacNodeId matches or - if this is a multicast communication - enrolled in multicast group)
./stack/phy/layer/LtePhyUeD2D.cc:        if (lteInfo->getUserTxParams()->readCqiVector().size() == 1)
./stack/phy/layer/LtePhyUeD2D.cc:        double cqi = lteInfo->getUserTxParams()->readCqiVector()[cw];
./stack/phy/layer/LtePhyUeD2D.cc:    RemoteSet r = lteInfo->getUserTxParams()->readAntennaSet();
./stack/phy/layer/LtePhyUeD2D.cc:    if (getEnvir()->isGUI())
./stack/phy/layer/LtePhyUeD2D.cc:        cModule* enb = getSimulation()->getModule(binder_->getOmnetId(masterId_));
./stack/phy/layer/LtePhyUeD2D.cc:        D2DModeSelectionBase *d2dModeSelection = check_and_cast<D2DModeSelectionBase*>(enb->getSubmodule("cellularNic")->getSubmodule("d2dModeSelection"));
./stack/phy/layer/LtePhyUeD2D.cc:        throw cRuntimeError("LtePhyUeD2D::handleUpperMessage - Carrier frequency [%f] not supported by any channel model", carrierFreq);
./stack/phy/layer/LtePhyUeD2D.cc:        double cqi = lteInfo->getUserTxParams()->readCqiVector()[lteInfo->getCw()];
./stack/phy/layer/LtePhyUeD2D.cc:    EV << NOW << " LtePhyUeD2D::handleUpperMessage - message from stack" << endl;
./stack/phy/layer/LtePhyUeD2D.cc:    frame->setControlInfo(lteInfo.get()->dup());
./stack/phy/layer/LtePhyUeD2D.cc:    EV << "LtePhyUeD2D::handleUpperMessage - " << nodeTypeToA(nodeType_) << " with id " << nodeId_
./stack/phy/layer/LtePhyUeD2D.cc:        throw cRuntimeError("LtePhyUeD2D::storeAirFrame - Carrier frequency [%f] not supported by any channel model", carrierFreq);
./stack/phy/layer/LtePhyUeD2D.cc:        EV << NOW << " LtePhyUeD2D::storeAirFrame - Average RSRP from node " << newInfo->getSourceId() << ": " << rsrpMean << endl;
./stack/phy/layer/LtePhyUeD2D.cc:        EV << NOW << " LtePhyUeD2D::storeAirFrame - Distance from node " << newInfo->getSourceId() << ": " << distance << endl;
./stack/phy/layer/LtePhyUeD2D.cc:    EV << NOW << " LtePhyUeD2D::decodeAirFrame - Start decoding..." << endl;
./stack/phy/layer/LtePhyUeD2D.cc:        throw cRuntimeError("LtePhyUeD2D::decodeAirFrame - Carrier frequency [%f] not supported by any channel model", carrierFreq);
./stack/phy/layer/LtePhyUeD2D.cc:    RemoteSet r = lteInfo->getUserTxParams()->readAntennaSet();
./stack/phy/layer/LtePhyUeD2D.cc:    // Note: no need to delete the frame itself - will be deleted later when the buffer of
./stack/phy/layer/LtePhyUeD2D.cc:    if (getEnvir()->isGUI())
./stack/phy/layer/LtePhyUeD2D.cc:    if (getSimulation()->getSimulationStage() != CTX_FINISH)
./stack/phy/layer/LtePhyUeD2D.h:    // ---------------------------------------------------------------- //
./stack/phy/layer/NRPhyUe.cc:            otherPhy_ = check_and_cast<NRPhyUe*>(getParentModule()->getSubmodule("phy"));
./stack/phy/layer/NRPhyUe.cc:            otherPhy_ = check_and_cast<NRPhyUe*>(getParentModule()->getSubmodule("nrPhy"));
./stack/phy/layer/NRPhyUe.cc:        int cw = (lteInfo->getUserTxParams()->readCqiVector().size() == 1) ? 0 : lteInfo->getCw();
./stack/phy/layer/NRPhyUe.cc:        double cqi = lteInfo->getUserTxParams()->readCqiVector()[cw];
./stack/phy/layer/NRPhyUe.cc:    RemoteSet r = lteInfo->getUserTxParams()->readAntennaSet();
./stack/phy/layer/NRPhyUe.cc:    if (getEnvir()->isGUI())
./stack/phy/layer/NRPhyUe.cc:                EV << NOW << " NRPhyUe::triggerHandover - Wait the handover completion for the other stack. Delay this handover." << endl;
./stack/phy/layer/NRPhyUe.cc:                EV << NOW << " NRPhyUe::triggerHandover - UE " << nodeId_ << " is canceling its handover to eNB " << candidateMasterId_ << " since the master is performing handover" << endl;
./stack/phy/layer/NRPhyUe.cc:        EV << NOW << " NRPhyUe::triggerHandover - Forcing detachment from " << otherPhy_->getMasterId() << " which is a secondary node to " << masterId_ << ". Delay this handover." << endl;
./stack/phy/layer/NRPhyUe.cc:        EV << NOW << " NRPhyUe::triggerHandover - UE " << nodeId_ << " is starting attachment procedure to eNB " << candidateMasterId_ << "... " << endl;
./stack/phy/layer/NRPhyUe.cc:        EV << NOW << " NRPhyUe::triggerHandover - UE " << nodeId_ << " lost its connection to eNB " << masterId_ << ". Now detaching... " << endl;
./stack/phy/layer/NRPhyUe.cc:        EV << NOW << " NRPhyUe::triggerHandover - UE " << nodeId_ << " is starting handover to eNB " << candidateMasterId_ << "... " << endl;
./stack/phy/layer/NRPhyUe.cc:    IP2Nic* ip2nic = check_and_cast<IP2Nic*>(getParentModule()->getSubmodule("ip2nic"));
./stack/phy/layer/NRPhyUe.cc:        cModule* enb = getSimulation()->getModule(binder_->getOmnetId(masterId_));
./stack/phy/layer/NRPhyUe.cc:            IP2Nic* enbIp2nic = check_and_cast<IP2Nic*>(enb->getSubmodule("cellularNic")->getSubmodule("ip2nic"));
./stack/phy/layer/NRPhyUe.cc:        D2DModeSelectionBase *d2dModeSelection = check_and_cast<D2DModeSelectionBase*>(enb->getSubmodule("cellularNic")->getSubmodule("d2dModeSelection"));
./stack/phy/layer/NRPhyUe.cc:    if(getParentModule()->getParentModule()->findSubmodule("NRueCollector") != -1)
./stack/phy/layer/NRPhyUe.cc:        cellInfo_ = check_and_cast<LteMacEnb*>(getSimulation()->getModule(binder_->getOmnetId(masterId_))
./stack/phy/layer/NRPhyUe.cc:                ->getSubmodule("cellularNic")->getSubmodule("mac"))->getCellInfo();
./stack/phy/layer/NRPhyUe.cc:            int index = intuniform(0, binder_->phyPisaData.maxChannel() - 1);
./stack/phy/layer/NRPhyUe.cc:        fbGen = check_and_cast<LteDlFeedbackGenerator*>(getParentModule()->getSubmodule("dlFbGen"));
./stack/phy/layer/NRPhyUe.cc:        fbGen = check_and_cast<LteDlFeedbackGenerator*>(getParentModule()->getSubmodule("nrDlFbGen"));
./stack/phy/layer/NRPhyUe.cc:        EV << NOW << " NRPhyUe::doHandover - UE " << nodeId_ << " detached from the network" << endl;
./stack/phy/layer/NRPhyUe.cc:        EV << NOW << " NRPhyUe::doHandover - UE " << nodeId_ << " has completed handover to eNB " << masterId_ << "... " << endl;
./stack/phy/layer/NRPhyUe.cc:    IP2Nic* ip2nic =  check_and_cast<IP2Nic*>(getParentModule()->getSubmodule("ip2nic"));
./stack/phy/layer/NRPhyUe.cc:        IP2Nic* enbIp2nic =  check_and_cast<IP2Nic*>(getSimulation()->getModule(binder_->getOmnetId(masterId_))->getSubmodule("cellularNic")->getSubmodule("ip2nic"));
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'ModulationType' as cValue -- field index out of range?", field);
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'AirFrame' as cValue -- field index out of range?", field);
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/AirFrame_m.h:    virtual inet::Coord& getSenderPosForUpdate() { return const_cast<inet::Coord&>(const_cast<AirFrame*>(this)->getSenderPos());}
./stack/phy/packet/AirFrame_m.h:    virtual ModulationType& getModulationTypeForUpdate() { return const_cast<ModulationType&>(const_cast<AirFrame*>(this)->getModulationType());}
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteAirFrame_Base' as cValue -- field index out of range?", field);
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteAirFrame_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteFeedbackPkt_Base' as cValue -- field index out of range?", field);
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/LteFeedbackPkt_m.cc:        field -= base->getFieldCount();
./stack/phy/packet/ModulationType.h:/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
./stack/rlc/am/buffer/AmRxQueue.cc:    lteRlc_ = check_and_cast<LteRlcAm *>(getParentModule()->getSubmodule("am"));
./stack/rlc/am/buffer/AmRxQueue.cc:        getParentModule()->getParentModule()->getSubmodule("mac"));
./stack/rlc/am/buffer/AmRxQueue.cc:    std::string defragmentedName(fragmentFrames.at(0)->getName());
./stack/rlc/am/buffer/AmRxQueue.cc:    int index = sn - rxWindowDesc_.firstSeqNum_;
./stack/rlc/am/buffer/AmRxQueue.cc:            throw cRuntimeError("RLC AM - Unknown status PDU");
./stack/rlc/am/buffer/AmRxQueue.cc:        // control PDU (not a DATA PDU) - completely processed
./stack/rlc/am/buffer/AmRxQueue.cc:    int index = tsn - rxWindowDesc_.firstSeqNum_;
./stack/rlc/am/buffer/AmRxQueue.cc:    auto header = check_and_cast<Packet*>(pduBuffer_.get(index))->peekAtFront<LteRlcAmPdu>();
./stack/rlc/am/buffer/AmRxQueue.cc:                auto frgId = p->peekAtFront<LteRlcAmPdu>()->getSnoMainPacket();
./stack/rlc/am/buffer/AmRxQueue.cc:            auto headerAux = check_and_cast<Packet*>(pduBuffer_.get(auxIndex))->peekAtFront<LteRlcAmPdu>();
./stack/rlc/am/buffer/AmRxQueue.cc:                frameBuff.push_back(check_and_cast<Packet*>(pduBuffer_.get(auxIndex))->dup());
./stack/rlc/am/buffer/AmRxQueue.cc:        pkt = (check_and_cast<Packet*>(pduBuffer_.get(index)))->dup();
./stack/rlc/am/buffer/AmRxQueue.cc:    double delay = (NOW - pkt->getCreationTime()).dbl();
./stack/rlc/am/buffer/AmRxQueue.cc:    double tputSample = (double)totalRcvdBytes_ / (NOW - getSimulation()->getWarmupPeriod());
./stack/rlc/am/buffer/AmRxQueue.cc:    double cellTputSample = (double)totalCellRcvdBytes_ / (NOW - getSimulation()->getWarmupPeriod());
./stack/rlc/am/buffer/AmRxQueue.cc:    // Get the SDU and pass it to the upper layers - PDU // SDU // PDCPPDU
./stack/rlc/am/buffer/AmRxQueue.cc:        EV << NOW << " AmRxQueue::checkCompleteSdu - complete SDU has been found (PDU at " << index << " was whole)" << endl;
./stack/rlc/am/buffer/AmRxQueue.cc:                for (int i = index - 1; i >= 0; i--)
./stack/rlc/am/buffer/AmRxQueue.cc:           << " AmRxQueue::checkCompleteSdu - SDU cannot be reconstructed, backward search didn't found any predecessors to PDU at "
./stack/rlc/am/buffer/AmRxQueue.cc:        EV << NOW << " AmRxQueue::checkCompleteSdu - complete SDU has been found, backward search was successful, and current was last of its SDU"
./stack/rlc/am/buffer/AmRxQueue.cc:        EV << NOW << " AmRxQueue::checkCompleteSdu - complete SDU has been found after forward search , passing up "
./stack/rlc/am/buffer/AmRxQueue.cc:    if ((NOW.dbl() - lastSentAck_.dbl()) < ackReportInterval_.dbl())
./stack/rlc/am/buffer/AmRxQueue.cc:        int lastSn = rxWindowDesc_.firstSeqNum_ + cumulative - 1;
./stack/rlc/am/buffer/AmRxQueue.cc:    int pos = seqNum - rxWindowDesc_.firstSeqNum_;
./stack/rlc/am/buffer/AmRxQueue.h:     *  given by  seqNum - current rx first seqnum.
./stack/rlc/am/buffer/AmTxQueue.cc:    lteRlc_ = check_and_cast<LteRlcAm *>(getParentModule()->getSubmodule("am"));
./stack/rlc/am/buffer/AmTxQueue.cc:    EV << NOW << " AmTxQueue::enque - inserting new SDU  " << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:        if (txWindowDesc_.seqNum_ - txWindowDesc_.firstSeqNum_ < txWindowDesc_.windowSize_)
./stack/rlc/am/buffer/AmTxQueue.cc:        B length = (i == rlcFragDesc.totalFragments_-1) ? B(frame->getTotalLength()) - offset : fragUnit;
./stack/rlc/am/buffer/AmTxQueue.cc:        pdu->setLastSn(rlcFragDesc.firstSn_ + rlcFragDesc.totalFragments_ - 1);
./stack/rlc/am/buffer/AmTxQueue.cc:        int txWindowIndex = tmp.seqNum_ - tmp.firstSeqNum_;
./stack/rlc/am/buffer/AmTxQueue.cc:    while ((txWindowDesc_.seqNum_ - txWindowDesc_.firstSeqNum_) < txWindowDesc_.windowSize_)
./stack/rlc/am/buffer/AmTxQueue.cc:            EV << NOW << " AmTxQueue::addPdus - No data to send " << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:            EV << NOW << " AmTxQueue::addPdus - No pending SDU has been found" << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:                lteInfo_ = currentSdu_->getTag<FlowControlInfo>()->dup();
./stack/rlc/am/buffer/AmTxQueue.cc:                // EV << NOW << " AmTxQueue::addPdus   cannot fragment new SDU since fragments do not fit - tx window is full" << std::endl;
./stack/rlc/am/buffer/AmTxQueue.cc:        EV << NOW << " AmTxQueue::addPdus - prepare new RLC PDU" << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:    EV << NOW << " AmTxQueue::addPdus - added " << addedPdus << " PDUs" << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:    int txWindowIndex = seqNum - txWindowDesc_.firstSeqNum_;
./stack/rlc/am/buffer/AmTxQueue.cc:        i < (txWindowDesc_.seqNum_ - txWindowDesc_.firstSeqNum_); ++i)
./stack/rlc/am/buffer/AmTxQueue.cc:            auto nextPdu = check_and_cast<Packet*>(pduRtxQueue_.get(i))->peekAtFront<LteRlcAmPdu>();
./stack/rlc/am/buffer/AmTxQueue.cc:    for (int i = txWindowIndex - 1; i >= 0; i--)
./stack/rlc/am/buffer/AmTxQueue.cc:        auto nextPdu = check_and_cast<Packet*>(pduRtxQueue_.get(i))->peekAtFront<LteRlcAmPdu>();
./stack/rlc/am/buffer/AmTxQueue.cc:    for (int i = 0; i < (txWindowDesc_.seqNum_ - txWindowDesc_.firstSeqNum_); ++i)
./stack/rlc/am/buffer/AmTxQueue.cc:    int pos = seqNum - txWindowDesc_.firstSeqNum_;
./stack/rlc/am/buffer/AmTxQueue.cc:    // Shift the tx window - pos is the location after the last PDU to be removed (pointing to the new firstSeqNum_).
./stack/rlc/am/buffer/AmTxQueue.cc:        i < ((txWindowDesc_.seqNum_ - txWindowDesc_.firstSeqNum_)); ++i)
./stack/rlc/am/buffer/AmTxQueue.cc:            pduRtxQueue_.addAt(i - pos, pdu);
./stack/rlc/am/buffer/AmTxQueue.cc:               << " being moved at position " << i - pos << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:           << "] corresponding new index " << i - pos
./stack/rlc/am/buffer/AmTxQueue.cc:           << " marked as received [" << (received_.at(i - pos))
./stack/rlc/am/buffer/AmTxQueue.cc:           << "] , discarded [" << (discarded_.at(i - pos)) << "]" << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:        received_.at(i - pos) = received_.at(i);
./stack/rlc/am/buffer/AmTxQueue.cc:        discarded_.at(i - pos) = discarded_.at(i);
./stack/rlc/am/buffer/AmTxQueue.cc:    for (int i = (txWindowDesc_.seqNum_ - txWindowDesc_.firstSeqNum_);
./stack/rlc/am/buffer/AmTxQueue.cc:       << txWindowDesc_.seqNum_ - txWindowDesc_.firstSeqNum_ << " to "
./stack/rlc/am/buffer/AmTxQueue.cc:       << txWindowDesc_.windowSize_ - 1 << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:    // pdu is not sent directly but queued - will be sent upon mac request
./stack/rlc/am/buffer/AmTxQueue.cc:        // next PDU does fit - pop it
./stack/rlc/am/buffer/AmTxQueue.cc:        // throw cRuntimeError("AmTxQueue::sendPdus cannot return current head of line PDU - size too small.");
./stack/rlc/am/buffer/AmTxQueue.cc:                  << " AmTxQueue::sendPdus: Cannot send PDU - PDU is larger than requested size (size == "
./stack/rlc/am/buffer/AmTxQueue.cc:    int index = seqNum - txWindowDesc_.firstSeqNum_;
./stack/rlc/am/buffer/AmTxQueue.cc:           << " AmTxBuffer::recvAck ACK already received - ignoring : index "
./stack/rlc/am/buffer/AmTxQueue.cc:        for (int i = 0; i <= (seqNum - txWindowDesc_.firstSeqNum_); ++i)
./stack/rlc/am/buffer/AmTxQueue.cc:    int index = sn - txWindowDesc_.firstSeqNum_;
./stack/rlc/am/buffer/AmTxQueue.cc:    EV << NOW << " AmTxQueue::pduTimerHandle - sequence number " << sn << endl;
./stack/rlc/am/buffer/AmTxQueue.cc:        EV << NOW << "AmTxBuffer::mrwTimerHandle newer MRW has been sent - no action has to be taken" << endl;
./stack/rlc/am/buffer/AmTxQueue.h:     * copy of LTE control info - used for sending down PDUs and control packets.
./stack/rlc/am/buffer/AmTxQueue.h:    //--------------------------------------------------------------------------------------
./stack/rlc/am/buffer/AmTxQueue.h:    //--------------------------------------------------------------------------------------
./stack/rlc/am/buffer/AmTxQueue.h:    //----------------------------------------------------------------------------------------
./stack/rlc/am/buffer/AmTxQueue.h:    //-------------------------------------------------------------------------
./stack/rlc/am/buffer/AmTxQueue.h:    //-------------------------------------------------------------------------
./stack/rlc/am/buffer/AmTxQueue.h:    //-------------------------------------------------------------------------
./stack/rlc/am/LteRlcAm.cc:    pkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&LteProtocol::pdcp);
./stack/rlc/am/LteRlcAm.cc:    pkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&LteProtocol::rlc);
./stack/rlc/am/LteRlcAm.cc:    EV << "LteRlcAm::sendNewDataPkt - Sending message " << newData->getName() << " to port AM_Sap_down$o\n";
./stack/rlc/am/LteRlcAm.cc:       << pkt->getArrivalGate()->getName() << endl;
./stack/rlc/am/LteRlcAm.h:     * - Adds the RLC-Am header to the packet, containing
./stack/rlc/am/LteRlcAm.h:     * - Search (or add) the proper TXBuffer, depending
./stack/rlc/am/LteRlcAm.h:     * - Calls the TXBuffer, that from now on takes
./stack/rlc/am/LteRlcAm.h:     * - Search (or add) the proper RXBuffer, depending
./stack/rlc/am/LteRlcAm.h:     * - Calls the RXBuffer, that from now on takes
./stack/rlc/am/LteRlcAm.h:     * - Search the proper TXBuffer, depending
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:    // field bitmap is abstract or custom -- please do packing in customized class
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:    // field bitmap is abstract or custom -- please do unpacking in customized class
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteRlcAmPdu_Base' as cValue -- field index out of range?", field);
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteRlcAmSdu' as cValue -- field index out of range?", field);
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/am/packet/LteRlcAmSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlc.ned:        tm.TM_Sap_up <--> TM_Sap;
./stack/rlc/LteRlc.ned:        um.UM_Sap_up <--> UM_Sap;
./stack/rlc/LteRlc.ned:        am.AM_Sap_up <--> AM_Sap;
./stack/rlc/LteRlc.ned:        tm.TM_Sap_down <--> mux.TM_Sap;
./stack/rlc/LteRlc.ned:        um.UM_Sap_down <--> mux.UM_Sap;
./stack/rlc/LteRlc.ned:        am.AM_Sap_down <--> mux.AM_Sap;
./stack/rlc/LteRlc.ned:        mux.MAC_to_RLC <-- MAC_to_RLC;
./stack/rlc/LteRlc.ned:        mux.RLC_to_MAC --> RLC_to_MAC;
./stack/rlc/LteRlcDefs.h:     * Main SDU size (bytes) - the size of  the SDU to be fragmented
./stack/rlc/LteRlcDefs.h:     * Fragmentation Unit (bytes) - the size of fragments the SDU will be divided into
./stack/rlc/LteRlcDefs.h:     * resets the fragmentation descriptor for working on SDU of size sduSize - frag unit is left untouched.
./stack/rlc/LteRlcDefs.h://  - 00: First and last chunk of the PDU are complete SDUs
./stack/rlc/LteRlcDefs.h://  - 01: First chunk is a complete SDU, last chunk is a fragment
./stack/rlc/LteRlcDefs.h://  - 10: First chunk is a fragment, last chunk is a complete SDU
./stack/rlc/LteRlcDefs.h://  - 11: First and last chunk of the PDU are fragments
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'RlcFragDesc' as cValue -- field index out of range?", field);
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'RlcWindowDesc' as cValue -- field index out of range?", field);
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'MrwDesc' as cValue -- field index out of range?", field);
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'RlcUmRxWindowDesc' as cValue -- field index out of range?", field);
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcDefs_m.cc:        field -= base->getFieldCount();
./stack/rlc/LteRlcMux.cc:    " from port " << pkt->getArrivalGate()->getName() << endl;
./stack/rlc/LteRlcMux.h: * - Traffic coming from TM/UM/AM modules is decoded
./stack/rlc/LteRlcMux.h: * - Traffic coming from MAC layer is decoded
./stack/rlc/packet/LteRlcDataPdu.h:            auto newPkt = (*sit)->dup();
./stack/rlc/packet/LteRlcDataPdu.h:        rlcPduLength_ -= (sduSizes_.front());
./stack/rlc/packet/LteRlcDataPdu.h:        numSdu_--;
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteRlcDataPdu_Base' as cValue -- field index out of range?", field);
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcDataPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteRlcPdu' as cValue -- field index out of range?", field);
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteRlcPduNewData' as cValue -- field index out of range?", field);
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcPdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteRlcSdu' as cValue -- field index out of range?", field);
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/packet/LteRlcSdu_m.cc:        field -= base->getFieldCount();
./stack/rlc/tm/LteRlcTm.cc:        // cannot queue - queue is full
./stack/rlc/tm/LteRlcTm.cc:    pkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&LteProtocol::rlc);
./stack/rlc/tm/LteRlcTm.cc:    EV << "LteRlcTm::handleUpperMessage - Sending message " << newDataPkt->getName() << " to port TM_Sap_down$o\n";
./stack/rlc/tm/LteRlcTm.cc:            EV << "LteRlcTm : Received " << pkt->getName() << " - sending packet " << rlcPduPkt->getName() << " to port TM_Sap_down$o\n";
./stack/rlc/tm/LteRlcTm.cc:            EV << "LteRlcTm : Received " << pkt->getName() << " but no PDUs buffered - nothing to send to MAC.\n";
./stack/rlc/tm/LteRlcTm.cc:        // pkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&LteProtocol::pdcp);
./stack/rlc/tm/LteRlcTm.cc:    " from port " << pkt->getArrivalGate()->getName() << endl;
./stack/rlc/tm/LteRlcTm.h: * - Transparent mode (TM):
./stack/rlc/um/entity/UmRxEntity.cc:    EV << NOW << " UmRxEntity::enque - buffering new PDU" << endl;
./stack/rlc/um/entity/UmRxEntity.cc:    int index = tsn - rxWindowDesc_.firstSno_;
./stack/rlc/um/entity/UmRxEntity.cc:    EV << NOW << " UmRxEntity::enque - tsn " << tsn << ", the corresponding index in the buffer is " << index << endl;
./stack/rlc/um/entity/UmRxEntity.cc:            int shift = rxWindowDesc_.highestReceivedSno_ - old;
./stack/rlc/um/entity/UmRxEntity.cc:                shift -= p;
./stack/rlc/um/entity/UmRxEntity.cc:    index = tsn - rxWindowDesc_.firstSno_;
./stack/rlc/um/entity/UmRxEntity.cc://    int rlcSduSize = (B(pdu->getChunkLength()) - B(RLC_HEADER_UM)).get(); // RLC pdu size - RLC header
./stack/rlc/um/entity/UmRxEntity.cc://    EV << "UmRxEntity::enque - RlcSdu of size " << rlcSduSize << " arrived" << endl;
./stack/rlc/um/entity/UmRxEntity.cc:    double tputSample = (double)totalPduRcvdBytes_ / (NOW - getSimulation()->getWarmupPeriod());
./stack/rlc/um/entity/UmRxEntity.cc:            ue->emit(rlcPduDelay_, (NOW - pktPdu->getCreationTime()).dbl());
./stack/rlc/um/entity/UmRxEntity.cc:            ue->emit(rlcPduDelayD2D_, (NOW - pktPdu->getCreationTime()).dbl());
./stack/rlc/um/entity/UmRxEntity.cc:    EV << NOW << " UmRxEntity::enque - tsn " << tsn << ", the corresponding index after shift in the buffer is " << index << endl;
./stack/rlc/um/entity/UmRxEntity.cc:    EV << NOW << " UmRxEntity::enque - firstSnoReordering " << rxWindowDesc_.firstSnoForReordering_ << endl;
./stack/rlc/um/entity/UmRxEntity.cc:        int index = old - rxWindowDesc_.firstSno_;
./stack/rlc/um/entity/UmRxEntity.cc:        for (unsigned int i = index; i < rxWindowDesc_.firstSnoForReordering_ - rxWindowDesc_.firstSno_; i++)
./stack/rlc/um/entity/UmRxEntity.cc:    * it is occurred if t1 - t2 > TTI
./stack/rlc/um/entity/UmRxEntity.cc:    LteRlcUm* lteRlc = check_and_cast<LteRlcUm*>(getParentModule()->getSubmodule("um"));
./stack/rlc/um/entity/UmRxEntity.cc:    double cellTputSample = (double)totalCellRcvdBytes_ / (NOW - getSimulation()->getWarmupPeriod());
./stack/rlc/um/entity/UmRxEntity.cc:    double tputSample = (double)totalRcvdBytes_ / (NOW - getSimulation()->getWarmupPeriod());
./stack/rlc/um/entity/UmRxEntity.cc:            ue->emit(rlcDelay_, (NOW - ts).dbl());
./stack/rlc/um/entity/UmRxEntity.cc:            ue->emit(rlcDelayD2D_, (NOW - ts).dbl());
./stack/rlc/um/entity/UmRxEntity.cc:                                (rlcSdu->getSnoMainPacket() != buffered_.pkt->peekAtFront<LteRlcSdu>()->getSnoMainPacket()) ||
./stack/rlc/um/entity/UmRxEntity.cc:                                (rlcSdu->getSnoMainPacket() != buffered_.pkt->peekAtFront<LteRlcSdu>()->getSnoMainPacket()) ||
./stack/rlc/um/entity/UmRxEntity.cc:                        EV << NOW << " UmRxEntity::reassemble The waiting SDU has size " << buffered_.size << " bytes, was " <<  buffered_.size - sduLengthPktLeng << " bytes" << endl;
./stack/rlc/um/entity/UmRxEntity.cc:                                (rlcSdu->getSnoMainPacket() != buffered_.pkt->peekAtFront<LteRlcSdu>()->getSnoMainPacket()) ||
./stack/rlc/um/entity/UmRxEntity.cc:    cModule* parent = check_and_cast<LteRlcUm*>(getParentModule()->getSubmodule("um"));
./stack/rlc/um/entity/UmRxEntity.cc:    if (strcmp(getParentModule()->getFullName(),"nrRlc") == 0)
./stack/rlc/um/entity/UmRxEntity.cc:        mac = check_and_cast<LteMacBase*>(getParentModule()->getParentModule()->getSubmodule("nrMac"));
./stack/rlc/um/entity/UmRxEntity.cc:        mac = check_and_cast<LteMacBase*>(getParentModule()->getParentModule()->getSubmodule("mac"));
./stack/rlc/um/entity/UmRxEntity.cc:        int index = old - rxWindowDesc_.firstSno_;
./stack/rlc/um/entity/UmRxEntity.cc:        for (unsigned int i = index; i < rxWindowDesc_.firstSnoForReordering_ - rxWindowDesc_.firstSno_; i++)
./stack/rlc/um/entity/UmRxEntity.cc:        ttiBits_ -= buffered_.size; // remove the discarded SDU size from the tput
./stack/rlc/um/entity/UmRxEntity.cc:            EV << NOW << " UmRxEntity::rlcHandleD2DModeSwitch - nothing to do on DL leg of IM flow" << endl;
./stack/rlc/um/entity/UmRxEntity.cc:            EV << NOW << " UmRxEntity::rlcHandleD2DModeSwitch - clear RX buffer of the RLC entity associated to the old mode" << endl;
./stack/rlc/um/entity/UmRxEntity.cc:        EV << NOW << " UmRxEntity::rlcHandleD2DModeSwitch - handle numbering of the RLC entity associated to the new selected mode" << endl;
./stack/rlc/um/entity/UmRxEntity.cc:     *   - if 0:
./stack/rlc/um/entity/UmRxEntity.cc:     *  - if 1:
./stack/rlc/um/entity/UmRxEntity.cc:    EV_FATAL << "UmRxEntity::handleBurst - size: " << pduBuffer_.size() + ((buffered_.pkt== NULL)?0 : 1) << endl;
./stack/rlc/um/entity/UmRxEntity.cc:            // the second last, in the simulator t1 - t2 is 0.
./stack/rlc/um/entity/UmRxEntity.cc:            if((t1_ - t2_) > TTI)
./stack/rlc/um/entity/UmRxEntity.cc:                EV_FATAL << "BURST ENDED - size : " << totalBits_ << endl;
./stack/rlc/um/entity/UmRxEntity.cc:            EV_FATAL << "NO BURST - size : " << totalBits_ << endl;
./stack/rlc/um/entity/UmRxEntity.cc:                EV_FATAL << "BURST CONTINUE - size : " << totalBits_ << endl;
./stack/rlc/um/entity/UmRxEntity.cc:            EV_FATAL << "BURST STARTED - size : " << totalBits_ << endl;
./stack/rlc/um/entity/UmTxEntity.cc:    if (strcmp(getParentModule()->getFullName(),"nrRlc") == 0)
./stack/rlc/um/entity/UmTxEntity.cc:        mac = check_and_cast<LteMacBase*>(getParentModule()->getParentModule()->getSubmodule("nrMac"));
./stack/rlc/um/entity/UmTxEntity.cc:        mac = check_and_cast<LteMacBase*>(getParentModule()->getParentModule()->getSubmodule("mac"));
./stack/rlc/um/entity/UmTxEntity.cc:    lteRlc_ = check_and_cast<LteRlcUm*>(getParentModule()->getSubmodule("um"));
./stack/rlc/um/entity/UmTxEntity.cc:        if(getParentModule()->getParentModule()->findSubmodule("packetFlowManager") != -1)
./stack/rlc/um/entity/UmTxEntity.cc:            EV << "UmTxEntity::initialize - RLC layer if of a base station" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:            packetFlowManager_ = check_and_cast<PacketFlowManagerEnb *>(getParentModule()->getParentModule()->getSubmodule("packetFlowManager"));
./stack/rlc/um/entity/UmTxEntity.cc:        if(strcmp(lteRlc_->getParentModule()->getName(), "nrRlc") == 0)
./stack/rlc/um/entity/UmTxEntity.cc:            if(getParentModule()->getParentModule()->findSubmodule("nrPacketFlowManager") != -1)
./stack/rlc/um/entity/UmTxEntity.cc:                EV << "UmTxEntity::initialize - RLC layer is NRRlc, cast the packetFlowManager to NR" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                packetFlowManager_ = check_and_cast<PacketFlowManagerUe *>(getParentModule()->getParentModule()->getSubmodule("nrPacketFlowManager"));
./stack/rlc/um/entity/UmTxEntity.cc:            if(getParentModule()->getParentModule()->findSubmodule("packetFlowManager") != -1)
./stack/rlc/um/entity/UmTxEntity.cc:                EV << "UmTxEntity::initialize - RLC layer, cast the packetFlowManager " << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                packetFlowManager_ = check_and_cast<PacketFlowManagerUe *>(getParentModule()->getParentModule()->getSubmodule("packetFlowManager"));
./stack/rlc/um/entity/UmTxEntity.cc:    EV << NOW << " UmTxEntity::enque - bufferize new SDU  " << endl;
./stack/rlc/um/entity/UmTxEntity.cc:        // Buffer is full - cannot enqueue packet
./stack/rlc/um/entity/UmTxEntity.cc:    EV << NOW << " UmTxEntity::rlcPduMake - PDU with size " << pduLength << " requested from MAC"<< endl;
./stack/rlc/um/entity/UmTxEntity.cc:    pduLength -= RLC_HEADER_UM;
./stack/rlc/um/entity/UmTxEntity.cc:        EV << NOW << " UmTxEntity::rlcPduMake - Next data chunk from the queue, sduSno[" << sduSequenceNumber
./stack/rlc/um/entity/UmTxEntity.cc:            EV << NOW << " UmTxEntity::rlcPduMake - Add " << sduLength << " bytes to the new SDU, sduSno[" << sduSequenceNumber << "]" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:            pduLength -= sduLength;
./stack/rlc/um/entity/UmTxEntity.cc:            queueLength_ -= pkt->getByteLength();
./stack/rlc/um/entity/UmTxEntity.cc:            EV << NOW << " UmTxEntity::rlcPduMake - Pop data chunk from the queue, sduSno[" << sduSequenceNumber << "]" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:            EV << NOW << " UmTxEntity::rlcPduMake - The new SDU has length " << len << ", left space is " << pduLength << endl;
./stack/rlc/um/entity/UmTxEntity.cc:            EV << NOW << " UmTxEntity::rlcPduMake - Add " << pduLength << " bytes to the new SDU, sduSno[" << sduSequenceNumber << "]" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                fragmentInfo->size -= pduLength;
./stack/rlc/um/entity/UmTxEntity.cc:                fragmentInfo->size = sduLength - pduLength;
./stack/rlc/um/entity/UmTxEntity.cc:            int newLength = sduLength - pduLength;
./stack/rlc/um/entity/UmTxEntity.cc:            EV << NOW << " UmTxEntity::rlcPduMake - Data chunk in the queue is now " << newLength << " bytes, sduSno[" << sduSequenceNumber << "]" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:            EV << NOW << " UmTxEntity::rlcPduMake - The new SDU has length " << len << ", left space is " << pduLength << endl;
./stack/rlc/um/entity/UmTxEntity.cc:        EV << NOW << " UmTxEntity::rlcPduMake - cannot send PDU with data, pdulength requested by MAC (" << pduLength << "B) is too small." << std::endl;
./stack/rlc/um/entity/UmTxEntity.cc:                    EV << NOW << " UmTxEntity::burstStatus - ACTIVE -> INACTIVE" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                    EV << NOW << " UmTxEntity::burstStatus - "<< burstStatus_ << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                    EV << NOW << " UmTxEntity::burstStatus - INACTIVE -> ACTIVE" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                    EV << NOW << " UmTxEntity::burstStatus - burstStatus: "<< burstStatus_ << endl;
./stack/rlc/um/entity/UmTxEntity.cc:    EV << NOW << " UmTxEntity::rlcPduMake - send PDU " << rlcPdu->getPduSequenceNumber() << " with size " << pkt->getByteLength() << " bytes to lower layer" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:    EV << NOW << " UmTxEntity::removeDataFromQueue - removed SDU " << endl;
./stack/rlc/um/entity/UmTxEntity.cc:    queueLength_ -= retPkt->getByteLength();
./stack/rlc/um/entity/UmTxEntity.cc:    EV << NOW << " UmTxEntity::enqueHoldingPackets - storing new SDU into the holding buffer " << endl;
./stack/rlc/um/entity/UmTxEntity.cc:    EV << NOW << " UmTxEntity::resumeDownstreamInPackets - resume buffering incoming downstream packets of the RLC entity associated to the new mode" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:        	// Queue is full - drop SDU
./stack/rlc/um/entity/UmTxEntity.cc:            EV << "UmTxEntity::resumeDownstreamInPackets - cannot buffer SDU (queue is full), dropping" << std::endl;
./stack/rlc/um/entity/UmTxEntity.cc:            EV << NOW << " UmRxEntity::rlcHandleD2DModeSwitch - nothing to do on DL leg of IM flow" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:            EV << NOW << " UmTxEntity::rlcHandleD2DModeSwitch - clear TX buffer of the RLC entity associated to the old mode" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                EV << NOW << " UmTxEntity::rlcHandleD2DModeSwitch - check when TX buffer the RLC entity associated to the old mode becomes empty - queue length[" << sduQueue_.getLength() << "]" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                EV << NOW << " UmTxEntity::rlcHandleD2DModeSwitch - TX buffer of the RLC entity associated to the old mode is already empty" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:        EV << " UmTxEntity::rlcHandleD2DModeSwitch - reset numbering of the RLC TX entity corresponding to the new mode" << endl;
./stack/rlc/um/entity/UmTxEntity.cc:                EV << NOW << " UmTxEntity::rlcHandleD2DModeSwitch - halt incoming downstream connections of the RLC entity associated to the new mode" << endl;
./stack/rlc/um/entity/UmTxEntity.h: * - When a RLC SDU is received from upper layer:
./stack/rlc/um/entity/UmTxEntity.h: * - When lower layer requests for a RLC PDU, this module invokes
./stack/rlc/um/entity/UmTxEntity.h: * - The newly created SDU is encapsulated into a RLC PDU and sent
./stack/rlc/um/LteRlcUm.cc:        throw cRuntimeError("LteRlcUm::getTxBuffer - lteInfo is NULL pointer. Aborting.");
./stack/rlc/um/LteRlcUm.cc:    pkt->addTagIfAbsent<inet::PacketProtocolTag>()->setProtocol(&LteProtocol::rlc);
./stack/rlc/um/LteRlcUm.cc:    EV << "LteRlcUm::handleUpperMessage - Received packet " << chunk->getClassName() << " from upper layer, size " << pktAux->getByteLength() << "\n";
./stack/rlc/um/LteRlcUm.cc:        EV << "LteRlcUm::handleUpperMessage - Enque packet " << rlcPkt->getClassName() << " into the Holding Buffer\n";
./stack/rlc/um/LteRlcUm.cc:            EV << "LteRlcUm::handleUpperMessage - Enque packet " << rlcPkt->getClassName() << " into the Tx Buffer\n";
./stack/rlc/um/LteRlcUm.cc:            EV << "LteRlcUm::handleUpperMessage - Sending message " << newDataPkt->getClassName() << " to port UM_Sap_down$o\n";
./stack/rlc/um/LteRlcUm.cc:            // Queue is full - drop SDU
./stack/rlc/um/LteRlcUm.cc:    EV << "LteRlcUm::handleLowerMessage - Received packet " << pkt->getName() << " from lower layer\n";
./stack/rlc/um/LteRlcUm.cc:        EV << "LteRlcUm::handleLowerMessage - Enque packet " << pkt->getName() << " into the Rx Buffer\n";
./stack/rlc/um/LteRlcUm.cc:    EV << "LteRlcUm : Received packet " << pkt->getName() << " from port " << pkt->getArrivalGate()->getName() << endl;
./stack/rlc/um/LteRlcUm.h: * - Unacknowledged mode (UM):
./stack/rlc/um/LteRlcUm.h:     * - Adds the RLC-UM header to the packet, containing
./stack/rlc/um/LteRlcUm.h:     * - Search (or add) the proper TXBuffer, depending
./stack/rlc/um/LteRlcUm.h:     * - Calls the TXBuffer, that from now on takes
./stack/rlc/um/LteRlcUm.h:     * - Search (or add) the proper RXBuffer, depending
./stack/rlc/um/LteRlcUm.h:     * - Calls the RXBuffer, that from now on takes
./stack/rlc/um/LteRlcUmD2D.cc:        throw cRuntimeError("LteRlcUmD2D::getTxBuffer - lteInfo is NULL pointer. Aborting.");
./stack/rlc/um/LteRlcUmD2D.cc:        EV << NOW << " LteRlcUmD2D::handleLowerMessage - Received packet " << pkt->getName() << " from lower layer\n";
./stack/rlc/um/LteRlcUmD2D.cc:            EV << "LteRlcUmD2D::handleLowerMessage - Sending packet " << pkt->getName() << " to port UM_Sap_up$o\n";
./stack/rlc/um/LteRlcUmD2D.cc:        if ((*it)->isHoldingDownstreamInPackets())
./stack/rlc/um/LteRlcUmD2D.cc:            (*it)->resumeDownstreamInPackets();
./stack/rlc/um/LteRlcUmD2D.cc:    EV << NOW << " LteRlcUmD2D::isEmptyingTxBuffer - peerId " << peerId << endl;
./stack/rlc/um/LteRlcUmD2D.cc:        if ((*it)->isEmptyingBuffer())
./stack/rlc/um/LteRlcUmD2D.cc:            EV << NOW << " LteRlcUmD2D::isEmptyingTxBuffer - found " << endl;
./stack/rlc/um/LteRlcUmD2D.h:     * - Search (or add) the proper RXBuffer, depending
./stack/rlc/um/LteRlcUmD2D.h:     * - Calls the RXBuffer, that from now on takes
./world/radio/ChannelAccess.cc:        IChannelControl *cc = dynamic_cast<IChannelControl *>(getSimulation()->findModuleByPath("channelControl"));
./world/radio/ChannelAccess.cc:    IChannelControl *cc = dynamic_cast<IChannelControl *>(getSimulation()->findModuleByPath("channelControl"));
./world/radio/ChannelAccess.cc:    if ( (strcmp(hostModule->getFullName(), source->getParentModule()->getFullName()) != 0) )
./world/radio/ChannelAccess.h:    virtual omnetpp::cPar& getChannelControlPar(const char *parName) { return dynamic_cast<omnetpp::cModule *>(cc)->par(parName); }
./world/radio/ChannelControl.cc:    // NICs switching channels -- so there's no point doing it if there's only
./world/radio/ChannelControl.cc:    if (simTime() - lastOngoingTransmissionsUpdate > TRANSMISSION_PURGE_INTERVAL)
./world/radio/ChannelControl.cc:            check_and_cast<cSimpleModule*>(srcRadio->radioModule)->sendDirect(airFrame->dup(), delay, airFrame->getDuration(), r->radioInGate);
./world/radio/LteChannelControl.cc:        check_and_cast<cSimpleModule*>(srcRadio->radioModule)->sendDirect(airFrame->dup(), delay, airFrame->getDuration(), r->radioInGate);
./x2/LteX2App.ned:// - a server that sends data to the peering X2App
./x2/LteX2App.ned:// - a client that receive data from the peering X2App
./x2/LteX2App.ned:        sctpIn[0] --> client.socketIn;
./x2/LteX2App.ned:        sctpOut[0] <-- client.socketOut;
./x2/LteX2App.ned:        sctpIn[1] --> server.socketIn;
./x2/LteX2App.ned:        sctpOut[1] <-- server.socketOut;
./x2/LteX2App.ned:        x2ManagerIn --> server.x2ManagerIn;
./x2/LteX2App.ned:        x2ManagerOut <-- client.x2ManagerOut;
./x2/LteX2Manager.cc:        IInterfaceTable *interfaceTable =  configurator->findInterfaceTableOf(getParentModule()->getParentModule());
./x2/LteX2Manager.cc:                const Ipv4Address addr = NetworkInterface->getProtocolData<Ipv4InterfaceData>()->getIPAddress();
./x2/LteX2Manager.cc:                getBinder()->setX2NodeId(addr, nodeId_);
./x2/LteX2Manager.cc:            //                                                  x2  -> X2App.x2ManagerIn ->  X2App.client
./x2/LteX2Manager.cc:            X2AppClient* client = check_and_cast<X2AppClient*>(inGate->getPathStartGate()->getOwnerModule());
./x2/LteX2Manager.cc:            X2NodeId peerId = getBinder()->getX2NodeId(addr.toIpv4());
./x2/LteX2Manager.cc:        EV << "LteX2Manager::handleMessage - Received message from LTE stack" << endl;
./x2/LteX2Manager.cc:            EV << "LteX2Manager::handleMessage - Received message from X2-GTP" << endl;
./x2/LteX2Manager.cc:            EV << "LteX2Manager::handleMessage - Received message from X2, gate " << gateIndex << endl;
./x2/LteX2Manager.cc:        int gateIndex = pkt->getArrivalGate()->getIndex();
./x2/LteX2Manager.cc:        EV << " LteX2Manager::fromX2 - Unknown type of the X2 message. Discard." << endl;
./x2/LteX2Manager.cc:    EV << "LteX2Manager::fromX2 - send X2MSG to LTE stack" << endl;
./x2/packet/LteX2Message.h:            ieList_.push_back((*it)->dup());
./x2/packet/LteX2Message.h:        msgLength_ -= ie->getLength();
./x2/packet/LteX2Message.h:        // (chunk length can therefore not be adapted - we only adapt the separate msg_Length_)
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'LteX2Message_Base' as cValue -- field index out of range?", field);
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'X2InformationElement_Base' as cValue -- field index out of range?", field);
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2Message_m.cc:        field -= base->getFieldCount();
./x2/packet/LteX2MsgSerializer.cc:    // note: length does not need to be serialized - is calculated during deserialization
./x2/packet/LteX2MsgSerializer.cc:    int64_t remainders = B(msg->getChunkLength() - (stream.getLength() - startPosition)).get();
./x2/packet/LteX2MsgSerializer.cc:        throw cRuntimeError("LteX2Msg length = %d smaller than required %d bytes", (int)B(msg->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./x2/packet/LteX2MsgSerializer.cc:        throw cRuntimeError("LteX2Msg length = %d larger than serialized %d bytes", (int)B(msg->getChunkLength()).get(), (int)B(stream.getLength() - startPosition).get());
./x2/packet/X2ControlInfo.msg:// - The X2 ID of the source eNodeB
./x2/packet/X2ControlInfo.msg:// - The X2 IDs of the destination eNodeBs (as a user can send an InformationElement to several peers)
./x2/packet/X2ControlInfo.msg:// - a 'init' flag: if set, the X2 Manager uses the IE and the incoming gate to register the user module  
./x2/packet/X2ControlInfo.msg:// - Source X2 ID
./x2/packet/X2ControlInfo.msg:// - List of destionation IDs
./x2/packet/X2ControlInfo.msg:// - init flag
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'DestinationIdList' as cValue -- field index out of range?", field);
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'X2ControlInfoTag' as cValue -- field index out of range?", field);
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.cc:        field -= base->getFieldCount();
./x2/packet/X2ControlInfo_m.h: * // - Source X2 ID
./x2/packet/X2ControlInfo_m.h: * // - List of destionation IDs
./x2/packet/X2ControlInfo_m.h: * // - init flag
./x2/packet/X2ControlInfo_m.h:    virtual DestinationIdList& getDestIdListForUpdate() { return const_cast<DestinationIdList&>(const_cast<X2ControlInfoTag*>(this)->getDestIdList());}
./x2/packet/X2InformationElement.h:    COMP_REQUEST_IE,         // CoMP slave -> master
./x2/packet/X2InformationElement.h:    COMP_REPLY_IE,           // CoMP master -> slave
./x2/packet/X2InformationElement.h:    COMP_PROP_REQUEST_IE,    // CoMP slave -> master (for compManagerProportional, with RB value)
./x2/packet/X2InformationElement.h:    COMP_PROP_REPLY_IE,      // CoMP master -> slave (for compManagerProportional, with map)
./x2/packet/X2InformationElement.h:    X2_HANDOVER_CMD_IE       // HO command source eNB -> target eNB
./x2/X2AppClient.cc:        X2NodeId peerId = getBinder()->getX2NodeId(addr.toIpv4());
./x2/X2AppClient.cc:        X2NodeId nodeId = check_and_cast<LteMacEnb*>(getParentModule()->getParentModule()->getSubmodule("cellularNic")->getSubmodule("mac"))->getMacCellId();
./x2/X2AppClient.cc:        getBinder()->setX2PeerAddress(nodeId, peerId, addr);
./x2/X2AppClient.cc:        int connectPort = getBinder()->getX2Port(peerId);
./x2/X2AppClient.cc:    EV << "X2AppClient::socketDataArrived - Client received packet Nr " << packetsRcvd << " from Sctp\n";
./x2/X2AppClient.cc:        EV << "X2AppClient::socketDataArrived - Forwarding packet to the X2 manager" << endl;
./x2/X2AppClient.cc:        EV << "X2AppClient::socketDataArrived - No encapsulated message. Discard." << endl;
./x2/X2AppServer.cc:        getBinder()->registerX2Port(id, localPort);
./x2/X2AppServer.cc:    pkt->addTag<DispatchProtocolReq>()->setProtocol(&Protocol::sctp);
./x2/X2AppServer.cc:        EV << "X2AppServer::handleMessage - Received message from x2 manager" << endl;
./x2/X2AppServer.cc:        EV << "X2AppServer::handleMessage - Forwarding to X2 interface" << endl;
